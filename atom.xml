<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小狐濡尾]]></title>
  <subtitle><![CDATA[未济]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://starding.github.io/"/>
  <updated>2016-03-19T06:42:16.000Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name><![CDATA[starding]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[什么是模态框]]></title>
    <link href="http://starding.github.io/2016/03/19/model-dialog/"/>
    <id>http://starding.github.io/2016/03/19/model-dialog/</id>
    <published>2016-03-19T05:19:32.000Z</published>
    <updated>2016-03-19T06:42:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4EC0_u4E48_u662F_u6A21_u6001_u6846_uFF08modal_dialog_uFF09"><a href="#u4EC0_u4E48_u662F_u6A21_u6001_u6846_uFF08modal_dialog_uFF09" class="headerlink" title="什么是模态框（modal dialog）"></a>什么是模态框（modal dialog）</h1><h2 id="u95EE_u9898_u6765_u6E90"><a href="#u95EE_u9898_u6765_u6E90" class="headerlink" title="问题来源"></a>问题来源</h2><p>在学习前端的时候，我遇到一个让人费解的词：「模态框」，它对应的是一种特殊的弹出式窗口，当然一时之间也很难说清楚到底特殊在什么地方，以及这样的弹窗与其他类型的弹出式窗口的核心区别在哪里。与「对话框」，「面板」这些词汇对应的窗体不同，「模态」这个词处处透漏着一种玄乎的感觉，很难直观的感受到它到底是个啥，又想要通过这个词来表达什么，你会不自觉的感到困惑：啥叫模态？</p>
<p>在计算机领域的词汇中，我一直抱有这样一种信念：如果一个词汇显得玄乎，那它背后肯定隐藏着更多的东西，或许是某些<a href="http://metaphor.space/2016/02/26/metaphor/" target="_blank" rel="external">隐喻</a>，或许是一些更深层次的设计原理等等。无论如何，都值得去好好调查一番这些词汇背后的含义，一不小心可能这个小小的词汇就成了通往一个饶有趣味的世界的门径。</p>
<h2 id="u4EC0_u4E48_u662F_u300C_u6A21_u6001_u300D_uFF1F"><a href="#u4EC0_u4E48_u662F_u300C_u6A21_u6001_u300D_uFF1F" class="headerlink" title="什么是「模态」？"></a>什么是「模态」？</h2><p>要理解模态框的含义，除了先用眼睛看看这个词汇对应的东西到底是个啥（可以找bootstrap的模态框组件体验）之外，最应该干的事情，就是先搞明白「模态」的含义了。</p>
<p><strong>模态，英文词汇叫modal</strong></p>
<p>先看看「模态」的字典解释：模式的，情态的，形式的。</p>
<p>再看看使用这个词汇组合出来的一些让人莫名其妙的专业词汇。</p>
<ul>
<li>模态分析</li>
<li>模态矩阵</li>
<li>模态逻辑</li>
<li>模态框</li>
</ul>
<p>我们可以猜想一下这个词汇的引入情景，或者说从英文词汇modal翻译成汉语的情形：想要表达一种特定状态下的内容，那该怎么翻译比较好呢？我们知道「模型」这个词有「一种事物的固定抽象」的含义，那么它可以表达一种「固定模式的含义」，而「状态」一词，可以表示事物在某种情形下的表现。这两者结合一下，「模态」这个词便呼之欲出了。当然，实际的翻译和词汇创造肯定远远比上面描述的情况复杂，但核心思想是一致的，也即：如何信达雅的表示出一个事物的概念。</p>
<p>经过这样的分析，我们可以说算是对「模态」这个词稍有了解了，它指的是<strong>某种特定的状态</strong>。</p>
<p>那再来看看上面那些专业词汇，就比较容易理解了，也就是说他们都有一种「研究某些特定状态下的事物」的意思。</p>
<h2 id="u4EC0_u4E48_u662F_u300C_u6A21_u6001_u6846_u300D"><a href="#u4EC0_u4E48_u662F_u300C_u6A21_u6001_u6846_u300D" class="headerlink" title="什么是「模态框」"></a>什么是「模态框」</h2><p>有了上面的词汇理解基础，我们可以继续往下说模态框的概念了。从字面意思上来看，它指的应当是「某种特定状态下的窗体」。</p>
<p>当然，这样来看，可能仍然有些难以理解。这是因为我们缺了另外一些东西造成的，就是「模态框」这个东西使用的环境，只有加入这些内容才能让我们的理解完整。</p>
<p>那么模态框使用的环境是什么？当然，这个词是在软件领域产生的，我们可以先看看普通的软件使用流程。在使用软件的时候，我们一般都会按照自己的思路一步步操作，比如我们在使用一个购物系统，我们会按照我们对这个软件的固有理解来执行自己脑中的流程：选购商品，加入购物车，下单付款等等。这些流程可以说是我们使用软件时的一种<strong>「正常状态」</strong>。</p>
<p>「模态框」这种『特定状态下的窗体』正是相对于这种正常状态来说的。模态框是出于一种特定状态下的窗体，<strong>它会把我们从正常状态中中断出来，将关注点放在这个特定状态的处理上。</strong>可以看看模态框的实际表现：当模态框出现的时候，它会屏蔽掉所有其他操作，用户可关注的范围只限于当前的模态框内部，除非你特意去关闭这个模态框，结束这种中断，回到原先正常的流程中去。</p>
<p>上面所描述的就是模态框的核心思想。其实准确地说，模态框是一个UI设计领域的概念，维基百科的定义是：</p>
<blockquote>
<h3 id="model_window"><a href="#model_window" class="headerlink" title="model window"></a>model window</h3><p>In user interface design, a modal window is a graphical control element subordinate to an application’s main window which creates a mode where the main window can’t be used. The modal window is a child window that requires users to interact with it before it can return to operating the parent application, thus preventing the workflow on the application main window. Modal windows are often called heavy windows or modal dialogs because the window is often used to display a dialog box.</p>
<p>Modal windows are commonly used in GUI systems to command user awareness and to display emergency states, although they have been argued to be ineffective for that use. Modal windows are prone to produce mode errors.</p>
</blockquote>
<p>当然模态框这种设计理念，暗含着一种强制性的思路。它强制用户的关注点从正常思维流中抽出来，来关注模态框内的内容，有些强制思考的意味。这种设计理念一般用在比较危险的操作的提示上。</p>
<p>但是对模态框的批评也是多种多样，主要是批评这种强制性的设计思路，以及它是否应被更好的方案代替等等，更有些观点宣称模态框是「邪恶的」。关于这些批评，可以参考下面一些资料：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/361493/why-are-modal-dialog-boxes-evil" target="_blank" rel="external">Why are modal dialog boxes evil?</a></li>
<li><a href="http://alistapart.com/article/neveruseawarning" target="_blank" rel="external">Never Use a Warning When you Mean Undo</a></li>
</ul>
<h2 id="u300C_u975E_u6A21_u6001_u300D"><a href="#u300C_u975E_u6A21_u6001_u300D" class="headerlink" title="「非模态」"></a>「非模态」</h2><p>有模态的概念，当然也有非模态的概念，关于非模态概念，本文暂时按下不表。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4EC0_u4E48_u662F_u6A21_u6001_u6846_uFF08modal_dialog_uFF09"><a href="#u4EC0_u4E48_u662F_u6A21_u6001_u6846_uFF08modal_dialog_uFF09" ]]>
    </summary>
    
      <category term="前端" scheme="http://starding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[html5设计原理]]></title>
    <link href="http://starding.github.io/2016/03/19/html5-design-principle/"/>
    <id>http://starding.github.io/2016/03/19/html5-design-principle/</id>
    <published>2016-03-19T03:39:52.000Z</published>
    <updated>2016-03-19T07:00:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="html5_u8BBE_u8BA1_u539F_u7406"><a href="#html5_u8BBE_u8BA1_u539F_u7406" class="headerlink" title="html5设计原理"></a>html5设计原理</h1><h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之所以取个这么大的标题，是因为这是一篇翻译稿的标题。个人认为这篇演讲的翻译稿非常符合个人的思维习惯，而且网上没有一个比较好的版本，故单读整理出来，形成一篇转载文章。</p>
<p>前一段时间，我们小组一直有一个争论，就是在时间传输的时候，到底是使用utc时间，还是使用unix时间戳。个人坚持的观点就是「先为人设计，再为机器设计」，赞同语义化更强的utc时间。</p>
<p>上面的事是想说明，有时候我们做出一件决策，并非是根据一时的想法，而应该去遵循一些明显经过时间检验的设计原则行事。尤其是一些两难的选择时，遵循一些这个领域的原则，可能会带来意象不到的好处。</p>
<p>而我们在关注一件新事物，比如html5时，不仅仅只是看它出现了那些新元素，新api等等。而是应该考虑这背后的一些设计理念以及发展历程，它解决了什么痛点等等。</p>
<h2 id="u6B63_u6587"><a href="#u6B63_u6587" class="headerlink" title="正文"></a>正文</h2><h3 id="HTML5_u8BBE_u8BA1_u539F_u7406"><a href="#HTML5_u8BBE_u8BA1_u539F_u7406" class="headerlink" title="HTML5设计原理"></a>HTML5设计原理</h3><p>2010年10月21日 <a href="http://www.cn-cuckoo.com/category/web" target="_blank" rel="external">Web开发</a>, 翻译.(不清楚博主的这篇翻译文章为什么没了，但原翻译者应该是他没错，这里只进行一下整理)</p>
<p><a href="http://adactio.com/articles/1704/" target="_blank" rel="external">Jeremy Keith在 Fronteers 2010 上的主题演讲</a></p>
<p>今天我想跟大家谈一谈HTML5的设计。主要分两个方面：一方面，当然了，就是HTML5。我可以站在这儿只讲HTML5，但我并不打算这样做，因为如果你想了解HTML5的话，你可以Google，可以看书，甚至可以看规范。</p>
<p>实际上，确实有人会谈到规范的内容。史蒂夫·福克纳（Steve Faulkner）会讲HTML5与可访问性。而保罗·艾里什（Paul Irish）则会讲HTML5提供的各种API。因此，我今天站在这里，不会光讲一讲HTML5就算完事了。</p>
<p>说老实话，在正式开始之前，我想先交待清楚我所说的HTML5到底是什么意思。这话听起来有点搞笑：这会子你一直在说HTML5，难道我们还不知道什么是HTML5吗？大家知道，有一个规范，它的名字叫HTML5。我所说的HTML5，指的就是这个规范。但问题是，有些人所说的HTML5，指的不仅仅是这个规范，还有别的意思。比如说，用HTML5来代指CSS3就是一种常见的叫法。我可不是这样的。我所说的HTML5，不包含CSS3，就是HTML5。</p>
<p>类似的术语问题以前也有过。Ajax本来是一种含义明确的技术，但过了不久，它的含义就变成了“用JavaScript来做一切好玩的东西”。这就是Ajax，对不对？今天，HTML5也面临同样的问题，它本来指的是一个特定的规范，但如今含义却成了“在Web上做一切好玩的事。”我说的不是这种HTML5，不是这种涵盖了最近刚刚出现的各种新东东的HTML5。我说的仅仅是规范本身：HTML5。</p>
<p>刚才已经说了，我今天想要讲的内容不多，也没有打算介绍HTML5都包含什么。今天我要讲的是它的另一方面，即HTML5的设计。换句话说，我要讲的不是规范里都包含什么，而是规范里为什么会包含它们，以及在设计这个规范的时候，设计者们是怎么看待这些东西的。<br>[待续]</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="html5_u8BBE_u8BA1_u539F_u7406"><a href="#html5_u8BBE_u8BA1_u539F_u7406" class="headerlink" title="html5设计原理"></a>html5设计原理</h1><h2 i]]>
    </summary>
    
      <category term="前端" scheme="http://starding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在计算机学习中，为什么我们应该问为什么]]></title>
    <link href="http://starding.github.io/2016/03/18/why-should-we-ask-why/"/>
    <id>http://starding.github.io/2016/03/18/why-should-we-ask-why/</id>
    <published>2016-03-18T12:46:05.000Z</published>
    <updated>2016-03-19T03:01:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5728_u8BA1_u7B97_u673A_u5B66_u4E60_u4E2D_uFF0C_u4E3A_u4EC0_u4E48_u6211_u4EEC_u5E94_u8BE5_u95EE_u4E3A_u4EC0_u4E48"><a href="#u5728_u8BA1_u7B97_u673A_u5B66_u4E60_u4E2D_uFF0C_u4E3A_u4EC0_u4E48_u6211_u4EEC_u5E94_u8BE5_u95EE_u4E3A_u4EC0_u4E48" class="headerlink" title="在计算机学习中，为什么我们应该问为什么"></a>在计算机学习中，为什么我们应该问为什么</h1><p>最近在使用bootstrap的时候，遇到一个下拉菜单（dropdown menu）的设计问题。bootstrap默认的下拉菜单组件是使用list作为html基础完成的，而不是<code>&lt;select&gt;&lt;/select&gt;</code>。我想这背后一定有设计者的意图，但是对于刚入门前端的我来说很难考究。不过问了一些人之后，发现似乎并没有关注这些实现背后的设计意图问题。</p>
<p>在之前的一篇博客——<a href="http://metaphor.space/2016/01/10/open-questions/" target="_blank" rel="external">open questions</a>中，提过一个问题，大意是说在计算机领域，为什么我们要去追问一件事情的动机。最近在学习前端的时候，对这个问题有了更深一步的体会，所以开始将这个问题单独提出来进行阐述。</p>
<h2 id="u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u300C_u56DB_u56E0_u8BF4_u300D"><a href="#u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u300C_u56DB_u56E0_u8BF4_u300D" class="headerlink" title="科学哲学中的「四因说」"></a>科学哲学中的「四因说」</h2><p>早在古希腊时代，就有哲学家开始思索事物的本质了。有一个很有名的哲学家提出了一些解释事物运动与变化的论点，其核心思想也就是标题中所描述的<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%9B%A0%E8%AA%AA" target="_blank" rel="external">「四因说」</a>。当然，如你所料，这位哲学家的名字叫「亚里士多德」。</p>
<p>为了省去时间解释「四因说」的概念，摘出吴国盛老师博客：<a href="http://blog.sina.com.cn/s/blog_51fdc06201009s7z.html" target="_blank" rel="external">海德格尔的技术哲思</a>中的几段话来稍作说明，当然你也可以参考英文版的维基百科词条，或者是更专业的科哲书籍：</p>
<blockquote>
<p>导致一个物出现的东西被称为该物的原因。亚里士多德曾经主张原因有四种，即「质料因」、「形式因」、「目的因」和「动力因」。比如造一顶皇冠，金子是它的质料因；皇冠的形状是它的形式因；皇帝用来举行大典、显示威仪和华贵是它的目的因；工匠汇总各方面的要求和准备并发挥自己的作用从而最终将皇冠拿出来，工匠是它的动力因。</p>
<p>今日我们对这四因说不是太理解，不知道为什么要提出四种原因，更不知道为什么单单提出这四种原因。因为当我们说到“原因”时，指的往往只是那直接产生作用并造成和带来最终结果的东西，也就只是亚里士多德意义上的动力因（也可以称之为「直推因」 ——引用注）。皇冠作为被造出来的结果，在我们今天看来，工匠是其唯一的原因。</p>
<p>　　动力因成为四因中起决定作用的方面，并最终决定了对因果性的规定。这件事情发生在16、17世纪之后(也就是机械自然观开始成型的那些年 ——引用注)，非同寻常，里面包含着近代思想对于目的因的排除。一个物的出现被描述为另一个早先的物加上某个作用力的结果，物在某种意义上成了现成的东西，即所谓“物质”。物不再“出现”（coming to），它根本就在场，恒久的在场。因果性说的也不再是那种使物“出现”的东西，而是根本上在场的物质的在数量方面的变化。</p>
<p>　　这种对因果性的规定使我们无法理解希腊人的四因说，特别是，使我们对希腊人四因说中的动力因的理解打上我们时代的烙印：对物产生作用，使其发生改变。但是那种希腊意义上四因之间的内在联系就完全丢失了。海德格尔提醒说，对工具之本质的理解依赖于对因果性之本质的理解，而对因果性的本质我们至今还茫然无知，这一茫然无知特别表现在我们对希腊四因说的误解</p>
</blockquote>
<p>上面的吴老师的文字，基本上已经很清楚的解释了什么是「四因说」以及为什么在今天我们提到一件事情的「原因」时，我们暗示的语境是「一个原因（cause）」而不是「四个原因（cause）」。这是因为16，17世纪发生的自然观的范式转变造成的，这些转变把四因说中的「动力因」（也可以说是直推因）当成事物变化的首要因素，以及「四因说」中的其他几个原因被淡化了。</p>
<h2 id="u52A8_u529B_u56E0_uFF08_u76F4_u63A8_u56E0_uFF09_u2014_u2014__u4F20_u7EDF_u81EA_u7136_u79D1_u5B66_u63A2_u7A76_u7684_u6709_u6548_u65B9_u5F0F"><a href="#u52A8_u529B_u56E0_uFF08_u76F4_u63A8_u56E0_uFF09_u2014_u2014__u4F20_u7EDF_u81EA_u7136_u79D1_u5B66_u63A2_u7A76_u7684_u6709_u6548_u65B9_u5F0F" class="headerlink" title="动力因（直推因）—— 传统自然科学探究的有效方式"></a>动力因（直推因）—— 传统自然科学探究的有效方式</h2><p>在传统科学中，我们说一件事情的原因的时候，往往指的就是它的直推因。比如曾经在知乎上回答的一个问题：<a href="https://www.zhihu.com/question/30546364" target="_blank" rel="external">为啥乙醇没毒，而甲丙丁醇都有毒？</a></p>
<p>然后可以观察下面的答案，得票最高的答案描述了醇类的分子结构以及相应的化学性质，不同醇类在人类体内所产生的不同影响，并且给出了相当专业的答案。从这种角度出来，所阐述的就是「醇类毒性的直推因」。也就说「当前是什么样」。</p>
<p>在科学革命之后，上述回答中体现出的思想一直是自然科学研究的指导思想。这种追问「直推因」的研究模式有非常巨大的优势：它可以引导人类先将那些最根本的追问放到一旁，集中精力研究在当前阶段下能研究的东西，对于不能研究的或者研究暂时够不着的地方保持沉默。比如研究物体的运动，最直接的是去研究推动物体的力，研究在不同力的作用下，产生的不同效果。同时将牛顿所讲的第一推动力放到一旁，暂时不予考虑。正是这样按照一种内在的逻辑精密的步步前行，不断积累，并且如我们所见，这种研究形式取得了重大的成果。</p>
<p>但是这并没有给「我们的期待」一个显得更更本质的解释：对，这个答案说的是非常准确，非常符合人类目前掌握的生理化学知识，但是仍然可以在这个基础上问一句，为什么是这样？是什么原因造成了生理化学上的这种现状？</p>
<h2 id="u76EE_u7684_u56E0__u2014_u2014__u6211_u4EEC_u7684_u671F_u5F85"><a href="#u76EE_u7684_u56E0__u2014_u2014__u6211_u4EEC_u7684_u671F_u5F85" class="headerlink" title="目的因 —— 我们的期待"></a>目的因 —— 我们的期待</h2><p>正如上面小结结尾所提出的问题，我们人类心理上总是想要一种「更为本质」的解释，而且有些偏执的认为这种「更为本质的解释应该存在」，虽然目前来看很多都只是「因果关系上的错觉」。这一点在达尔文的进化论中表现的更为明显，正如我在：<a href="https://www.zhihu.com/question/30546364" target="_blank" rel="external">为啥乙醇没毒，而甲丙丁醇都有毒？</a>问题下的回答。</p>
<blockquote>
<p>这题明显是一个生理学加进化论的问题，一旦牵扯到进化论，「因果关系」就会变得微妙起来。</p>
<p>我们说一件事物「有毒」的时候，是暗含着语境的——对生物来说。甲乙丙丁醇，结构相似，为什么乙醇毒性最小？从生理化学方面回答，只能回答出这种毒性表现「是什么」，从因果关系上讲，这样推理找到的是“有毒”的「直推因」。</p>
<p>「直推因」是指与所要研究的事情本身最直接的原因。探寻直推因也是物理和化学中最常见的研究形式。这个来历与十六七世纪发生的科学革命有很大关系，具体情况比较复杂，这里不细说。</p>
<p>但是在生物学上，只研究直推因，能很好的说明“表现为什么样，是什么样”，但并不能很好的说明“为什么是这样”。在回答「是什么样」的时候，生理化学做的很好了。至于「为什么这样」，只能求助于进化论。</p>
<p>大胆的猜测就是因为：乙醇在自然条件下更容易出现(至于为什么更容易出现，又是另一个问题了)，生命接触乙醇的机会比其他醇类多。这样就导致了生命对于乙醇的不敏感。</p>
<p>至于证据问题，只能说这个猜测和进化论的逻辑是相符合的。如果要拿出具体的数据很难。</p>
</blockquote>
<p>这个答案的正确性暂且不论，而且关于进化论中令人头疼的因果关系也姑且不去考虑，我想说的就是即便是上面这样的「半吊子目的因答案」也会给我们一种：『吖，就是这样！』的感觉，仿佛满足了我们灵魂最深处的某种渴望一样。</p>
<p>其实这就是「目的因」的魅力——它满足我们人类某种对真相的神秘渴求。即便有时候这种目的因是虚妄的。</p>
<h2 id="u8BA1_u7B97_u673A_u79D1_u5B66_u4E2D_u7684_u300C_u76EE_u7684_u56E0_u300D"><a href="#u8BA1_u7B97_u673A_u79D1_u5B66_u4E2D_u7684_u300C_u76EE_u7684_u56E0_u300D" class="headerlink" title="计算机科学中的「目的因」"></a>计算机科学中的「目的因」</h2><p>上面讲述了传统自然科学中的研究或者学习方式。但是对于计算机科学来说却不是这样。在自然界内，各种事物都是独立于人类存在的，多数事物更是早早先于人类就存在无数年头了，我们很难甚至可以说基本没有办法追溯回去，看看当初事物出现时的样子，以及在自然界这个复杂系统中所处的位置。</p>
<p>但在计算机领域内却大不一样，有非常多的内容是「人类创造的」，这些内容出于某些动机而构建出来，非常符合人类的直觉——这么干，背后肯定有一种「更为本质的原因」，而这种本质的原因，就是创造者的目的和意图。</p>
<p>这些现象基本上可以推广到所有与人造事物有关的事物上去。我们设计或者创造一种事物，都是有着某种根植于当时环境的目的在里面的。以一个普通桌子椅子为例，每一种设计，都有创造者背后想要表达的目的，它们都不是凭空出现的，而是伴生着创造者所种下的意向而来。有折叠的椅子，那设计师考虑的可能是节省空间，有纯榫卯的椅子，那可能是创造者为了自然环保，或者追溯往日的情怀。</p>
<p>在计算机领域，我们同样应该追问一件事情的「目的因」，也就是这件事物背后创造者的初衷。通过追问这些初衷可以更加了解一件事物内在的意向，以及深化对于这件事物的认识。比如设计模式，为什么要有这些设计模式，有没有其他的？当我们了解到这些之后，就会意识到这些东西不是铁板一块，进而解放我们的创造力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5728_u8BA1_u7B97_u673A_u5B66_u4E60_u4E2D_uFF0C_u4E3A_u4EC0_u4E48_u6211_u4EEC_u5E94_u8BE5_u95EE_u4E3A_u4EC0_u4E48"><a href="#u5728_u]]>
    </summary>
    
      <category term="computer philosophy" scheme="http://starding.github.io/categories/computer-philosophy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端记录]]></title>
    <link href="http://starding.github.io/2016/03/13/my-front-end-route/"/>
    <id>http://starding.github.io/2016/03/13/my-front-end-route/</id>
    <published>2016-03-13T14:25:05.000Z</published>
    <updated>2016-03-17T04:09:50.000Z</updated>
    <content type="html"><![CDATA[<p>主要记录一下前端学习的路线</p>
<h2 id="u96F6_u6563_u8BB0_u5F55"><a href="#u96F6_u6563_u8BB0_u5F55" class="headerlink" title="零散记录"></a>零散记录</h2><h3 id="u56FE_u7247_u7684_width__u548C_height__u5C5E_u6027"><a href="#u56FE_u7247_u7684_width__u548C_height__u5C5E_u6027" class="headerlink" title="图片的 width 和 height 属性"></a>图片的 <code>width</code> 和 <code>height</code> 属性</h3><ol>
<li>为图像指定 height 和 width 属性是一个好习惯。如果设置了这些属性，就可以在页面加载时为图像预留空间。如果没有这些属性，浏览器就无法了解图像的尺寸，也就无法为图像保留合适的空间，因此当图像加载时，页面的布局就会发生变化。</li>
<li>不要通过 height 和 width 属性来缩放图像。如果通过 height 和 width 属性来缩小图像，那么用户就必须下载大容量的图像（即使图像在页面上看上去很小）。正确的做法是，在网页上使用图像之前，应该通过软件把图像处理为合适的尺寸。</li>
<li>使用 height 和 width 属性的另外一种技巧，是可以非常容易地实现对页面区域的填充，同时还可以改善文档的性能。比如切图时常用的，切出1px宽度的纯色线，然后平铺填充。（还有一种用法是使用背景图重复）</li>
<li>height 和 width 实用百分数相对单位时，相对的是父元素宽度计算。 如果不指定，默认值就是图片本身的宽高，如果图片加载失败，会显示alt属性值，或者浏览器自带的加载失败效果。</li>
<li>虽然 <img> 标签的 height 和 width 属性能够改善性能并让你实现一些小技巧，但在使用它们时还是有一些棘手的负面效果。即使用户已经关掉了自动下载图像的功能，浏览器还是要把为图像预留的空间以指定的尺寸显示出来。而这样留给读者的通常是一个空的框架，里面有一个毫无意义的图标，表示这是放置图像的位置。这时页面将看上去非常糟糕，就像根本没有完成一样，并且大部分内容都毫无用处。如果不用这些指定的尺寸，则浏览器将只是在文本中放置一个图像图标，这样显示中至少还有一些文字可以阅读。对于这个问题我们还没有解决方案，只能强调一点，就是去使用 alt 属性和一些描述性文字，这样读者至少知道这里缺少的是什么东西。我们还是建议您使用这些尺寸属性，因为我们鼓励一切能够改善网络性能的行为</li>
</ol>
<h2 id="u4F7F_u7528_u8FC7_u7684_u5DE5_u5177"><a href="#u4F7F_u7528_u8FC7_u7684_u5DE5_u5177" class="headerlink" title="使用过的工具"></a>使用过的工具</h2><ul>
<li>reactjs react router</li>
<li>underscore</li>
<li>project-path （npm模块）</li>
<li>fixed-data-table （react组件）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要记录一下前端学习的路线</p>
<h2 id="u96F6_u6563_u8BB0_u5F55"><a href="#u96F6_u6563_u8BB0_u5F55" class="headerlink" title="零散记录"></a>零散记录</h2><h3 id]]>
    </summary>
    
      <category term="前端" scheme="http://starding.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://starding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[隐喻]]></title>
    <link href="http://starding.github.io/2016/02/26/metaphor/"/>
    <id>http://starding.github.io/2016/02/26/metaphor/</id>
    <published>2016-02-26T06:40:42.000Z</published>
    <updated>2016-02-29T07:07:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u9690_u55BB"><a href="#u9690_u55BB" class="headerlink" title="隐喻"></a>隐喻</h2><h3 id="u4E3A_u4EC0_u4E48_u660E_u786E_u6982_u5FF5_u5982_u6B64_u91CD_u8981"><a href="#u4E3A_u4EC0_u4E48_u660E_u786E_u6982_u5FF5_u5982_u6B64_u91CD_u8981" class="headerlink" title="为什么明确概念如此重要"></a>为什么明确概念如此重要</h3><p>在美剧中，我们常常能见到演员们提及或使用「隐喻」这种修辞手法，而且模糊的知道这种修辞和「类比」相似，但是缺少对这种修辞的清晰认知。实际上，我们平时日常交谈时，常常会无意识的使用到这种修辞，而造成这种无意识的原因是我们对「隐喻」没有一个明确的概念。</p>
<p>不止隐喻是这样，在日常生活中，常常会遇到这样的情景：在你明确一件事物的概念之前，即使这件事物在身边常常见到，你也不会过多的去留意它，这个时候对这件事物的认知，就处于一种「无意识」的状态，而你一旦掌握了这样事物的概念之后，就会脱离那种混沌的无意识状态，转而开始有意的留意身边的这些事物，就会吃惊的发现，啊，原来它早已存在。</p>
<p>用一个比较哲学的说法，这叫「有之非有，存在的无」。人类根据经验在语言上建立起一种事物的概念，然后这个语言学上的概念，反过来又会促进人类更加留意对应的事物，最终加深对概念和事物更深刻的认识。</p>
<p>在《写给大家看的设计书》中，作者开篇就写了约书亚树的例子。</p>
<blockquote>
<p>约书亚树</p>
<p>很多年前的一个圣诞节，我收到一份圣诞礼物，是一本关于如何认识各种树的书。那时我住在父母的家里，所有礼物都打开后，我决定出去走走，认一认邻居家的树。出去之前我读了书的一部分。其中提到的第一种树是约书亚树，只需要两个线索就能认出它。由于约书亚树相当怪异，所以看到书中它的照片时，我对自己说：“哦，北加利福尼亚绝对没有这种树。这种树太怪异了。如果我见过，肯定应该有印象，可我以前从来没有见过。”</p>
<p>之后我拿着这本书走出去。我的父母住在一个小巷子里，这里共有6家住户。其中4家的前院里都赫然立着约书亚树。我住在那里已经有13年了，而我此前从来没有注意过约书亚树。我在这个街区转了转，发现似乎每一家布置新居时苗圃里都有约书亚树卖，至少80%的住家前院都种有约书亚树。而我在此之前居然从来没有注意过！在我知道了这种树之后，我是说在我能够说出它的名字后，它就无处不在了。这正是我要说的：一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，使它在你的控制中。</p>
</blockquote>
<p>这个例子所讲述的内容并不是特殊的情况，它背后有着关于语言和认知的更深层次的问题。概念是思维的最基本单元，其重要性我们怎样重视都不会过分。现在有一些认知，语言上的方向专门来研究这些问题，而本文就简单介绍「隐喻」的概念，以及讲述在计算机科学中「隐喻」的重要性。</p>
<p>原本对隐喻的介绍是在其他文章中完成的，但是后来越来越感觉到这个概念的重要性，以至于不得不单独提出来特别讲述一下。就如前面所描述，一旦「隐喻」的概念明确之后，你就会开始摆脱原来的无意识使用状态，有意识地使用这种修辞来表达一些原来难以言状的概念，事物等。而且也会发现，「隐喻」这种修辞随处可见，并且深刻意识到它带来的好处。</p>
<h3 id="u300A_u4EE3_u7801_u5927_u5168_u300B_u5BF9_u9690_u55BB_u7684_u6001_u5EA6"><a href="#u300A_u4EE3_u7801_u5927_u5168_u300B_u5BF9_u9690_u55BB_u7684_u6001_u5EA6" class="headerlink" title="《代码大全》对隐喻的态度"></a>《代码大全》对隐喻的态度</h3><p>在《代码大全》中，作者在欢迎章节之后，就开始介绍软件开发中的隐喻，并且强调了隐喻的重要性：</p>
<blockquote>
<p>计算机科学领域中有着搜友学科中最为丰富多彩的语言。你走进一间安全严密，温度精确控制在20℃的房间，并在里面发现了病毒（virus），特洛伊木马（Trojan horse），蠕虫（worm），臭虫（bug），逻辑炸弹（bomb），崩溃（crash），论坛口水战（flame），双绞线转换头（twisted sex changer），还有致命错误（fatal error）……在其他领域中，你能遇到这些吗？</p>
<p>这些形象的隐喻描述了软件领域总各种特定的现象和事物，像这样生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻，我们能更深刻的理解软件开发的过程。</p>
</blockquote>
<h2 id="u90A3_u4E48_u4EC0_u4E48_u662F_u9690_u55BB_uFF1F"><a href="#u90A3_u4E48_u4EC0_u4E48_u662F_u9690_u55BB_uFF1F" class="headerlink" title="那么什么是隐喻？"></a>那么什么是隐喻？</h2><p>隐喻是比喻的一种，其字面意思是「隐含的比喻」。与普通的比喻，也就是「明喻」相对。</p>
<p>对比来讲，明喻这种修辞手法在日常用语中是使用最多的比喻形式，例如「貌美如花」，「父爱如山」等。使用「明喻」主要是因为某些审美上的倾向，希望将一种事物上的审美特点添加到另一种事物上，比如上面的词语中，想要将花朵的美好赋予到人类身上，或是将山的厚重，巍峨的特性赋予到父亲身上。</p>
<p>而「隐喻」则有所不同，它多数不是因为审美上的倾向才使用，而是想要表达出两种事物之间有某种实实在在的联系。比如莎士比亚的著名隐喻：</p>
<blockquote>
<p>All the world’s a stage,<br>And all the men and women merely players;<br>They have their exits and their entrances；and one man in his time plays many parts…</p>
<p>—William Shakespeare</p>
<p>世界是舞台，男人和女人都是演员。他们都有下场的时候，也都有上场的时候。一个人的一生中扮演着好几个角色。</p>
<p>——莎士比亚</p>
</blockquote>
<p>莎士比亚使用这个隐喻，并不是想将舞台和演员某些审美上的特点赋予世界和人类，而是实实在在的认为，世界的运行机制和舞台剧的运行机制，有某些相似点。</p>
<p>很多人（通常是认知语言学家）认为，「隐喻」这种修辞具有认知学上的意义。换句话说，它可以帮助人类更好的认识一件事物，所使用的手段就是将一种比较新的陌生的概念，与已知的比较容易理解的其他概念联系起来，利用两件事物之间的相似性辅助认知。</p>
<h2 id="u4E00_u4E9B_u4F8B_u5B50_u2014_u2014_u90A3_u4E9B_u6211_u4EEC_u66FE_u6CE8_u610F_u6216_u4E0D_u66FE_u6CE8_u610F_u7684_u9690_u55BB"><a href="#u4E00_u4E9B_u4F8B_u5B50_u2014_u2014_u90A3_u4E9B_u6211_u4EEC_u66FE_u6CE8_u610F_u6216_u4E0D_u66FE_u6CE8_u610F_u7684_u9690_u55BB" class="headerlink" title="一些例子——那些我们曾注意或不曾注意的隐喻"></a>一些例子——那些我们曾注意或不曾注意的隐喻</h2><p>在语言中，一种新事物的产生需要一个词汇来命名时，一种手段是在原来有的词汇的基础上进行引申，而这种引申并不是随性而为的，往往是新事物之间和之前的旧事物之间有某些特殊的相似性。</p>
<p>一些典型的例子：</p>
<ul>
<li>socket：原意是插头，插座。在计算机通信传输时，引申为一种信息交互的机制。特点就像是插座那样，有对接的意思。</li>
<li>docker：原意是码头工人。现在出现了一种常用的虚拟化技术，叫docker。它同样借助了码头工人，集装箱一类的隐喻，来表达标准化交付的意思。</li>
<li>待续</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9690_u55BB"><a href="#u9690_u55BB" class="headerlink" title="隐喻"></a>隐喻</h2><h3 id="u4E3A_u4EC0_u4E48_u660E_u786E_u6982_u5FF5_u5982]]>
    </summary>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[问题记录]]></title>
    <link href="http://starding.github.io/2016/02/25/questions-record/"/>
    <id>http://starding.github.io/2016/02/25/questions-record/</id>
    <published>2016-02-25T02:54:31.000Z</published>
    <updated>2016-03-03T06:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>Meta: 本文章用来记录平时遇到的问题以及相应的解决方案</p>
<h3 id="linux_crontab_+_django_command__u5B9A_u65F6_u6267_u884C_u547D_u4EE4"><a href="#linux_crontab_+_django_command__u5B9A_u65F6_u6267_u884C_u547D_u4EE4" class="headerlink" title="linux crontab +  django command 定时执行命令"></a>linux crontab +  django command 定时执行命令</h3><h4 id="u95EE_u9898_u573A_u666F"><a href="#u95EE_u9898_u573A_u666F" class="headerlink" title="问题场景"></a>问题场景</h4><p>在做一个档案管理系统时，有一个需要定时从DB2数据库中取出数据，处理之后，存入mysql中的任务。这意味着需要在django中单独跑一个脚本，这个脚本使用django的环境。</p>
<h4 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h4><p>django提供了一种用户自定义命令来实现这个功能：</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.9/howto/custom-management-commands/" target="_blank" rel="external">Writing custom django-admin commands¶</a></p>
</blockquote>
<p>而linux则提供了定时执行任务方面的好用工具：</p>
<blockquote>
<p><a href="http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">linux crontab</a></p>
</blockquote>
<h3 id="u5F80mysql_u4E2D_u5199_u5927_u91CF_u6570_u636E_u65F6_uFF0C_u51FA_u73B0_u9519_u8BEF_uFF1A2006__u2018mysql_server_has_gone_away_u2019"><a href="#u5F80mysql_u4E2D_u5199_u5927_u91CF_u6570_u636E_u65F6_uFF0C_u51FA_u73B0_u9519_u8BEF_uFF1A2006__u2018mysql_server_has_gone_away_u2019" class="headerlink" title="往mysql中写大量数据时，出现错误：2006 ‘mysql server has gone away’"></a>往mysql中写大量数据时，出现错误：2006 ‘mysql server has gone away’</h3><h4 id="u95EE_u9898_u573A_u666F-1"><a href="#u95EE_u9898_u573A_u666F-1" class="headerlink" title="问题场景"></a>问题场景</h4><p>在做一个档案管理系统时，使用django+mysql，当一次性往mysql中写入了近3w条数据时，就出现了这个错误</p>
<h4 id="u89E3_u51B3_u65B9_u6848-1"><a href="#u89E3_u51B3_u65B9_u6848-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>调查发现是因为mysql默认的有一个写入数据大小限制。只需要在<code>/etc/my.cnf</code>(如果没有这个文件就自己建立一个)下加上下面的代码即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]&#10;max_allowed_packet = 16M</span><br></pre></td></tr></table></figure>
<p>当然，也可以限制一下自己每次往mysql中写入数据的数量来解决这个问题。</p>
<h3 id="CSS__u4F2A_u7C7B_u548C_u4F2A_u5143_u7D20_u533A_u522B"><a href="#CSS__u4F2A_u7C7B_u548C_u4F2A_u5143_u7D20_u533A_u522B" class="headerlink" title="CSS 伪类和伪元素区别"></a>CSS 伪类和伪元素区别</h3><p><strong>伪类：Pseudo-elements</strong></p>
<p><strong>伪元素：Pseudo-classes</strong></p>
<h4 id="u6982_u5FF5_u8FA8_u6790"><a href="#u6982_u5FF5_u8FA8_u6790" class="headerlink" title="概念辨析"></a>概念辨析</h4><p><strong>stackoverflows上的回答</strong></p>
<p><a href="http://stackoverflow.com/questions/8069973/what-is-the-difference-between-a-pseudo-class-and-a-pseudo-element-in-css" target="_blank" rel="external">What is the difference between a pseudo-class and a pseudo-element in CSS?</a></p>
<p><strong>W3C上的说明</strong></p>
<p><a href="https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-elements" target="_blank" rel="external">pseudo-elements</a></p>
<p><a href="https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-classes" target="_blank" rel="external">pseudo-classes</a></p>
<h3 id="CSS_font-size__u76F8_u5BF9_u5927_u5C0F_u7EE7_u627F"><a href="#CSS_font-size__u76F8_u5BF9_u5927_u5C0F_u7EE7_u627F" class="headerlink" title="CSS font-size 相对大小继承"></a>CSS font-size 相对大小继承</h3><p>font-size使用em等相对大小时，会发生计算叠加。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--HTML--&gt;</span><span class="tag">&lt;<span class="title">body</span>&gt;</span>    <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is <span class="tag">&lt;<span class="title">strong</span>&gt;</span>very important!<span class="tag">&lt;/<span class="title">strong</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code class="css"># <span class="selector-tag">CSS</span>
<span class="selector-tag">p</span> {<span class="attribute">font-size</span>:.<span class="number">75em</span>;}
<span class="selector-tag">strong</span> {<span class="attribute">font-size</span>:.<span class="number">75em</span>;}
</code></pre>
<blockquote>
<p>摘自《css设计指南》</p>
<p>一般来说，em以浏览器默认值为基本单位，也就是<code>1em=16px</code>。如果你想使用 em,但又需要设定具体的像素大小,可以把 body 的 font-size 设定为 62.5%。这样,就等于把基准大小从 16 像素改为 10 像素(16×62.5%=10)。然后, em 与像素的对应关系就十分明确了,比如 1em 等于 10 像素,1.5em 等于 15 像素,2em 等于 20 像素,等等。</p>
<p>p 元素的文本为 12 像素(body 的 16 像素基准大小×.75=12px), strong 是 p 的子元素,它的文本相对大小会逐层复合,应该是 16px <em> 0.75</em> 0.75=9px。</p>
</blockquote>
<p><strong>注意与text-indent的区别</strong>: font-size 会叠加复合计算，text-indent则是后面的值覆盖前面的值</p>
<blockquote>
<p>text-indent 可以被子元素继承。如果你 在一个 div 上设定了 text-indent 属性,那么 div 中的所有段落都会继承该缩进值。然而,与 所有继承的 CSS 值一样,这个缩进值并不是祖先元素中设定的值,而是计算的值。下面举一个 例子说明。</p>
<p>假设有一个 400 像素宽的 div,包含的文本缩进 5%,则缩进的距离是 20 像素(400 的 5%)。 在这个 div 中有一个 200 像素宽的段落。作为子元素,它继承父元素的 text-indent 值,所以 它包含的文本也缩进。但继承的缩进值是多少呢?不是 5%,而是 20 像素。也就是说,子元素 继承的是根据父元素宽度计算得到的缩进值。结果,虽然段落只有父元素一半宽,但其中的文 本也会缩进 20 像素。这样可以确保无论段落多宽,它们的缩进距离都一样。当然,在子元素 上重新设定 text-indent 属性,可以覆盖继承的值.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Meta: 本文章用来记录平时遇到的问题以及相应的解决方案</p>
<h3 id="linux_crontab_+_django_command__u5B9A_u65F6_u6267_u884C_u547D_u4EE4"><a href="#linux_crontab_+_]]>
    </summary>
    
      <category term="问题" scheme="http://starding.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript犀牛书（第六版）学习笔记]]></title>
    <link href="http://starding.github.io/2016/01/19/learn-javascript-follow-definitive-guide/"/>
    <id>http://starding.github.io/2016/01/19/learn-javascript-follow-definitive-guide/</id>
    <published>2016-01-18T16:14:52.000Z</published>
    <updated>2016-02-24T06:11:03.000Z</updated>
    <content type="html"><![CDATA[<p>记录一些学习javascript中，比较重要或是比较容易混乱的地方。不断更新，直到看完。</p>
<p>2016-1-18 更新到try-except-finally语句</p>
<h2 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h2><h3 id="u53D8_u91CF_u53CA_u53D8_u91CF_u7C7B_u578B"><a href="#u53D8_u91CF_u53CA_u53D8_u91CF_u7C7B_u578B" class="headerlink" title="变量及变量类型"></a>变量及变量类型</h3><p>javascript中的变量本身没有类型，给一个变量赋值时，其实是这个变量引用了这个值。这根python中是一致的。</p>
<p>他们都区别于C语言等固定类型的变量，在C语言中，当声明一个变量时，需要指定它的类型，这个变量其实就是一个固定大小的空间，直接用于存放变量的值。数组也是一样，一个数组只能存储同样类型的值，C语言需要根据类型决定如何分配内存大小，比如int是4个字节。</p>
<p>而javascript和Python中，无需声明变量类型。变量只是对数据的引用，而类型是数据本身决定的，这个变量引用了什么类型，这个变量就是什么类型。</p>
<h3 id="u53D8_u91CF_u58F0_u660E"><a href="#u53D8_u91CF_u58F0_u660E" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>声明提前<ul>
<li>指的是var声明变量时，会提前到其所在作用域的顶部</li>
</ul>
</li>
<li>可配置性<ul>
<li>全局变量是全局对象的属性，但局部变量没有此规定</li>
<li>var声明的全局变量是不可配置的，无法通过delete运算符删除</li>
</ul>
</li>
</ul>
<h2 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h2><p>javascript中的数据类型分为两类:</p>
<h3 id="u539F_u59CB_u7C7B_u578B"><a href="#u539F_u59CB_u7C7B_u578B" class="headerlink" title="原始类型"></a>原始类型</h3><ul>
<li><p>原始类型 primitive type（5种）</p>
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔值</li>
<li>null</li>
<li>undefined</li>
</ul>
</li>
<li><p>原始类型不是对象，但你可能会见过 APrimitiveType.method的调用形式，这是因为数字，字符串，布尔值存在「包装对象」这个概念。也就是说，档使用上面的.运算时，javascript会自动调用 new String(s) | new Number(s) | new Boolean(s) 的方式将这三种基本类型临时转换为对象，并继承相应类型的方法。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个经典的例子</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"test"</span>;</span><br><span class="line">s.len = <span class="number">4</span>;  <span class="comment">//因为点运算，这里会临时建立一个string对象，但是随即又销毁了</span></span><br><span class="line"><span class="keyword">var</span> t = s.len; <span class="comment">//这里也会创建一个string对象，但是已经不是上面那个了，故undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>null和undefined没有包装对象</p>
</li>
<li><p>可以使用构造函数显式地构造包装对象。</p>
</li>
</ul>
<h3 id="u5BF9_u8C61_u7C7B_u578B"><a href="#u5BF9_u8C61_u7C7B_u578B" class="headerlink" title="对象类型"></a>对象类型</h3><ul>
<li>对象类型（object）（除了5种原始类型的数据类型，都是对象类型）<ul>
<li>普通对象（名值对对象）</li>
<li>数组</li>
<li>函数<ul>
<li>javascript可以将function对象当做普通对象对待</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u8868_u8FBE_u5F0F_u548C_u8FD0_u7B97_u7B26"><a href="#u8868_u8FBE_u5F0F_u548C_u8FD0_u7B97_u7B26" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>eval()实际上是个函数，但它早已被当成运算符看待。ECMAscript会尽量约束eval()的表现，使其看起来像个表达式。</p>
<p>这是因为如果将eval当做普通的函数对待，不做任何限制的话，会有很多缺点。一是因为eval()会动态的执行代码段，破坏原来的代码结构，解释器难以优化。二是因为如果eval是普通的函数，那么它就可以被赋值给其他的变量名，比如g = eval, 这样导致任何使用g的地方，也会产生上述问题，导致javascript的代码优化变得困难，性能堪忧。</p>
<p>综上所述，如果eval的表现行为像一个运算符的话，就不会有上述这么严重的问题，所以在ECMAscript语法中，不断的约束它，让他的表现更接近为运算符。</p>
<h2 id="u8BED_u53E5"><a href="#u8BED_u53E5" class="headerlink" title="语句"></a>语句</h2><h3 id="u6807_u7B7E_u8BED_u53E5"><a href="#u6807_u7B7E_u8BED_u53E5" class="headerlink" title="标签语句"></a>标签语句</h3><p>主要用于配合continue和break使用，来实现更灵活一些的跳转。</p>
<h3 id="throw/try/catch/finally"><a href="#throw/try/catch/finally" class="headerlink" title="throw/try/catch/finally"></a>throw/try/catch/finally</h3><p>之前写过一篇<a href="http://starding.github.io/2016/01/10/traps-in-python/">那些年我在python中扑过的街</a>，在其中提到过python中，try/except/finally中容易进的坑。</p>
<p>这个坑在javascript中也是同样的，就像那篇文章里说的那样，因为finally的设计目的就是无论如何都会执行，那么一旦finally中出现了跳转语句，其他语句中的返回内容就会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finallyTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'catch'</span>, y = <span class="string">'except'</span>, z = <span class="string">'finally'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k = x + y;</span><br><span class="line">        a = b;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"here is try------------"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"here is catch----------"</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"here is finally---------"</span>);</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">finallyTest()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line">here is <span class="keyword">catch</span>----------</span><br><span class="line">here is <span class="keyword">finally</span>---------</span><br><span class="line"><span class="string">'finally'</span></span><br></pre></td></tr></table></figure>
<h3 id="use_strict"><a href="#use_strict" class="headerlink" title="use strict"></a>use strict</h3><p>use strict其实是ECMAscript 5 中加入的指令，非常接近于语句，但又有所区分：不包含关键字，只是个字符串字面量。而且只能出现在特定的位置。</p>
<p>use strict的目的是使其后的代码使用js的「严格模式」执行，它是js的一个子集，修正了一些语言的重要缺陷，并提供健壮的cha功能和增强的安全机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一些学习javascript中，比较重要或是比较容易混乱的地方。不断更新，直到看完。</p>
<p>2016-1-18 更新到try-except-finally语句</p>
<h2 id="u53D8_u91CF"><a href="#u53D8_u91CF" cla]]>
    </summary>
    
      <category term="javascript" scheme="http://starding.github.io/tags/javascript/"/>
    
      <category term="前端" scheme="http://starding.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://starding.github.io/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker-gitlab数据迁移]]></title>
    <link href="http://starding.github.io/2016/01/18/gitlab-migrate/"/>
    <id>http://starding.github.io/2016/01/18/gitlab-migrate/</id>
    <published>2016-01-18T08:04:04.000Z</published>
    <updated>2016-03-04T03:38:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u95EE_u9898_u6765_u6E90_uFF1Adocker_u7684file_system_u795E_u5751"><a href="#u95EE_u9898_u6765_u6E90_uFF1Adocker_u7684file_system_u795E_u5751" class="headerlink" title="问题来源：docker的file system神坑"></a>问题来源：docker的file system神坑</h2><p>我们的gitlab是使用docker部署的，方便快捷。</p>
<p>但是后来服务器上的某个应用出现了内存泄露，没想到重启服务器之后整个docker就跪了，启动容器时总是遇到一系列比较底层的filesystem unkown错误，而且报错细节不止一种。调查之后，发现是docker使用的 devicemapper 出现了bug，而且查看docker官方的github，有不少人遇到这个bug，讨论话题在此：<a href="https://github.com/docker/docker/issues/4036" target="_blank" rel="external">docker fails to mount the block device for the container on devicemapper</a>，感觉掉到一个深不见底的神坑里了。</p>
<p>stackoverflow或github上给出的解决办法是：关掉docker，删除/var/lib/docker中的所有内容，然后重启gilab。我觉得可能是另一个神坑，没敢往里跳。于是选择慢慢研究这个问题，先在另外一台服务器上重新部署一下gitlab，并且把数据迁移过去就行了。</p>
<h2 id="gitlab_u6570_u636E_u8FC1_u79FB"><a href="#gitlab_u6570_u636E_u8FC1_u79FB" class="headerlink" title="gitlab数据迁移"></a>gitlab数据迁移</h2><p>原以为迁移会很简单，没想到也有不少坑等着跳。</p>
<p>先把原服务器上的gitlab的volumes备份了一下，直接把备份好的volumes文件拷贝到新服务器上，按照原来的方法挂载，启动。</p>
<h3 id="u9047_u5230_u7684_u95EE_u9898"><a href="#u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol>
<li>首先发现是redis啥啥没有权限，于是google了一番，把权限都改了。</li>
</ol>
<ol>
<li><p>然后出了一个<a href="https://gitlab.com/gitlab-org/gitlab-ce/commit/ff98c631c1004247656677568989e5ed68fc88f3" target="_blank" rel="external">unfoudmethod错误</a>。调查是数据库没有migrate的造成的。</p>
</li>
<li><p>还有一个隐藏的坑是gitlab的版本问题。类似的关键服务应用，尽量不要使用latest作为版本号，不然出了问题，还得去找自己使用的究竟是什么版本，如果找不到…准备拼人品吧。</p>
</li>
</ol>
<h3 id="u6700_u7EC8_u7684_u89E3_u51B3_u529E_u6CD5"><a href="#u6700_u7EC8_u7684_u89E3_u51B3_u529E_u6CD5" class="headerlink" title="最终的解决办法"></a>最终的解决办法</h3><p>感觉这么一个一个坑的跳太二了，后来发现原来已经有人把坑都填好了：<a href="https://cmanios.wordpress.com/2015/12/04/migrate-a-gitlab-docker-container-from-version-8-0-4-to-8-2-0/" target="_blank" rel="external">Migrate a Gitlab Docker container from version 8.0.4 to 8.2.0
</a></p>
<h2 id="u9644_u5F55_uFF1A_u4E0B_u9762_u662F_u539F_u6587_uFF08_u5DF2_u7FFB_u8BD1_uFF09"><a href="#u9644_u5F55_uFF1A_u4E0B_u9762_u662F_u539F_u6587_uFF08_u5DF2_u7FFB_u8BD1_uFF09" class="headerlink" title="附录：下面是原文（已翻译）"></a>附录：下面是原文（已翻译）</h2><p>前几天，我需要将docker部署的gitlab实例从 8.04 版迁移到 8.2.0版本。我完全是按照Gitlab Docker 镜像文档中的步骤进行的，但是出了一堆问题，简直日了狗。不过谢天谢地，在经过数小时的搜索挣扎之后，我终于搞定了。</p>
<p>在本教程中，假定 Gitlab的volumes存储在 <code>/home/bob/docker-data/gitlab</code> 目录中(当然，你需要根据你的实际目录结构来适当改写本教程)。然后下面是我成功迁移gitlab时遵循的所有步骤:</p>
<h2 id="1-_u505C_u6B62Gitlab_u5BB9_u5668"><a href="#1-_u505C_u6B62Gitlab_u5BB9_u5668" class="headerlink" title="1.停止Gitlab容器"></a>1.停止Gitlab容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop gitlab</span><br></pre></td></tr></table></figure>
<h2 id="2-_u5907_u4EFD_u6240_u6709Docker_Volumes__28_u6240_u6709_u7684gitlab_u6587_u4EF6_29"><a href="#2-_u5907_u4EFD_u6240_u6709Docker_Volumes__28_u6240_u6709_u7684gitlab_u6587_u4EF6_29" class="headerlink" title="2.备份所有Docker Volumes (所有的gitlab文件)"></a>2.备份所有Docker Volumes (所有的gitlab文件)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backupDate=$(date +<span class="string">"%Y%m%d%H%M%S"</span>) \</span><br><span class="line">  &amp;&amp; <span class="built_in">cd</span> /home/bob/docker-data/ \</span><br><span class="line">  &amp;&amp; sudo tar zvcf gitlab-data-<span class="variable">$&#123;backupDate&#125;</span>.tar.gz gitlab/</span><br></pre></td></tr></table></figure>
<h2 id="3-_u5907_u4EFDgitlab_u955C_u50CF_uFF08_u53EF_u9009_uFF09"><a href="#3-_u5907_u4EFDgitlab_u955C_u50CF_uFF08_u53EF_u9009_uFF09" class="headerlink" title="3.备份gitlab镜像（可选）"></a>3.备份gitlab镜像（可选）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o /home/bob/gitlab-ce-image.tar gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="4-_u5220_u9664gitlab_u5BB9_u5668_28__u8BD1_u6CE8__uFF1A_u5982_u679C_u4F60_u662F_u628A_u6570_u636E_u8FC1_u5230_u5176_u4ED6_u670D_u52A1_u5668_u7684docker_gitlab_u5B9E_u4F8B_u4E0B_u7684_u8BDD_uFF0C_u672C_u6B65_u9AA4_u53EF_u9009_29"><a href="#4-_u5220_u9664gitlab_u5BB9_u5668_28__u8BD1_u6CE8__uFF1A_u5982_u679C_u4F60_u662F_u628A_u6570_u636E_u8FC1_u5230_u5176_u4ED6_u670D_u52A1_u5668_u7684docker_gitlab_u5B9E_u4F8B_u4E0B_u7684_u8BDD_uFF0C_u672C_u6B65_u9AA4_u53EF_u9009_29" class="headerlink" title="4.删除gitlab容器( 译注 ：如果你是把数据迁到其他服务器的docker gitlab实例下的话，本步骤可选)"></a>4.删除gitlab容器( <strong>译注</strong> ：如果你是把数据迁到其他服务器的docker gitlab实例下的话，本步骤可选)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm gitlab</span><br></pre></td></tr></table></figure>
<h2 id="5-_u62C9_u53D6_u6700_u65B0_u7684gitlab_u955C_u50CF"><a href="#5-_u62C9_u53D6_u6700_u65B0_u7684gitlab_u955C_u50CF" class="headerlink" title="5.拉取最新的gitlab镜像"></a>5.拉取最新的gitlab镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="6-_u62C9_u53D6_u5B8C_u6BD5_u540E_uFF0C_u521B_u5EFA_u5E76_u8FD0_u884C_u5BB9_u5668"><a href="#6-_u62C9_u53D6_u5B8C_u6BD5_u540E_uFF0C_u521B_u5EFA_u5E76_u8FD0_u884C_u5BB9_u5668" class="headerlink" title="6.拉取完毕后，创建并运行容器"></a>6.拉取完毕后，创建并运行容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_ins">run</span> -d \</span><br><span class="line">  --hostname 192.168.1.1 \</span><br><span class="line">  --publish 8443:443 --publish 8082:80 --publish 2224:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --<span class="built_ins">volume</span> /etc/localtime:/etc/localtime \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/config:/etc/gitlab \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="7-_u5BB9_u5668_u542F_u52A8_u540E_uFF0C_u89C2_u5BDF_u8FD0_u884C_u65E5_u5FD7_3A"><a href="#7-_u5BB9_u5668_u542F_u52A8_u540E_uFF0C_u89C2_u5BDF_u8FD0_u884C_u65E5_u5FD7_3A" class="headerlink" title="7.容器启动后，观察运行日志:"></a>7.容器启动后，观察运行日志:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f --tail 10 gitlab</span><br></pre></td></tr></table></figure>
<p><strong>日志内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2015-11-26T15:12:26+02:00] INFO: Retrying execution of execute[create gitlab database user], 19 attempt(s) left&#10;[2015-11-26T15:12:28+02:00] INFO: Retrying execution of execute[create gitlab database user], 18 attempt(s) left&#10;... (some lines omitted) ...&#10;[2015-11-26T15:13:09+02:00] INFO: Retrying execution of execute[create gitlab database user], 0 attempt(s) left&#10; &#10; &#10;Error executing action `run` on resource &#39;execute[create gitlab database user]&#39;&#10; &#10; &#10;Mixlib::ShellOut::ShellCommandFailed&#10; &#10;Expected process to exit with [0], but received &#39;2&#39;&#10;---- Begin output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; ----&#10;STDOUT: &#10;STDERR: psql: could not connect to server: No such file or directory&#10;Is the server running locally and accepting&#10;connections on Unix domain socket &#34;/var/opt/gitlab/postgresql/.s.PGSQL.5432&#34;?&#10;---- End output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; ----&#10;Ran /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; returned 2&#10; &#10;Resource Declaration:&#10; &#10;# In /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb&#10; &#10;153:   execute &#34;create #&#123;sql_user&#125; database user&#34; do&#10;154:     command &#34;#&#123;bin_dir&#125;/psql --port #&#123;pg_port&#125; -h #&#123;postgresql_socket_dir&#125; -d template1 -c \&#34;CREATE USER #&#123;sql_user&#125;\&#34;&#34;&#10;155:     user postgresql_user&#10;156:     # Added retries to give the service time to start on slower systems&#10;157:     retries 20&#10;158:     not_if &#123; !pg_helper.is_running? || pg_helper.user_exists?(sql_user) &#125;&#10;159:   end&#10;160: &#10; &#10;Compiled Resource:&#10; &#10;# Declared in /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb:153:in `block in from_file&#39;&#10; &#10;execute(&#34;create gitlab database user&#34;) do&#10;action [:run]&#10;retries 20&#10;retry_delay 2&#10;default_guard_interpreter :execute&#10;command &#34;/opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c \&#34;CREATE USER gitlab\&#34;&#34;&#10;backup 5&#10;returns 0&#10;user &#34;gitlab-psql&#34;&#10;declared_type :execute&#10;cookbook_name &#34;gitlab&#34;&#10;recipe_name &#34;postgresql&#34;&#10;not_if &#123; #code block &#125;&#10;end</span><br></pre></td></tr></table></figure>
<p>有两个已知的权限问题，在 <a href="http://doc.gitlab.com/omnibus/docker/" target="_blank" rel="external">official documentation</a> 和 <a href="https://github.com/gitlabhq/gitlabhq/issues/9611" target="_blank" rel="external">#9611</a> 中描述. 为了解决这两个问题, 执行:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab update-permissions</span><br><span class="line">docker exec gitlab chown -R gitlab-redis /var/opt/gitlab/redis</span><br></pre></td></tr></table></figure>
<p>然后重启gitlab容器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
<h2 id="8-_u7136_u540E_u6211_u4EEC_u9700_u8981_u68C0_u67E5_u6570_u636E_u5E93_u8FC1_u79FB_u662F_u5426_u6210_u529F_u4EE5_u53CA_u907F_u514D_233255_u95EE_u9898_u3002"><a href="#8-_u7136_u540E_u6211_u4EEC_u9700_u8981_u68C0_u67E5_u6570_u636E_u5E93_u8FC1_u79FB_u662F_u5426_u6210_u529F_u4EE5_u53CA_u907F_u514D_233255_u95EE_u9898_u3002" class="headerlink" title="8.然后我们需要检查数据库迁移是否成功以及避免#3255问题。"></a>8.然后我们需要检查数据库迁移是否成功以及避免#3255问题。</h2><p>登录到gitlab容器中的shell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -t -i gitlab /bin/bash</span><br></pre></td></tr></table></figure>
<p>检查数据库迁移状况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure>
<p>如果所有状态都显示为up状态，是没问题的。如果发现down状态，类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up     20150920161119  Add line code to sent notification&#10;down    20150924125150  Add project id to ci commit&#10;down    20150924125436  Migrate project id for ci commits</span><br></pre></td></tr></table></figure>
<p>就必须重新手动执行数据库migration命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate</span><br></pre></td></tr></table></figure>
<p>当执行结束时，重新检查数据库migrate状态，确保所有状态都为up：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure>
<h2 id="9-_u7EE7_u7EED_u5728_u5BB9_u5668_u5185_u90E8_u7684bash_shell_u4E0A_uFF0C_u91CD_u65B0_u914D_u7F6Egitlab_3A"><a href="#9-_u7EE7_u7EED_u5728_u5BB9_u5668_u5185_u90E8_u7684bash_shell_u4E0A_uFF0C_u91CD_u65B0_u914D_u7F6Egitlab_3A" class="headerlink" title="9.继续在容器内部的bash shell上，重新配置gitlab:"></a>9.继续在容器内部的bash shell上，重新配置gitlab:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>然后检查是不是所有内容都正常运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:check</span><br></pre></td></tr></table></figure>
<h2 id="10-_u5982_u679C_u4E00_u5207_u6B63_u5E38_2C__u6267_u884C_u4E0B_u9762_u7684_u547D_u4EE4_3A"><a href="#10-_u5982_u679C_u4E00_u5207_u6B63_u5E38_2C__u6267_u884C_u4E0B_u9762_u7684_u547D_u4EE4_3A" class="headerlink" title="10.如果一切正常, 执行下面的命令:"></a>10.如果一切正常, 执行下面的命令:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:env:info RAILS_ENV=production</span><br></pre></td></tr></table></figure>
<p>会返回类似下面这样的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System information&#10;System:   Ubuntu 14.04&#10;Current User: git&#10;Using RVM:  no&#10;Ruby Version: 2.1.7p400&#10;Gem Version:  2.2.5&#10;Bundler Version:1.10.6&#10;Rake Version: 10.4.2&#10;Sidekiq Version:3.3.0&#10; &#10;GitLab information&#10;Version:  8.2.0&#10;Revision: d6bcf44&#10;Directory:  /opt/gitlab/embedded/service/gitlab-rails&#10;DB Adapter: postgresql&#10;URL:    http://192.168.1.1:8082&#10;HTTP Clone URL: http://192.168.1.1:8082/some-group/some-project.git&#10;SSH Clone URL:  git@192.168.1.1:some-group/some-project.git&#10;Using LDAP: yes&#10;Using Omniauth: no&#10; &#10;GitLab Shell&#10;Version:  2.6.7&#10;Repositories: /var/opt/gitlab/git-data/repositories&#10;Hooks:    /opt/gitlab/embedded/service/gitlab-shell/hooks/&#10;Git:    /opt/gitlab/embedded/bin/git</span><br></pre></td></tr></table></figure>
<h2 id="11-_u6700_u540E_uFF0C_u6E05_u9664Redis_u7684_u7F13_u5B58"><a href="#11-_u6700_u540E_uFF0C_u6E05_u9664Redis_u7684_u7F13_u5B58" class="headerlink" title="11.最后，清除Redis的缓存"></a>11.最后，清除Redis的缓存</h2><p>不然可能会遇到这个问题： <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/3619" target="_blank" rel="external">#3619</a> 或这个问题  <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/3609" target="_blank" rel="external">#3609</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake cache:clear</span><br></pre></td></tr></table></figure>
<h2 id="12-_u8BBF_u95EE_u6D4B_u8BD5"><a href="#12-_u8BBF_u95EE_u6D4B_u8BD5" class="headerlink" title="12.访问测试"></a>12.访问测试</h2><p>完成上述步骤之后，访问 <a href="http://localhost:8082" target="_blank" rel="external">http://localhost:8082</a> 应该能正常登陆</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u95EE_u9898_u6765_u6E90_uFF1Adocker_u7684file_system_u795E_u5751"><a href="#u95EE_u9898_u6765_u6E90_uFF1Adocker_u7684file_system_u79]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="gitlab" scheme="http://starding.github.io/tags/gitlab/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机领域中的概念辨析]]></title>
    <link href="http://starding.github.io/2016/01/15/learn-in-computer-sciense/"/>
    <id>http://starding.github.io/2016/01/15/learn-in-computer-sciense/</id>
    <published>2016-01-15T15:32:53.000Z</published>
    <updated>2016-01-15T17:19:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6982_u5FF5_u8FA8_u6790_3F"><a href="#u6982_u5FF5_u8FA8_u6790_3F" class="headerlink" title="概念辨析?"></a>概念辨析?</h2><p>概念, 摘自维基百科，为了保持概念的完整性，这里摘录了比较长的内容：</p>
<blockquote>
<p>概念也称观念，是抽象的、普遍的想法、观念或充当指明实体、事件或关系的范畴或类的实体。在它们的外延中忽略事物的差异，如同它们是同一的去处理它们，所以概念是抽象的。它们等同的适用于在它们外延中的所有事物，所以它们是普遍的。概念也是命题的基本元素，如同词是句子的基本语义元素一样。</p>
<p>概念是意义的载体，而不是意义的主动者。一个单一的概念可以用任何数目的语言来表达；术语则是概念的表达形式。狗的概念可以表达为德语的 Hund，法语的 chien 和西班牙语的 perro。概念在一定意义上独立于语言的事实使得翻译成为可能 - 在各种语言中词有同一的意义，因为它们表达了相同的概念。</p>
<p>概念是人类对一个复杂的过程或事物的理解。从哲学的观念来说概念是思维的基本单位。在日常用语中人们往往将概念与一个词或一个名词（术语）同等对待。传统上认为中国文化不强调定义概念，因此没有发展出逻辑和相关的哲学、科学。</p>
</blockquote>
<p>所谓概念辨析，就是去追溯词语的意思，来历，以及其可能的语境。这在哲学中是非常常见的，甚至在讨论每一个问题之前，都首先要把问题中的每一个概念辨析清楚，彻底搞清楚问题中的每一个词汇是什么意义，然后讨论才能继续往下进行。</p>
<h2 id="u4FEE_u8F9E_u5B66_u4EE5_u53CA_u7FFB_u8BD1_u4E2D_u7684_u5931_u771F"><a href="#u4FEE_u8F9E_u5B66_u4EE5_u53CA_u7FFB_u8BD1_u4E2D_u7684_u5931_u771F" class="headerlink" title="修辞学以及翻译中的失真"></a>修辞学以及翻译中的失真</h2><p>需要概念辨析的原因是多种多样的，可能是一个概念因为时间的关系，经历了意义的变化；也有可能是因为一个词是完全的外来词汇，在翻译中流失了原来的意义。而在计算机科学本身就是引入的科学，其专业术语基本都是翻译过来的。所以这里词汇辨析也就更倾向于消除翻译中的失真问题。</p>
<p>在计算机科学中，至少我目前所接触到的诸多书籍，甚至是在之前所受的专业的计算机教育中，都没有词语辨析这一块。而且由于汉语本身重修辞，轻辨析的特点，在原来英文词汇中存在的比较直白的意象，到了汉语翻译时，就可能为了优美，意向等加入一些隐含的修辞手法，开始变得玄妙起来。这个时候去追寻原来的词汇就非常重要了。</p>
<p>相应的翻译有：</p>
<ul>
<li>handle 翻译为「句柄」</li>
<li>socket 翻译为「套接字」</li>
<li>meta-programming  翻译为 「元编程」</li>
</ul>
<p>等等，这些翻译在英文中的含义都比较直白，但是到了汉语中，为了兼顾概念的简洁，雅致，借用了很多本土化的意象，但是这些意象本身就是比较朦胧的意思。导致原来明确地意思，变得朦胧，难以理解。这些翻译都是历史和当时技术背景下的产物。其实如果放到今天，可能根本不会像原来那样去翻译，甚至关键的词直接就保留了。</p>
<p>遇到这些词汇的时候我们就需要考察它翻译的时期，以及翻译成中文之前的源词汇是什么。找到这些源词汇后，在源词汇中的上下文中去理解。但是即便是在源词汇中，也是很有辨析的必要的。因为源词汇也不是凭空而来的，计算机是一门非常新的科学，其词汇也有很多是新构造的词。这些词有的是直接造出来的，有的则也是用了一定的修辞，在原来的意义上引申到进计算机领域中来。</p>
<p>一个词汇的引申并不是毫无理由的，其背后的动机往往是某些概念具有内在的联系，而这也常常构成一种修辞手法：「隐喻」</p>
<h2 id="u6982_u5FF5_u80CC_u540E_u7684_u9690_u55BB"><a href="#u6982_u5FF5_u80CC_u540E_u7684_u9690_u55BB" class="headerlink" title="概念背后的隐喻"></a>概念背后的隐喻</h2><p>概念辨析另一层好处就是，它能让我们看到概念背后的隐喻。进而我们更好，也更深刻地理解一个概念的核心思想。</p>
<p>举例来说，个人比较喜欢的几个隐喻是：</p>
<ul>
<li>docker 码头工人的隐喻</li>
<li>handle 把手的隐喻</li>
<li>callback  回电的隐喻</li>
<li>hook        钩子的隐喻</li>
</ul>
<p>隐喻的共同点就是，其本身直白的原意以一种比较隐含的方式与其在计算机科学中的概念关联，它们之间有一种很相似的结构，含义等。想要快速理解一个词汇的含义，将其隐喻与现有语境结合起来是非常重要的。</p>
<h2 id="u6982_u5FF5_u8FA8_u6790_u80CC_u540E_u7684_u54F2_u5B66_u601D_u60F3"><a href="#u6982_u5FF5_u8FA8_u6790_u80CC_u540E_u7684_u54F2_u5B66_u601D_u60F3" class="headerlink" title="概念辨析背后的哲学思想"></a>概念辨析背后的哲学思想</h2><p>「直推因」和「目的因」的辨析</p>
<p>待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6982_u5FF5_u8FA8_u6790_3F"><a href="#u6982_u5FF5_u8FA8_u6790_3F" class="headerlink" title="概念辨析?"></a>概念辨析?</h2><p>概念, 摘自维基百科，为了保持概]]>
    </summary>
    
      <category term="computer" scheme="http://starding.github.io/tags/computer/"/>
    
      <category term="computer philosophy" scheme="http://starding.github.io/categories/computer-philosophy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中的装饰器和迭代器]]></title>
    <link href="http://starding.github.io/2016/01/15/python-iterator-generator/"/>
    <id>http://starding.github.io/2016/01/15/python-iterator-generator/</id>
    <published>2016-01-15T14:59:16.000Z</published>
    <updated>2016-01-20T05:46:52.000Z</updated>
    <content type="html"><![CDATA[<p>简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不是很靠谱，很明显甚至连官方文档都没有看，就只根据经验就直接写文章来总结了，很容易误导人。</p>
<h2 id="Iterator_Types"><a href="#Iterator_Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h2><p>迭代器类型</p>
<h3 id="u5148_u770Bpython2-7_u5B98_u65B9_u6587_u6863_u4E2D_u5173_u4E8E_u8FED_u4EE3_u7684_u90E8_u5206_uFF1A"><a href="#u5148_u770Bpython2-7_u5B98_u65B9_u6587_u6863_u4E2D_u5173_u4E8E_u8FED_u4EE3_u7684_u90E8_u5206_uFF1A" class="headerlink" title="先看python2.7官方文档中关于迭代的部分："></a>先看python2.7官方文档中关于迭代的部分：</h3><p>在阅读之前，需要明确几个词的含义：</p>
<ul>
<li>「iterator」 迭代器</li>
<li>「iteration」 迭代</li>
<li>「iterable」 可迭代的</li>
<li>「container」 容器对象，也就是可以存放其他对象的对象，比如列表，字典等</li>
</ul>
<blockquote>
<p>New in version 2.2.</p>
<p>Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods.</p>
<p>python提供一种基于容器对象（container）的迭代概念。并且使用了两个特的方法来实现这一概念；这些方法允许自定义的类支持迭代。符合下面详细描述的序列（sequences），都将支持迭代方法。</p>
<p>One method needs to be defined for container objects to provide iteration support:</p>
<p>第一个在容器对象中定义的方法用于支持迭代（iteration）</p>
<p><strong><code>container.__iter__()</code></strong></p>
<p>Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example of an object supporting multiple forms of iteration would be a tree structure which supports both breadth-first and depth-first traversal.) This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.</p>
<p>返回一个迭代器对象（iterator object）。这个对象需要支持下面描述的迭代器协议（iterator protocal）。如果一个容器对象需要支持不同类型的迭代方式，也可以往容器对象中添加更多的方法来支持那些迭代方式。（一个对象支持多种跌打方式的例子是同时支持深度优先遍历和广度优先遍历的树结构）</p>
<p>The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:</p>
<p>迭代器本身也需要支持下面的两个方法，『这两个方法一起构成了迭代器协议』</p>
<p><strong><code>iterator.__iter__()</code></strong></p>
<p>Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.</p>
<p>返回迭代器对象自身。如果在for语句以及in语句中，使用容器对象和迭代器对象的话，那么它们都需要拥有此方法。</p>
<p><strong><code>iterator.next()</code></strong></p>
<p>Return the next item from the container. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python/C API.</p>
<p>返回容器中的下一个元素。如果没有下一个元素，则产生一个StopIteration异常。</p>
<p>Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms. The specific types are not important beyond their implementation of the iterator protocol.</p>
<p>python基于一些或通用或特定的序列类型，字典或其他更特殊的类型，定义了一系列的迭代器对象来支持迭代。这些对象的核心内容就是其中的迭代器协议。</p>
<p>The intention of the protocol is that once an iterator’s next() method raises StopIteration, it will continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. (This constraint was added in Python 2.3; in Python 2.2, various iterators are broken according to this rule.)</p>
<p>这个协议的目的是，一旦一个迭代器的next()方法产生了一个StopIteration异常，后续再度调用时，就会一直保持产生一个StopIteration的状态。如果不按照这个特性实现，就被认为是有问题的（这个约束是在python2.3中添加的；在python2.2中，有很多迭代器不遵守这个规则）</p>
</blockquote>
<h3 id="u6982_u5FF5_u8FA8_u6790"><a href="#u6982_u5FF5_u8FA8_u6790" class="headerlink" title="概念辨析"></a>概念辨析</h3><p>上面大致就是python2.7中关于迭代的核心内容，整理一下就是：</p>
<ul>
<li><p>对于容器对象（container）来说，要支持迭代的话，需要在容器内部实现一个<code>__iter__()</code>方法。这个方法返回一个「迭代器对象」（iterator）。如果一个容器实现了这个方法，那么我们称这个容器是「可迭代的」（iterable）。</p>
</li>
<li><p>对于迭代器来说，它也需要一个<code>__iter__()</code>方法，用于返回这个迭代器自身。同时需要一个<code>next()</code>方法，来返回下一个元素。迭代器本身当然是「可迭代的」。迭代器的这两个方法，合在一起，叫做「迭代器协议」。</p>
</li>
</ul>
<p>在for，in语句中，无论是使用容器对象（如列表），还是迭代器对象，它们内部都需要支持<code>__iter__()</code>方法。对于容器对象来说这个方法会返回一个迭代器，对于迭代器对象来说，这个方法会返回自身。然后用于迭代, 换句话说，即使是容器对象，也是先转换为迭代器对象再进行迭代的。这在python的文档中也有说明：</p>
<h4 id="The_for_statement"><a href="#The_for_statement" class="headerlink" title="The for statement"></a>The for statement</h4><blockquote>
<p>The for statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_stmt ::=  <span class="string">"for"</span> target_list <span class="string">"in"</span> expression_list <span class="string">":"</span> suite </span><br><span class="line">              [<span class="string">"else"</span> <span class="string">":"</span> suite]</span><br></pre></td></tr></table></figure>
<p>The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the expression_list. The suite is then executed once for each item provided by the iterator, in the order of ascending indices. Each item in turn is assigned to the target list using the standard rules for assignments, and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.</p>
</blockquote>
<h2 id="Generator_Types"><a href="#Generator_Types" class="headerlink" title="Generator Types"></a>Generator Types</h2><p>生成器类型</p>
<h3 id="u5B98_u65B9_u6587_u6863_u7684_u5B9A_u4E49_uFF1A"><a href="#u5B98_u65B9_u6587_u6863_u7684_u5B9A_u4E49_uFF1A" class="headerlink" title="官方文档的定义："></a>官方文档的定义：</h3><blockquote>
<p>Python’s generators provide a convenient way to implement the iterator protocol. If a container object’s <code>__iter__()</code> method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the <code>__iter__()</code> and <code>next()</code> methods. More information about generators can be found in the documentation for the yield expression.</p>
<p>python 的生成器提供了应用迭代器协议的便捷方式。如果一个容器对象的<code>__iter__()</code>方法被用于生成器，它会自动地返回一个迭代器对象（技术上讲，是一个生成器对象），并且提供<code>__iter__()</code> 和<code>next()</code>方法。</p>
</blockquote>
<h3 id="u6982_u5FF5_u8FA8_u6790-1"><a href="#u6982_u5FF5_u8FA8_u6790-1" class="headerlink" title="概念辨析"></a>概念辨析</h3><p>上述内容的意思是，生成器对象不过是一种应用迭代器协议的快捷方式。平时我们需要一个自定义的迭代器<br>时，需要手动的去实现需要的<code>__iter__()</code>和<code>next()</code>方法，但是使用生成器对象的话，可以自动返回一个支持迭代协议的迭代器。而创建一个生成器，只需要在函数中使用yield表达式就可以了，这样会创建一个生成器函数，当它被调用时，会返回一个迭代器（通常被叫做生成器），它会控制生成器函数的执行。</p>
<blockquote>
<p>The yield expression is only used when defining a generator function, and can only be used in the body of a function definition. Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.</p>
<p>When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generator’s methods is called. At that time, the execution proceeds to the first yield expression, where it is suspended again, returning the value of expression_list to generator’s caller. By suspended we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack. When the execution is resumed by calling one of the generator’s methods, the function can proceed exactly as if the yield expression was just another external call. The value of the yield expression after resuming depends on the method which resumed the execution.</p>
<p>All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator’s caller</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不是很靠谱，很明显甚至连官方文档都没有看，就只根据经验就直接写文章来总结了，很容易误导人。</p>
<h2 id="Iterator_Types"><a href="#Iterator_Types" ]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim学习]]></title>
    <link href="http://starding.github.io/2016/01/14/learn-vim/"/>
    <id>http://starding.github.io/2016/01/14/learn-vim/</id>
    <published>2016-01-14T15:21:24.000Z</published>
    <updated>2016-03-13T09:48:22.000Z</updated>
    <content type="html"><![CDATA[<p>记录用到的一些vim使用方法，积累够一定数量再整理</p>
<h2 id="vim_u5206_u5C4F_u4E0E_ctrl_p_u63D2_u4EF6"><a href="#vim_u5206_u5C4F_u4E0E_ctrl_p_u63D2_u4EF6" class="headerlink" title="vim分屏与 ctrl p插件"></a>vim分屏与 <code>ctrl p</code>插件</h2><p>之前总是听说 <code>ctrl p</code> 插件如何如何好用。不过我开始试用的时候，确实没有体会到太强大的地方，知道后来发现vim的分屏功能。</p>
<p>试用vim分屏功能，加上ctrl p实现了不退出vim直接打开多个文件的功能，节省了大量在命令行下各种 <code>cd 目录</code> 的时间。</p>
<p>参考：<a href="http://coolshell.cn/articles/1679.html" target="_blank" rel="external">Vim的分屏功能</a></p>
<h2 id="u57FA_u7840_u6B63_u5219_u8868_u8FBE_u5F0F"><a href="#u57FA_u7840_u6B63_u5219_u8868_u8FBE_u5F0F" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>有一次，我需要在一个包含很多行短文字的后面补上的空格，将每一行补成相同的宽度。<br>刚开始使用各种列编辑，块编辑尝试都没有用。难道必须写一个程序来专门处理这件事情？</p>
<p>后来发现正则表达式基本能满足这一要求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/$/ n_spaces /g</span><br></pre></td></tr></table></figure>
<p>在vim中，$符有丰富的含义，这里值指的是行尾前一个字符</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录用到的一些vim使用方法，积累够一定数量再整理</p>
<h2 id="vim_u5206_u5C4F_u4E0E_ctrl_p_u63D2_u4EF6"><a href="#vim_u5206_u5C4F_u4E0E_ctrl_p_u63D2_u4EF6" class]]>
    </summary>
    
      <category term="vim" scheme="http://starding.github.io/tags/vim/"/>
    
      <category term="vim" scheme="http://starding.github.io/categories/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从快播案看技术中性论的地位]]></title>
    <link href="http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/"/>
    <id>http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/</id>
    <published>2016-01-11T05:07:32.000Z</published>
    <updated>2016-01-12T07:44:17.000Z</updated>
    <content type="html"><![CDATA[<p>本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。</p>
<blockquote>
<p>technological neutrality</p>
<p>中文意思为「技术中性论」， 核心主张是技术是纯粹的，价值中立的，其本身不存在是非善恶这些性质；技术的归宿是人类的使用，而最终产生的结果，也应该由人类自身来承担。</p>
</blockquote>
<h1 id="u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA"><a href="#u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA" class="headerlink" title="快播案中的技术中性论"></a>快播案中的技术中性论</h1><p>最近的快播案中的辩论，有关技术价值部分，可以说是「技术中性论」在科学哲学中所受讨论的缩影：技术中性论在科学哲学中，持续了非常长的一段时间，而且直到今天还非常有市场。在普通民众群体中，技术中性论甚至更是唯一的关于技术的价值观。</p>
<p>「技术中性论」价值观中，有一些非常常见的论据：</p>
<ul>
<li>日常生活中的例子：用刀杀了人，有罪的是人，而不是刀，也不是生产刀的厂家。</li>
<li>科学中的例子：原子弹是无罪的，有罪的是滥用它们的人。</li>
<li>互联网的例子：木马是无罪的，有罪的是用它们来进行非法活动的人。</li>
</ul>
<p>这些主张都是在论证技术的价值中立特点。后面会说这些论据的漏洞在哪里。</p>
<h2 id="u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA"><a href="#u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA" class="headerlink" title="科学哲学中的技术中性论"></a>科学哲学中的技术中性论</h2><p>其实「技术中性论」的观点，在科学哲学中很早就出现了，而且因为技术本身的「自我隐蔽性」，技术所附带的价值天然倾向于中立性。在近代工业革命之后，技术的弊病逐渐显露出来，而对技术价值的反思，也在科学哲学中有了新的进展。</p>
<h3 id="u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u7684_u524D_u63D0_uFF1A_u5F53_u6211_u4EEC_u5728_u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u65F6_uFF0C_u6211_u4EEC_u5728_u8BA8_u8BBA_u4EC0_u4E48_uFF1F"><a href="#u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u7684_u524D_u63D0_uFF1A_u5F53_u6211_u4EEC_u5728_u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u65F6_uFF0C_u6211_u4EEC_u5728_u8BA8_u8BBA_u4EC0_u4E48_uFF1F" class="headerlink" title="讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？"></a>讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？</h3><p>『技术没有价值偏向。一切技术的使用，所产生的后果，归根结底都应该由人类承担，不管它是好的或是坏的』。从根本上讲，这句话是对的，因为如果不是人类，根本就不会有技术，那也就不会有技术带来的副作用。在这种意义下，说『所有的罪，最终都归于人类』也无可厚非。</p>
<p>但是在现实中，并不能这样去讨论问题。即便是技术哲学中，在上面的意义下讨论问题也是无意义的，这种意义下的讨论不会给人类理解技术带来任何实质的帮助。</p>
<p>讨论技术价值的前提是：</p>
<p><strong>『技术是人类创建出来的，也是由人类使用的。技术并不是「死的」，它对人类是有影响的』</strong></p>
<p>在这种前提下，我们在讨论技术价值时，我们讨论的是：技术本身是否真的是纯粹的，技术会不会在某些方面对人类产生副作用。更准确地说，技术是人类创造出来的，那么这种创造物，对人类的自我建构会不会产生影响？</p>
<h3 id="u6280_u672F_u7684_u610F_u5411_u7ED3_u6784"><a href="#u6280_u672F_u7684_u610F_u5411_u7ED3_u6784" class="headerlink" title="技术的意向结构"></a>技术的意向结构</h3><p>试想这样一种情景：</p>
<p>有两个民族，一个民族在族人很小的时候，就送他们刀与马。而另一个民族，则送他们诗与书。那么在这两个民族成长之后会发生什么呢？可以想象，第一个民族，刀会成为他们首选的说话方式。而第二个民族，诗书则会成为他们选择的说话方式。</p>
<p>再举一个更贴近生活的例子，又一次老板问我，mac用着爽吗？是不是用mac，用着这些比较好的工具，就是想写东西，想写代码？用mac，你就是想写代码，用windows，你就是想玩儿游戏。</p>
<p>上面的例子是想要说明，技术本身是有它的意向结构的，这种意向结构带有一种附加的价值，不自觉地对人类产生副作用。这种副作用的产生，不是人类可以选择的，在群体中更是如此。人类身处自身范式之中，没有这种能力，去清晰的分辨一种意向结构长期带来的影响。</p>
<p>需要注意的是，这里只是说技术有自己的意向结构，反过来对人类产生不自觉地副作用。并没有对这种意向结构，做出价值上的判断，即没有判断它是好还是坏。实际上，这是一个相当艰巨，甚至多数时候是不能完成的任务。</p>
<p>另一方面，说技术对人类的自我建构有副作用，也不像传统哲学中的「决定论」那样，会出现人类没有自由意志，做出的任何决定，犯下的任何过错，都不用，也不能承担后果的局面。</p>
<p>在技术哲学中，技术的非中性论论题主张『技术与人类是互相构建的』</p>
<h3 id="u56DE_u5230_u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA_u70B9"><a href="#u56DE_u5230_u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA_u70B9" class="headerlink" title="回到快播案中的技术中性论点"></a>回到快播案中的技术中性论点</h3><p>技术的意向结构，决定了它必然会对人类产生副作用，也揭示出前面所列举论据的一个非常大的漏洞：它假设了一个前提，就是人类可以完全清醒的判断，一样技术的使用会有什么潜在的副作用。换句话说，人类可以清楚的知道，并且控制技术所带来的反作用，包括那些非常明显的和潜伏的效果。</p>
<p>但这是不现实的，很多技术的副作用是难以察觉的，你很难清楚的知道，长期使用微信这项技术，对你会产生，或者已经产生了怎样的影响。更何况人类身处一个技术交织成的大网之中了。</p>
<p>另一方面是，技术对于群体产生的副作用比起对个人产生的副作用，要更为复杂了，因为一个群体中的行为并不是简单个人行为的叠加，一种技术对群体带来的影响更为深远。以编程语言为例，纯粹的c程序员和python程序员必然是有差别的，而这些差别体现到群体上，基本就反映出了C和python设计哲学中的差别，也就是其本身意向结构的差别。</p>
<p>也就是说，技术在群体中产生的作用，最终会更接近技术本身意向结构：如果快播可以方便的传播淫秽资料，那么在目前文明阶段的自然情况下，它必然会传播淫秽资料，而不是学习资料。如果明白了这一点，也就能清楚的直到关键点在哪——控制，监管，批判，反思。</p>
<p>这也是技术批判理论主张的：</p>
<p><strong>『即使技术是由自身的意向结构的，但这对于我们的指导是更谨慎，更批判的去处理它，而不是直接对其做出价值判断来肯定或否定它』</strong></p>
<h2 id="u79D1_u5B66_u54F2_u5B66_u4E0E_u793E_u4F1A_u6280_u672F_u51B3_u7B56"><a href="#u79D1_u5B66_u54F2_u5B66_u4E0E_u793E_u4F1A_u6280_u672F_u51B3_u7B56" class="headerlink" title="科学哲学与社会技术决策"></a>科学哲学与社会技术决策</h2><p>待续</p>
<h1 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h1><p>关于技术的哲学，之前从未有过深思。仅从《娱乐至死》一书中体会到技术与人类的关系不是一分为二那么简单。后来也思考过技术中性论的问题，总觉得什么地方有问题，但是又说不上来，直到读了吴国盛老师的《技术哲学演讲录》，得到了一个迄今为止，我最为满意的一个答案：</p>
<blockquote>
<p><strong>『技术与人类是互相构建的』</strong></p>
</blockquote>
<h2 id="u300A_u6280_u672F_u54F2_u5B66_u6F14_u8BB2_u5F55_u300B_u5185_u5BB9_u8981_u70B9_u6458_u5F55_uFF1A"><a href="#u300A_u6280_u672F_u54F2_u5B66_u6F14_u8BB2_u5F55_u300B_u5185_u5BB9_u8981_u70B9_u6458_u5F55_uFF1A" class="headerlink" title="《技术哲学演讲录》内容要点摘录："></a>《技术哲学演讲录》内容要点摘录：</h2><h3 id="u6280_u672F_u7684_u4EBA_u6587_u672C_u8D28"><a href="#u6280_u672F_u7684_u4EBA_u6587_u672C_u8D28" class="headerlink" title="技术的人文本质"></a>技术的人文本质</h3><ul>
<li><p>什么是技术？</p>
<ul>
<li>技术是人的存在方式，技术与人并非是一分为二的</li>
</ul>
</li>
<li><p>人的本质是什么？</p>
<ul>
<li>人是一种没有本质的动物，人的本质是自我建构的</li>
</ul>
</li>
<li><p>技术的特性</p>
<ul>
<li><p>技术是自我隐蔽的，而西方学术史是只重视内在理路的历史</p>
</li>
<li><p>技术中性论的问题：技术是有意象结构的，包含着特定的价值取向</p>
</li>
<li><p>技术是构造人和世界的环节：身体技术，人类都是早产儿，身体塑造，知觉塑造。ppt的使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="u6280_u672F_u4E0E_u653F_u6CBB"><a href="#u6280_u672F_u4E0E_u653F_u6CBB" class="headerlink" title="技术与政治"></a>技术与政治</h3><ul>
<li><p>技术有政治吗</p>
<ul>
<li>技术与政治是相关的。政治干预技术，技术影响政治：火药消灭骑士阶层，是封建制度的掘墓者。水利社会与集权制度。</li>
</ul>
</li>
<li><p>技术的政治批判</p>
<ul>
<li>手推磨产生了封建制度，蒸汽磨产生了资本主义制度。</li>
</ul>
</li>
<li><p>泰勒制与福特制</p>
<ul>
<li>技术导致人性的退让：新闻上看到死人慢慢无视</li>
</ul>
</li>
<li><p>三种技术观</p>
<ul>
<li><p>技术乐观主义：技术中性论者，技术带来的问题只能用技术解决</p>
</li>
<li><p>技术悲观主义：技术自主论，有内在的发展逻辑，认为现代社会进入了一个单向度社会，差异感消失，技术的触角深入到每一个领域。但它是以整体观点看待技术，把技术看做铁板一块，没搞清楚技术各种可能性，只有深入细节，才能走出悲观主义。</p>
</li>
<li><p>技术批判理论：深入技术的细节，考察各方面。：技术转化论。流水线，计算机，通信，交通，宣传技术。一切新技术都要问谁受益，谁吃亏。</p>
</li>
</ul>
</li>
</ul>
<h3 id="u6280_u672F_u4E0E_u54F2_u5B66"><a href="#u6280_u672F_u4E0E_u54F2_u5B66" class="headerlink" title="技术与哲学"></a>技术与哲学</h3><ul>
<li><p>技术哲学的历史性缺席</p>
<ul>
<li><p>美，正义，善，艺术，科学，都是哲学关注点，技术却不是。</p>
</li>
<li><p>技术本身：自身隐蔽性，和长期的技术中性论</p>
</li>
<li><p>哲学：哲学注重说理，讲内在逻辑。：本质主义</p>
</li>
</ul>
</li>
<li><p>技术哲学的兴起</p>
<ul>
<li><p>技术本身的变化：近来技术的问题出现了，不再透明</p>
</li>
<li><p>哲学：本质主义的瓦解与现象主义的出现。经验论传承唯名论。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。</p>
<blockquote>
<p>technological neutrality</p>
<p>中文意思为「技术中性论」， 核心主张是技术是纯粹的，价值中立的，其本身不存在是非善恶这些性质；]]>
    </summary>
    
      <category term="科学哲学" scheme="http://starding.github.io/tags/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"/>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="科学史与科学哲学" scheme="http://starding.github.io/categories/%E7%A7%91%E5%AD%A6%E5%8F%B2%E4%B8%8E%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那些年我在python中扑过的街]]></title>
    <link href="http://starding.github.io/2016/01/10/traps-in-python/"/>
    <id>http://starding.github.io/2016/01/10/traps-in-python/</id>
    <published>2016-01-10T11:22:10.000Z</published>
    <updated>2016-03-17T07:12:54.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前事不忘，后事之师。       ——《战国策·赵策一》</p>
</blockquote>
<h2 id="python_u4E2D_u7684_u6A21_u5757_u5BFC_u5165"><a href="#python_u4E2D_u7684_u6A21_u5757_u5BFC_u5165" class="headerlink" title="python中的模块导入"></a>python中的模块导入</h2><h3 id="u5305_u5BFC_u5165"><a href="#u5305_u5BFC_u5165" class="headerlink" title="包导入"></a>包导入</h3><p>这个比较简单，一个例子带过吧，但刚开始确实扑街了…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件结构：</span></span><br><span class="line">packages</span><br><span class="line">├── __init__.py</span><br><span class="line">└── my_module.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是包导入</span></span><br><span class="line"><span class="keyword">import</span> packages</span><br><span class="line"><span class="comment"># 后续是从__init__.py中定义的属性中获取的</span></span><br><span class="line">packages.some_module.some_method</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是把包当做搜索路径上的一环</span></span><br><span class="line"><span class="keyword">from</span> packages <span class="keyword">import</span> some_module</span><br><span class="line">some_module.some_method</span><br></pre></td></tr></table></figure>
<h3 id="u6A21_u5757_u5BFC_u5165_u641C_u7D22_u8DEF_u5F84"><a href="#u6A21_u5757_u5BFC_u5165_u641C_u7D22_u8DEF_u5F84" class="headerlink" title="模块导入搜索路径"></a>模块导入搜索路径</h3><p>例如下面的使用场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># django中有一个common app，并且已经添加到已安装app列表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># common app文件结构</span></span><br><span class="line">common</span><br><span class="line">├── __init__.py</span><br><span class="line">├── common.py</span><br><span class="line">├── others.py</span><br><span class="line">└── somethings.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># somethings.py中存在导入语句</span></span><br><span class="line"><span class="keyword">from</span> common.others <span class="keyword">import</span> some_func   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，由于common的名称相同，以及搜索路径默认是先从当前执行代码所在目录开始搜索，所以 common 文件 会在common 包之前被搜索到，造成搜索路径上的覆盖。而一旦搜索到common时，就会去common文件中查找some_func， 但是无法找到，这样就会报错。</p>
<h2 id="try-except-finally_u4E2D_u8BED_u53E5_u6267_u884C_u987A_u5E8F"><a href="#try-except-finally_u4E2D_u8BED_u53E5_u6267_u884C_u987A_u5E8F" class="headerlink" title="try-except-finally中语句执行顺序"></a>try-except-finally中语句执行顺序</h2><p>在python的异常处理中，无论try语句中是否有异常抛出，finally语句总会被执行。由于这个特性，finally语句经常被用来做一些清理工作，例如关闭文件，数据库等等。</p>
<p>如果当try-except-finally中出现异常，并且未被妥善处理时，python会先把发生的异常暂存，当finally中的动作执行完毕之后，把保存的异常返回给上级。try-except-finally中的语句执行顺序，决定了它会有一些潜在的陷阱。</p>
<p>看以下例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finallyTest</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'start------'</span></span><br><span class="line">    <span class="keyword">while</span>  <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"running------"</span></span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"r"</span>)   <span class="comment">#抛出异IndexError异常</span></span><br><span class="line">        <span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'NameError happended &#123;0&#125;'</span>.format(str(e))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'finally executed'</span></span><br><span class="line">            <span class="keyword">break</span> <span class="comment">#finally语句中有break语句</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 执行测试函数</span></span><br><span class="line">FinallyTest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为：</span></span><br><span class="line">start------</span><br><span class="line">running------</span><br><span class="line"><span class="keyword">finally</span> executed</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在try语句中，raise出了一个IndexError异常，而且except语句也没有捕获这个错误。按照平常的理解，这个错误会向上级（也就是调用这个函数的程序）传递，在本例中会传递到解释器，并引发一个IndexError错误。但是整个函数执行完之后并没有异常出现。</p>
<p>原因就在于在当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被「临时保存起来」。当finally执行完毕的时候，临时保存的异常将会「再次被抛出」，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会被丢失，从而导致「异常屏蔽」。</p>
<p>另外一个稍微复杂一些例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.Logger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">returnTest</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> a == <span class="keyword">False</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"data can not be False"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a  </span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">"exception!, &#123;detail&#125;"</span>).fomat(detail)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"return exception in except statement"</span> </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"return in finally statement"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> returnTest(<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> returnTest(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>按照平常理解，第一个print语句会触发错误，然后进入except语句打印异常，而同时finally部分中的语句必然会执行，所以这里会返回一个’return in finally statement’值。第二个则会返回True。实际上则不然，返回值竟然都是’return in finally statement’。</p>
<p>原因是和上面的例子中是一样的，无论是try复合语句中，还是except复合语句中的return/break语句，这种会产生程序跳转的语句会先被保存起来。然后再去执行finally中的语句，而一旦finally中出现了跳转语句，就会直接跳转了，这样早成的结果就是上面保存状态的消失。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_u7684_u9650_u5236"><a href="#u5B57_u5178_u63A8_u5BFC_u7684_u9650_u5236" class="headerlink" title="字典推导的限制"></a>字典推导的限制</h2><p>在做一个项目的时候，遇到一个需要多次请求数据库的操作，详细情况就是，有一些公司，这些公司本身有名字，公司代号这样的组织，如果每次都从数据库中取公司信息，会有性能问题。于是就采用用字典缓存下来，于是想使用字典推导。发现推导时只能生成单元素，之前我没有留意过这一点，在此记录一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样是可以的</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key: model.value <span class="keyword">for</span> Modle <span class="keyword">in</span> models &#125;</span><br><span class="line"><span class="comment"># 结果就是个普通的字典</span></span><br><span class="line">&gt;&gt;&gt;&#123;key1: value1, key2: value2, ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是想要下面这样使用是不支持的</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key1: model.value1, moedel.key2: model.value2 <span class="keyword">for</span> model <span class="keyword">in</span> models&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 折中的办法是将上面的value值换成一个字典，或者是使用列表推导再封装一层列表</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key1: &#123;models.key1: models.value1, model.key2: model.value2, ...&#125; <span class="keyword">for</span> model <span class="keyword">in</span> models&#125;</span><br></pre></td></tr></table></figure>
<p>补充一下实际的例子，其中branch相关的是分公司信息，subbranch相关的是中支公司信息，目的是构造一个，分公司名称为key值，分公司的主键，编号，以及该分公司辖下的中支公司为value值的字典，其中的中支公司也是一个字典：以中支公司名称为key值，中支公司的其他信息为value值。这样就构成了一个公司数据的二阶字典缓存列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">companys_by_name = &#123;</span><br><span class="line">        branch.name: &#123;</span><br><span class="line">            <span class="string">"pk"</span>: branch.pk,</span><br><span class="line">            <span class="string">"number"</span>: branch.number,</span><br><span class="line">            <span class="string">"subbranch"</span>: &#123;</span><br><span class="line">                subbranch.name: &#123;<span class="string">"pk"</span>:subbranch.pk, <span class="string">"number"</span>:subbranch.number&#125; <span class="keyword">for</span> subbranch <span class="keyword">in</span> SubbranchCompany.objects.filter(branch_company=branch)</span><br><span class="line">            &#125; <span class="keyword">for</span> branch <span class="keyword">in</span> BranchCompany.objects.all()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细含义如下，其中中支公司是分工司辖下的公司</span></span><br><span class="line">公司信息字典 = &#123;</span><br><span class="line">     分公司名字:&#123;</span><br><span class="line">        <span class="string">"主键"</span>: 当前迭代分公司主键，</span><br><span class="line">        <span class="string">"公司号"</span>: 当前迭代公司公司号，</span><br><span class="line">        <span class="string">"中支公司"</span>:&#123;</span><br><span class="line">            中支公司名字:&#123;</span><br><span class="line">                <span class="string">"主键"</span>: 当前迭代中支公司主键,</span><br><span class="line">                <span class="string">"中支公司号"</span>: 当前迭代中支公司号,</span><br><span class="line">            &#125; <span class="keyword">for</span> 中支公司 <span class="keyword">in</span> 当期迭代分公司下中支公司集合</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">for</span> 分公司 <span class="keyword">in</span> 分公司集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前事不忘，后事之师。       ——《战国策·赵策一》</p>
</blockquote>
<h2 id="python_u4E2D_u7684_u6A21_u5757_u5BFC_u5165"><a href="#python_u4E2D_u7]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open Questions]]></title>
    <link href="http://starding.github.io/2016/01/10/open-questions/"/>
    <id>http://starding.github.io/2016/01/10/open-questions/</id>
    <published>2016-01-10T07:23:04.000Z</published>
    <updated>2016-01-10T13:18:29.000Z</updated>
    <content type="html"><![CDATA[<p>本文专门用于汇总一些平时遇到的问题。<br>这些问题有的有一些我的初步思考，但可能存在很大的缺陷，甚至根本上就是错误的。而有的是刚遇到，或者是刚刚想到的问题，因为身处于自己的范式之中，我目前甚至都判断不清楚这些问题是不是幼稚的，这些问题本身是不是就有问题。</p>
<p>或许是受过一点科学哲学教育的原因，总是想着在学习的过程中，试着了解一件事物的目的因。虽然在自然科学研究中，追寻直推因是知识增长的最佳方式，目的因的追求往往产生问题，而且不现实。但是，在计算机科学中，有非常多的事物是人类直接定义的，可以说计算机世界大部分都是人类自己创造的，在这样的情况下，追求目的因才是最好，也是最深刻的知识增长方式。</p>
<p>总之，我把问题以及目前的思路记录下来了。<br>对于我来说，能提出问题的时候，才是真正开始理解的时候</p>
<h2 id="u5DE5_u7A0B_u7C7B_u95EE_u9898"><a href="#u5DE5_u7A0B_u7C7B_u95EE_u9898" class="headerlink" title="工程类问题"></a>工程类问题</h2><ul>
<li>RESTful 与 ROA（面向资源的架构）之间的关系是什么？<ul>
<li>RESTful我是大致了解的，而且也简单实践过。</li>
<li>面向资源的架构，按照字面意思来理解，就是以资源为中心的架构，比如在后台，按照资源分类，实现各个资源的切分，然后按照比较独立的资源进行组合出想要的内容。</li>
<li>以一个隐喻来说，就像是在建造一幢大楼时，所有的原材料（资源）都以比较细分的方式给出来了，而且，理论上利用这些原材料，能构建出大部分结构的大楼。</li>
</ul>
</li>
</ul>
<h2 id="Meta__u95EE_u9898"><a href="#Meta__u95EE_u9898" class="headerlink" title="Meta 问题"></a>Meta 问题</h2><ul>
<li>计算机科学与自然科学学习中的不同。<ul>
<li>主要是有关方法论的。在自然科学中，比如物理学中，我们可能试着找出一件事物的目的因，比如为什么光速是有限的之类的，或是像生物学中的，为什么对于人类来说，乙醇没毒，而甲醇等相似结构的毒性却很大。在自然科学的研究中，我们会直接去寻找它表现为什么样，这叫做直推因，而且这种研究方式在自然科学中，很容易获得知识的增加。</li>
<li>在计算机科学中，大部分世界都是人类创造的，人类直接定义，制造了这个世界，所以很多时候，我们是可以追问目的因的，虽然追问到最后，仍有一部分问题会回到自然科学中，或是形式科学中。但是追寻目的因可以让我们更快速的深入一个问题的本质。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文专门用于汇总一些平时遇到的问题。<br>这些问题有的有一些我的初步思考，但可能存在很大的缺陷，甚至根本上就是错误的。而有的是刚遇到，或者是刚刚想到的问题，因为身处于自己的范式之中，我目前甚至都判断不清楚这些问题是不是幼稚的，这些问题本身是不是就有问题。</p>
<p>或]]>
    </summary>
    
      <category term="open-questions" scheme="http://starding.github.io/tags/open-questions/"/>
    
      <category term="open-questions" scheme="http://starding.github.io/categories/open-questions/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的前端笔记之理解html篇]]></title>
    <link href="http://starding.github.io/2016/01/09/my-front-end-introduction/"/>
    <id>http://starding.github.io/2016/01/09/my-front-end-introduction/</id>
    <published>2016-01-09T06:34:19.000Z</published>
    <updated>2016-01-26T12:46:35.000Z</updated>
    <content type="html"><![CDATA[<p>之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像html的某个元素啦，或是某个css的具体意思了，再或者是写一点javascript啦之类的内容。但总是感觉对前端缺乏一种比较顶层的认识。</p>
<p>虽然偶尔也会听说一些关于网页三剑客的比喻。类似html是网页的骨骼，负责网页的骨架部分；css是网页的皮肤，负责网页的外观部分；javascript则是网页的肌肉，给网页上的交互提供动力。不过这种说法似乎又太过于宽泛了，难以让人形成具体的认识。</p>
<p>所以本文试着整理一种介于上述比喻，以及底层细节之间的一些内容。通过分别叙述html，css，javascript的核心角色，试着能不能找到那种高屋建瓴的感觉。</p>
<p>首先辨析一下前端两个概念：「排版」和「布局」</p>
<p>参考知乎的两个回答：<br><a href="/有没有人觉得web排版系统，设计得非常非常烂？ - 回答作者：徐飞 http://zhihu.com/question/38795148/answer/78177006?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu（想看更多？下载知乎 App：http://weibo.com/p/100404711598）">排版和布局是两个不同的东西</a><br>和<br><a href="/在 CSS 中，用 float 和 position 的区别是什么？ - 回答作者：贺师俊 http://zhihu.com/question/19588854/answer/13243044?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu（想看更多？下载知乎 App：http://weibo.com/p/100404711598）">布局和排版是有差异的</a></p>
<p>「布局」指的是宏观GUI的划分，比如你有多个大块的东西，想要按照指定方式排布。</p>
<p>「排版」指的是，比如你有一些段落，段落中有不同的字体，不同字号，按照不同基线对齐、折行、断词，并且合理处理溢出的部分。</p>
<h2 id="u4ECE_u7F51_u9875_u8BF4_u8D77"><a href="#u4ECE_u7F51_u9875_u8BF4_u8D77" class="headerlink" title="从网页说起"></a>从网页说起</h2><h3 id="u7F51_u9875_u662F_u73B0_u5B9E_u751F_u6D3B_u4E2D_u5404_u79CD_u4FE1_u606F_u8F7D_u4F53_u7684_u7F51_u7EDC_u805A_u5408_u7248"><a href="#u7F51_u9875_u662F_u73B0_u5B9E_u751F_u6D3B_u4E2D_u5404_u79CD_u4FE1_u606F_u8F7D_u4F53_u7684_u7F51_u7EDC_u805A_u5408_u7248" class="headerlink" title="网页是现实生活中各种信息载体的网络聚合版"></a>网页是现实生活中各种信息载体的网络聚合版</h3><p>网页，是前端最直接的展示部分。它的目的在于「展示信息」，其他的一切活动都是为展示信息服务的。 网页和其他的展示信息的载体，并没有什么本质的差别。想象一下我们日常生活中常见的信息载体：一个word文档，一份PDF，一份调查问卷，一份财务报表等等。而网页就是这些信息载体的网络聚合版本。</p>
<h3 id="u4EBA_u7C7B_u5728_u5173_u6CE8_u7F51_u9875_u65F6_uFF0C_u4EBA_u7C7B_u5728_u5173_u6CE8_u4EC0_u4E48"><a href="#u4EBA_u7C7B_u5728_u5173_u6CE8_u7F51_u9875_u65F6_uFF0C_u4EBA_u7C7B_u5728_u5173_u6CE8_u4EC0_u4E48" class="headerlink" title="人类在关注网页时，人类在关注什么"></a>人类在关注网页时，人类在关注什么</h3><p>就像我们对待生活中的那些信息载体以及其所附带的信息那样，我们也会以类似的态度对待网页：首先关注的是文档本身展示出的内容，如果这些内容展示的格式非常漂亮，那可能会让我们阅读时更愉快，也更愿意去阅读更多的内容，另外，如果这些信息载体要是再多一些互动就更容易吸引人了。</p>
<p>也就是说，人类在关注网页时，仍然是: 内容-&gt;样式，交互 的顺序，当然在网页越来越丰富多彩的今天，样式和交互也越来越被看重，甚至已经和内容一样重要的程度了。</p>
<p>而内容，对应着html；样式和交互，则由css和javascript共同决定</p>
<h2 id="html_u2014_u2014_u5E26_u8BED_u4E49_u7684_u6587_u6863_u6D41"><a href="#html_u2014_u2014_u5E26_u8BED_u4E49_u7684_u6587_u6863_u6D41" class="headerlink" title="html——带语义的文档流"></a>html——带语义的文档流</h2><h3 id="u7F51_u9875_u7684_u300C_u4E24_u79CD_u8BED_u4E49_u300D"><a href="#u7F51_u9875_u7684_u300C_u4E24_u79CD_u8BED_u4E49_u300D" class="headerlink" title="网页的「两种语义」"></a>网页的「两种语义」</h3><p>当然网页作为信息载体和日常生活中的实体还是有区别的。虽然网页上的信息最终受众是人类，但它要通过浏览器，搜索引擎，或是一些其他能够处理网页的程序来实现这一功能。这也就形成了网页的两种语义：</p>
<ul>
<li>第一种语义是最终展示出来的语义，由人类来理解，也就是平时理解的语义。</li>
<li>第二种语义是由浏览器，搜索引擎等机器程序可理解，属于「机器可读的语义」</li>
</ul>
<p>最终呈现出的语义，是由人类的知识结构来决定的，人类会将页面上不同的内容，理解成为「标题」，「内容」， 「脚注」， 「导航」等具有特定语义的元素。也正是因为这个原因，有些html元素，生来就带有一定的样式，比如h1~h6这些标题，字号会比较大，同时也会加粗。这是符合人类的常识的，也与最终要展示的语义贴合，因此这样的设定会非常方便。</p>
<p>而第二种语义，也就是机器可读的语义，从上面的意义上说，是为第一种语义服务的。浏览器，搜索引擎等程序会识别html代码中的语义元素，然后加上样式等最终展示出来。语义化越强的html，越方便于机器去理解。在软件领域，语义化往往是建立在合理的「结构化」之上的，所谓「结构化」指的就是不同语义部分的内容，采用不同的结构加以区分，而html中的结构化，其实就是使用各类html标签完成的。</p>
<p>让第一种语义更友好的展示，是网页的整体目标。这需要设计师，信息架构师，程序员的通力合作。</p>
<p>让第二种语义更好的服务于第一种语义，是程序员的本质工作。</p>
<h3 id="u4E3A_u4EC0_u4E48_u7B2C_u4E8C_u79CD_u8BED_u4E49_u662F_u91CD_u8981_u7684"><a href="#u4E3A_u4EC0_u4E48_u7B2C_u4E8C_u79CD_u8BED_u4E49_u662F_u91CD_u8981_u7684" class="headerlink" title="为什么第二种语义是重要的"></a>为什么第二种语义是重要的</h3><p>有一个非常合适的例子可以说明第二种语义的重要性。不知道你在使用智能手机的时候有没有遇到过这样的情况：</p>
<p>有时候需要在某个网站上输入东西时，会弹出输入法。但是不同的输入框，弹出的输入法的界面又有所不同，当你输入邮箱时，会弹出带@符号的键盘，当你需要输入密码时，弹出的是全键盘等等。而且更奇怪的时，这个功能有时候灵，有时候不灵。这个功能好用的时候，你会感觉输入内容时非常顺畅，不灵时，你就要手动切换输入法的不同的界面，找到你需要的符号。感觉就非常不爽。</p>
<p>这背后就是第二种语义在起作用：在html中，输入框有很多不同的类型，有的是email，有的是password，有的是text。如果一个网站很好的对这些语义做了区分，并且应用在了他们的html中。那么上述的输入法弹窗表现的就会很智能。因为机器可以根据html中不同的语义来选择弹出什么样的界面。如果是emai，就弹出带@符号的界面，如果是密码，就弹出全键盘等等。但是如果语义化做的不好的网站，就做不到这一点，只会统一弹出通用界面，需要人类去判断，切换。</p>
<p>这个例子是要说明，在浏览器等软件越来越智能化的今天，html的语义化也变得越来越重要。</p>
<p>上面也提到，浏览器一般会给一些特定的html元素以特定的样式，但是这只是因为这样做比较符合人类尝试，能够提供便利性。千万不要因为想要某个样式去使用元素，而是应该给要标记的内容选择最合适语义的元素。至于样式，则应该交由css去处理。『html只关注语义，不关注布局，也不关注样式或交互』，这样的总结，也是出于这个原因。</p>
<h3 id="u4EE5html_u7684_u8BED_u4E49_u6765_u7406_u89E3_u7F51_u9875"><a href="#u4EE5html_u7684_u8BED_u4E49_u6765_u7406_u89E3_u7F51_u9875" class="headerlink" title="以html的语义来理解网页"></a>以html的语义来理解网页</h3><p>上面说完语义的重要性，接着来看如何通过理解这些第二类语义元素来理解网页。这部分内容涉及的元素比较多，这里只是粗略说明一下。</p>
<p>首先网页有不少展示用的语义化元素用来展示信息。</p>
<p>像最基本的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">main</span>&gt;</span><span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--尾部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--章节--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">section</span>&gt;</span><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--独立片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">artical</span>&gt;</span><span class="tag">&lt;/<span class="title">artical</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以及更具体的:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">time</span>&gt;</span><span class="tag">&lt;/<span class="title">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">address</span>&gt;</span><span class="tag">&lt;/<span class="title">address</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这些都是普通的语义化的来展示信息的元素。但是像现实生活那样，信息展示还有其他的方式，有助于人类更好的阅读和理解。比如：</p>
<ul>
<li><p>列表</p>
<p>  它分条分类的列出比较核心的信息，可以让人更快的理解清楚一件事物的各方面重点。html中</p>
</li>
<li><p>嵌入式的元素</p>
<p>  如图片，所谓一图胜千言。<br>  再如音乐，视频等等</p>
</li>
</ul>
<p>另外，现实生活中，我们常会遇到通过分发纸质的表单，用来收集信息。还有报表，用来清楚的展示分门分类的比较格式化的信息。这在html中也有相应的语义元素，分别是：</p>
<ul>
<li>表单（form）</li>
<li>表格（table）</li>
</ul>
<p>他们的作用也和现实生活中的大同小异，而且html中的表单有多种多样的类型，单选框，复选框，输入框（输入框本身也有更细的语义化的类型）。这和现实中的多种多样的调查表单都是相似的。</p>
<p>另外，html中还多了一些独特的语义元素。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接,可能是最重要的独特元素，它把各个页面通过网络组合了起来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他一些元素，这些元素或描述了网页关系，或是描述网页信息等等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本的html元素，就是上述这些种类，可以看到，这些元素组合起来，即有收集信息的部分，又有展示信息的部分，而且为了更好的展示信息，html又提供了许多语义化的元素。</p>
<p>这些元素组合在一起，一起形成了网页的全部语义信息，几乎可以实现和模仿现实中的所有信息载体，某些方面犹有胜之。</p>
<h3 id="u6587_u6863_u6D41"><a href="#u6587_u6863_u6D41" class="headerlink" title="文档流"></a>文档流</h3><p>除了前面所说的一些元素会根据常识带有一些样式外（如果说这算排版样式的话），html还有一种简单的默认的布局方式（姑且这叫布局样式）：也就是从上到下，从左至右依次排列元素。用更形象的说法是，这叫html文档流。</p>
<p>这种默认的文档流，给html提供了符合常识的，也是最基础的布局，不至于说所有元素都乱糟糟的堆在一起。但还是强调那句话，虽然浏览器给html提供了一些默认的样式和布局，但这都是基于人类直觉和常识的：<strong>『html只关注语义，不关注布局，也不关注样式或交互』</strong></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM 全称为 Document Object Module，也即文档对象模型。来看<a href="https://www.w3.org/DOM/" target="_blank" rel="external">W3.org上的解释</a></p>
<h4 id="u4EC0_u4E48_u662F_Document_Object_Model_3F"><a href="#u4EC0_u4E48_u662F_Document_Object_Model_3F" class="headerlink" title="什么是 Document Object Model?"></a>什么是 Document Object Model?</h4><blockquote>
<p>The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page. </p>
<p>文档对象模型是「平台和语言无关的接口」，允许程序或脚本来动态地获得和更新文档的内容，结构以及样式等。这样，文档就可以以后再被处理（further processed），而且处理的结果反过来合并入目前的页面上。</p>
</blockquote>
<h4 id="Why_the_Document_Object_Model_3F"><a href="#Why_the_Document_Object_Model_3F" class="headerlink" title="Why the Document Object Model?"></a>Why the Document Object Model?</h4><blockquote>
<p>“Dynamic HTML” is a term used by some vendors to describe the combination of HTML, style sheets and scripts that allows documents to be animated. The W3C has received several submissions from members companies on the way in which the object model of HTML documents should be exposed to scripts. These submissions do not propose any new HTML tags or style sheet technology. The W3C DOM Activity is working hard to make sure interoperable and scripting-language neutral solutions are agreed upon.</p>
<p>“动态html”是一些厂商描述HTML，style sheet（样式表）和scripts（脚本）结合起来实现文档动态化的说法。W3C已经收到了来自一些团体组织的submission，描述了HTML文档对象模型应该以何种方式暴露给scripts。这些submission不建议任何新的HTML标签和样式表技术。W3C组织的DOM运动累成狗，就是为了尽量协调多方需求以及形成平台和语言中立的解决方案。</p>
</blockquote>
<h4 id="u4E0A_u9762_u4E24_u6BB5_u5728_u8BF4_u5565_uFF1F"><a href="#u4E0A_u9762_u4E24_u6BB5_u5728_u8BF4_u5565_uFF1F" class="headerlink" title="上面两段在说啥？"></a>上面两段在说啥？</h4><p>也就是说，DOM呢，是文档对象模型，它不是属于某个具体语言的标准库啥的，它是一种与语言和平台无关的模型。其他语言想要操作HTML文档（其实不仅是HTML，还有XML等一些结构化语言）呢，就必须按照这个对象模型设计自己的操作方式。</p>
<p>推出DOM这个东西的原因就是原来有一批人在撕逼，你有你的想法，我有我的思路。W3C为了一统武林，就提出了DOM，并且不断的规范它，这样对大家都好。</p>
<p>DOM本身是挺复杂的东西，但是我们平常所用的DOM，只用了解到它的大致模样，以及知道如何操作就算入门了。我们平常说的DOM，其实就是一种HTML的树形结构：</p>
<p><img src="http://www.w3school.com.cn/i/ct_htmltree.gif" alt="DOM tree"></p>
<p>通过上图中的树形结构，可以使用其他实现了DOM操作的语言，如javascript等，按照一定的规则来操作这些节点。而这棵DOM树本身也定义了一些继承的概念，用于更方便的控制其中的节点。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>以上基本上就是html核心的全部了，用几个词来总结一下就是：语义，基于常识的元素默认样式，文档流，以及DOM。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像html的某个元素啦，或是某个css的具体意思了，再或者是写一点javascript啦之类的内容。但总是感觉对前端缺乏一种比较顶层的认识。</p>
<p>虽然偶尔也会听说一些关于网页三剑客的比喻。类似html是网页]]>
    </summary>
    
      <category term="前端" scheme="http://starding.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://starding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《三体》，《行尸走肉》与社会达尔文主义]]></title>
    <link href="http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/"/>
    <id>http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/</id>
    <published>2016-01-07T07:55:11.000Z</published>
    <updated>2016-02-29T14:34:32.000Z</updated>
    <content type="html"><![CDATA[<p>看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘的七七八八。刚开始看《行尸走肉》时，还以为是个单纯的丧尸剧，但随着剧情的不断深入，发现它描述了更多的东西。在某些重要的方面，比如场景的设定上，是非常相似的。不过是一个把达尔文主义推广到整个宇宙，建立了较为极端的达尔文性质的宇宙社会学。另一个则是将人类放入一个充满死亡的世界，以小团体进行黑暗森林式的生存，让自人类开始出现以来，数百万年形成的世界秩序重新洗牌，重新审视人类这一物种，同样渗透着浓厚的达尔文思想。</p>
<h1 id="1_uFF1A_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u57FA_u672C_u8BBE_u5B9A"><a href="#1_uFF1A_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u57FA_u672C_u8BBE_u5B9A" class="headerlink" title="1：《三体》与《行尸走肉》的基本设定"></a>1：《三体》与《行尸走肉》的基本设定</h1><p>二者的设定都充满了浓厚的达尔文色彩，非常强调生存竞争。</p>
<p>首先看进化论的基础：特定环境中，资源是有限的，仅能支持一定数量的生命体，而生命的数量是不断增长，为了争夺有限的生存资源必须进行生存斗争，获胜的将存活下来，而失败的遭到淘汰。</p>
<p>《三体》设定：大刘将上述思想扩展到整个宇宙，在宇宙层面设定了一种类似的社会学，即宇宙整体资源也是有限的，宇宙中生存着各种各样的文明，而且越是高层次的文明，所需求的资源越多，同时，各文明的最高标准是”生存是文明的第一需要“，要想生存。大刘在这样一个宇宙中来演绎文明的生存策略。</p>
<p>《行尸走肉》设定：利用一场突如其来的病毒，打乱既有的世界秩序，将幸存的人类放入一个周围充满危险的，生存资源有限的行尸世界中，来展现末世人类的生存之道。</p>
<h1 id="2-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u4E2D_u7684_u7B56_u7565"><a href="#2-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u4E2D_u7684_u7B56_u7565" class="headerlink" title="2.《三体》与《行尸走肉》中的策略"></a>2.《三体》与《行尸走肉》中的策略</h1><p>《三体》：无论是三体人的智子干扰，或是歌者的二向箔抹杀，所采取的都是完全的黑暗森林式策略，没有合作，也没有博弈。毁灭你，与你何干，直截了当。这可以说是把生存竞争推到了极致。在豆瓣上，长期霸占《三体》区评论第一位的文章《信卢瑟，永世不得超生》【1】 所吐槽的卢瑟(loser)思维，正是这种被极致化的生存竞争思维。</p>
<p>《行尸走肉》：加入了更多的元素。主角末世前的职业为警察：原世界秩序，规则的最好代表。包括人性与道德的考察：警察，士兵，医生，教师，牧师，平民，孩子等作为不同类型人群的代表，有着不同的人物展现。家庭式的，社区式的，陷阱式的等各种生存策略都一一考察。</p>
<h1 id="3-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u79E9_u5E8F"><a href="#3-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u79E9_u5E8F" class="headerlink" title="3.《三体》与《行尸走肉》的秩序"></a>3.《三体》与《行尸走肉》的秩序</h1><p>如今，除了一些原教旨主义者，很少有人会认为像《圣经》这样的文献是在直接描述自然真理了，最多是对自然做出一些隐喻。但认为其描述了道德与人性真理的说法仍然很有影响，尽管这一说法被达尔文进化论挑战。而中国虽然是礼仪之邦，不同时期有对道德的不同定义，但对定义本身缺乏深究，没有道德做哲学上寻根究底的传统。道德的本质是什么，世界秩序的本质又是什么，一直以来就是非常艰深的问题。</p>
<p>个人认为（应该不是我脑补过度）《三体》以文革为背景开始整个叙事，所要突出的正是文革时期那种满含猜疑的紧张气氛，以及当时道德秩序的混乱：仅需一场政治运动，便足以煽动无数人将数千年文明所谓道德人性推入深渊。文革中的一大主题就是如何生存下去，而且这仅仅是人类自身内部。将这些脆弱的存在推广到整个宇宙中的不同文明之间，并加以放大，黑暗森林并非不可想象。丧失理性会颠覆道德与人性，完全的理性同样也会。大刘展现了这样一种可能的残酷，道德什么的太靠不住，靠的住的是严格游戏规则，执剑者逻辑明白规则，程心（个人认为圣母程心就是道德与人性的代言人）不明白或者说不愿明白。失去人性失去很多，失去兽性，失去一切，大刘采用了不同的方式强调了这一点【2】。</p>
<p>《行尸走肉》将故事放在地球范围内，明显更为详细的对不同类型的人群进行了各式各样的考察。按剧情的发展来看，人类与行尸之间的冲突虽然一直是重要背景，但这一背景逐渐被弱化，人类与人类的冲突则逐渐被突出出来。数万年前人类逐渐开始产生社会形态，并利用语言，技术等进行自我规训，最终基本完成自我驯化，形成了一个压抑自己的意义世界【3】，个人认为这可以称作是道德和世界秩序的技术成因。但这种秩序是人类的特定阶段以及相应的特定的环境结合产生的，而末世结束了旧时秩序，同时结束的还有相应的社会和自然条件。在新的环境下，已经高度进化了的现代人，又该如何生存，能否重建一种不同的世界秩序，道德的标准又会发生什么变化？瑞克一行人在经历了众多情况之后，逐渐摆脱了原世界秩序的影响，在以警察为首的这一行人身上，还能看到生存之外的东西以及他们心理的摇摆不定，但是生存竞争已经在他们小组的意识中渗透的越来越深了，不知道采取何种策略才能更好的生存下去，但肯定不同于三体中的黑暗森林。</p>
<h1 id="4-_u8FBE_u5C14_u6587_u601D_u60F3_u4E0E_u793E_u4F1A_u5B66"><a href="#4-_u8FBE_u5C14_u6587_u601D_u60F3_u4E0E_u793E_u4F1A_u5B66" class="headerlink" title="4.达尔文思想与社会学"></a>4.达尔文思想与社会学</h1><p>达尔文的生存竞争思想在社会学中是很有地位的，并且以此发展出一种社会达尔文主义，而且达尔文思想在社会学中的应用会产生出一些逻辑清晰的，特别诱人的类似于科学中的那种分析方式（像《三体》这样就属一种）。但是达尔文自身过于强调了生存竞争的作用，忽视了生存竞争之外的现象，在社会中应用时也难以处理复杂的社会现象。另外，达尔文思想只是“演化”，而不是“进化”。</p>
<p> <strong>hexo对脚注的支持似乎很不好，暂时以标注的形式写出</strong></p>
<p>【1】: 详情见:<a href="http://book.douban.com/review/6146948/?start=800#comments" target="_blank" rel="external">信卢瑟，永世不得超生</a>,个人对这篇文章并不认同。我不认同的并不是其批评没有指中《三体》的要害。恰恰相反，此文对《三体》中的核心假定之一的批评相当到位：《三体》中的确采用了极致甚至很极端的生存竞争原则。个人不认同的是此文对科幻小说这一题材的误解：科幻小说一个常见手法是假定一个背景，然后以此展开，演绎出一个自洽的世界。大刘既然假定生存是文明的第一需要，那么以此写出的小说必定是这个样子。当然你可以假定生存不是文明的第一需要，来描述一个相对和谐的宇宙，但那将是另一个故事了。类似的例子有经典的以“如果冰的密度比水大”为主题的科幻小说，在这种反事实条件假定下，你不能指责科幻作家的假定存在问题，应该关注的是在这种假定下，作者所展现的世界是不是自洽，以及其展现达到了多深的层次。</p>
<p>【2】: 刘慈欣在新书《刘慈欣谈科幻》中透漏，他是一个科学主义者和技术崇拜者。其所架构的世界很多时候钢铁般坚硬和冷酷，缺少人性的关怀。个人认为这是一种缺点，但也是一种优点。</p>
<p>【3】: 此处参考吴国盛《技术哲学讲演录》，文中对技术哲学做了讲演式的概括介绍，人类的自我规训是其中一个重要内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘的七七八八。刚开始看《行尸走肉》时，还以为是个单纯的丧尸剧，但随着剧情的不断深入，发现它描述了更多的东西。在某些重要的方面，比如场景的设定上，是非常相似的。不过是一个把达尔文主义推广到整个宇宙，建立了]]>
    </summary>
    
      <category term="三体" scheme="http://starding.github.io/tags/%E4%B8%89%E4%BD%93/"/>
    
      <category term="社会达尔文主义" scheme="http://starding.github.io/tags/%E7%A4%BE%E4%BC%9A%E8%BE%BE%E5%B0%94%E6%96%87%E4%B8%BB%E4%B9%89/"/>
    
      <category term="行尸走肉" scheme="http://starding.github.io/tags/%E8%A1%8C%E5%B0%B8%E8%B5%B0%E8%82%89/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[科学史上的东方与西方]]></title>
    <link href="http://starding.github.io/2016/01/07/science-in-east-and-west/"/>
    <id>http://starding.github.io/2016/01/07/science-in-east-and-west/</id>
    <published>2016-01-07T07:48:31.000Z</published>
    <updated>2016-01-07T07:52:54.000Z</updated>
    <content type="html"><![CDATA[<p>此文是我在知乎的<a href="http://www.zhihu.com/question/21867922/answer/35898434" target="_blank" rel="external">第一个科学史答案</a></p>
<h1 id="u4E00_uFF1A_u79D1_u5B66_u53F2_u4E0A_u7684_u300E_u79D1_u5B66_u300F"><a href="#u4E00_uFF1A_u79D1_u5B66_u53F2_u4E0A_u7684_u300E_u79D1_u5B66_u300F" class="headerlink" title="一：科学史上的『科学』"></a>一：科学史上的『科学』</h1><p>科学史中所研究的科学范围，是超出我们日常生活中所提到的科学的，在科学史研究中，研究的是更广义意义上的科学，一般包括以下几种：</p>
<ol>
<li>古希腊的理性科学</li>
<li>近代科学革命产生的数理-实验科学</li>
<li>更为广泛意义上的博物学</li>
<li>更广泛的包括技术系统的科学</li>
</ol>
<p>题主所说的“西方科学史”的主线是：<br>古希腊——罗马——中世纪——文艺复兴——科学革命——现在。</p>
<p>以下叙述中的“科学”也是广义化的，但西方科学发展中的主线与支线，大家一看便知，一个非常重要的线索就是文明的类型与科学的类型这对关系。</p>
<h1 id="u4E8C_3A_u79D1_u5B66_u53F2_u4E0A_u7684_u4E1C_u65B9_u4E0E_u897F_u65B9"><a href="#u4E8C_3A_u79D1_u5B66_u53F2_u4E0A_u7684_u4E1C_u65B9_u4E0E_u897F_u65B9" class="headerlink" title="二:科学史上的东方与西方"></a>二:科学史上的东方与西方</h1><p>追溯到科学发展的源头去看，科学史上有两种比较典型的科学类型：东方的「实用型科学」与古希腊的「理性型科学」，而承载这两种科学类型的文明类型，也有两种类型：水利型文明和非水利型文明。</p>
<h2 id="u6C34_u5229_u578B_u6587_u660E_u4E0E_u5B9E_u7528_u578B_u79D1_u5B66_3A"><a href="#u6C34_u5229_u578B_u6587_u660E_u4E0E_u5B9E_u7528_u578B_u79D1_u5B66_3A" class="headerlink" title="水利型文明与实用型科学:"></a>水利型文明与实用型科学:</h2><p>代表是四大古文明，即两河流域的美索不达米亚文明，尼罗河流域的埃及文明，印度河恒河流域的印度文明，以及长江，黄河流域的中国文明。这几个文明都是近水而生，人们聚集在发达的水系旁边进行农业生产，当农业与人口都开始繁荣后，多余粮食的分配，水资源的分配，水利工程的建造和维护，排水，泄洪等都需要有组织的协作，而用水过程中出现的争执也需要权威来调节，这就应运而生了比较核心的管理组织，也就是集权政治的原型。在这种文明环境中，国家的正常运行，人民的生活是管理阶层首先要考虑的事，相应的，被管理阶层所把持的科学也偏向于实用，多集中于水利（农业灌溉必不可少），天文（农业生产，平时生活，预测王朝命运等都需要天文），医学。</p>
<h2 id="u975E_u6C34_u5229_u6587_u660E_u4E0E_u5E0C_u814A_u7406_u6027_u79D1_u5B66_uFF1A"><a href="#u975E_u6C34_u5229_u6587_u660E_u4E0E_u5E0C_u814A_u7406_u6027_u79D1_u5B66_uFF1A" class="headerlink" title="非水利文明与希腊理性科学："></a>非水利文明与希腊理性科学：</h2><p>希腊在地理位置上处于地中海沿岸，境内多山，没有大河，也没有大面积富饶的冲积平原，农业灌溉更加依靠雨水而不是与江河有关的水利，希腊人民靠本土条件难以为继，逐渐发展出了比较好的航海和商业。同时，希腊距离美索不达米亚和埃及这些文明不近也不远，便于交流而且不会被完全同化。另一方面，山脉把希腊的政治文明分割成多个小邦国，各个邦国之间形成合作竞争的关系。在此环境下，希腊人发展出了民主城邦制和奴隶制度，保证了闲暇阶层的出现，自由民主的环境也使得政治辩论成为常态，这都培养了希腊人的理性精神。希腊的闲暇阶层不同于东方的管理者，需要极力去维护一个集权大国的正常运行，而是更加注重于对政治合法性等这些内容进行思考。这些条件使得希腊成为科学史上的一朵奇葩，希腊人善于辩论，对事物有着一种寻根究底的热情，超越世俗的学术精神，比如希腊的天文学不同于东方的实用性天文学，它是一种数理行星天文学，是为了解释自然，而不是为了农业，占星等实用目的。用自然自身解释自然，不再求助于神等外物，从泰勒斯的“水是万物之源”，到柏拉图的“理念论”，再到亚里士多德的综合自然哲学，清晰的体现出理性科学出现的过程，这也是现代科学最古老的源头。</p>
<h1 id="u4E09_uFF1A_u4E24_u79CD_u79D1_u5B66_u7C7B_u578B_u7684_u53D1_u5C55"><a href="#u4E09_uFF1A_u4E24_u79CD_u79D1_u5B66_u7C7B_u578B_u7684_u53D1_u5C55" class="headerlink" title="三：两种科学类型的发展"></a>三：两种科学类型的发展</h1><h2 id="u5E0C_u814A_u7406_u6027_u79D1_u5B66_u7684_u7EE7_u627F_u53CA_u53D1_u5C55_uFF1A"><a href="#u5E0C_u814A_u7406_u6027_u79D1_u5B66_u7684_u7EE7_u627F_u53CA_u53D1_u5C55_uFF1A" class="headerlink" title="希腊理性科学的继承及发展："></a>希腊理性科学的继承及发展：</h2><p>希腊发展出了非功利的，比较系统的，有内在发展逻辑的理性科学传统，比如托勒密的《天文学大成》，欧几里得的《几何原本》，更为重要的是柏拉图和亚里士多德开创的理性的范式：柏拉图的理念论和亚氏自然哲学，他们虽然不同，但都是有内在逻辑的理性系统。希腊-罗马文明灭亡之后，这种理性融入到了基督教的教义之中，形成了前期的教父哲学和后期的经院哲学。希腊的文化同时被移植到伊斯兰世界中去，十字军东征之后，便开始在欧洲复兴，经历了航海时代，宗教改革，文艺复兴之后，希腊的这种理性科学的主线便在哥白尼身上连接了起来。紧接着就是近代的科学革命了。要注意的是，这个时候是十六十七世纪，资本主义对科学的发展有作用，但是还远没有到工业革命时的那么大的影响，在这中间主要的动力作用还理性科学内在的发展逻辑，宗教精神在其中也有不小的推动作用（宗教在近代科学产生过程中的作用，也是非常重要的，但讨论又需要大量篇幅了，答主题目中所说的“宗教的严格拘束”不太公平）。</p>
<h2 id="u4E1C_u65B9_u6C34_u5229_u6587_u660E_u5B9E_u7528_u578B_u79D1_u5B66_u7684_u53D1_u5C55_uFF1A"><a href="#u4E1C_u65B9_u6C34_u5229_u6587_u660E_u5B9E_u7528_u578B_u79D1_u5B66_u7684_u53D1_u5C55_uFF1A" class="headerlink" title="东方水利文明实用型科学的发展："></a>东方水利文明实用型科学的发展：</h2><p>实用型科学并没有它内在的发展逻辑，它的发展是根据外部环境的需要，一旦外部环境没有了需求时，它也就失去了发展的动力。这在中国历史上表现的非常明显，中国是非常典型的水利文明，集权的政治，官方掌控的科学都是其特点，这种由外部需求推动的科学与外部需要结合的非常紧密，长期来看就表现出科学技术发展的离散性，形不成系统。而且中国这种高度集权的国家，一旦形成了相应的治国文化后，这种文化对超越而无用的学术具有很强的限制作用（宗教还是文化，这是个问题）。中国在两千年的历史中，科学技术（取技术系统与博物学）其实一直都是非常强的，到了明代，达到了最高点。到了这个时候，外部的需求基本被满足，除非产生社会结构的变革（像资本主义与城市那样），或者是科学本身产生像希腊理性科学那样的结构，科学技术的发展就很难前进了。但是二者都是困难的，前者是封建势力不断扼杀资本主义的萌芽，后者是中国的政治文化已经固定，形成很强的束缚了。这个时候，也刚好是西方开始抓住希腊理性之线开始复兴的时候，从此中国在技术上也开始落后了。</p>
<h1 id="u56DB_uFF1A_u603B_u7ED3"><a href="#u56DB_uFF1A_u603B_u7ED3" class="headerlink" title="四：总结"></a>四：总结</h1><p>总之，以一种辉格史的角度来看的话，宏观上西方科学发展的逻辑还是比较清晰的，主线的就是希腊这根理性之线，旁支就是伊斯兰地区在中世纪时期对希腊学术的移植以及再移植，然而伊斯兰世界始终也是典型的东方文明，即使移植了希腊学术，对近代科学产生有着极其重要的影响，但最终也没能成功成为近代科学的策源地。</p>
<p>亚里士多德认为自由的学术有三个条件：</p>
<ol>
<li>闲暇的阶层</li>
<li>批判传统</li>
<li>对世界的惊异</li>
</ol>
<p>结合科学史可以看到，无论是古希腊，还是近代欧洲，都比较符合这些条件，而集权的国家则难以满足。注意这里没有强调“民主”，只是强调学术发展应有一个相对自由的环境，集权国家在脱去蒙昧之后，也是能创造出相似的条件的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>此文是我在知乎的<a href="http://www.zhihu.com/question/21867922/answer/35898434" target="_blank" rel="external">第一个科学史答案</a></p>
<h1 id="u4E00_uF]]>
    </summary>
    
      <category term="科学史" scheme="http://starding.github.io/tags/%E7%A7%91%E5%AD%A6%E5%8F%B2/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django中使用原生sql]]></title>
    <link href="http://starding.github.io/2016/01/07/raw-sql-in-django/"/>
    <id>http://starding.github.io/2016/01/07/raw-sql-in-django/</id>
    <published>2016-01-07T07:29:46.000Z</published>
    <updated>2016-01-08T11:33:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，django的orm只是sql的一个子集。也就是说很多使用sql能实现的功能，django orm是无法完成的，更不用说sql甚至是图灵完备的了。比如，直到1.8中，django才逐渐实现了case，when，if这些控制流。而这些内容在一些特殊类型的表操作中非常常见，比如说报表管理。</p>
<p>好在django提供了使用原生sql的接口，这样就能通过原生sql来实现一些复杂的功能。</p>
<h2 id="sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50"><a href="#sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="sql控制流之CASE WHEN一个例子"></a>sql控制流之CASE WHEN一个例子</h2><p>现有一张档案信息表archives：</p>
<p><img src="http://7xpxcb.com1.z0.glb.clouddn.com/starding48482-ddc55e26121f44aa.png" alt="mysql-demo"></p>
<p>字段说明：</p>
<ul>
<li>number 档案号</li>
<li>type 档案类型</li>
<li>status 档案状态</li>
<li>company 公司</li>
<li>branch_company 分公司</li>
</ul>
<p><strong>需求是计算出表中同一type，同一分公司下的档案总数，和status=01的档案数，以及它占档案总数的比值。</strong></p>
<p>当然，使用编程语言也可以实现这个功能，但是会比较复杂。这个时候可以使用case when语句来精确控制表中同一字段下，不同内容的选择。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> </span><br><span class="line">      <span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>) status_01,</span><br><span class="line">      <span class="keyword">COUNT</span>(*) total,</span><br><span class="line">      <span class="keyword">CONCAT</span>(<span class="keyword">FORMAT</span>(<span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>)/</span><br><span class="line">      <span class="keyword">COUNT</span>(*)*<span class="number">100</span>, <span class="number">2</span>), <span class="string">'%'</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      archives</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      <span class="keyword">status</span>, subbranch_company</span></span><br></pre></td></tr></table></figure>
<p>这样就可以解决上面提出的问题，因为这个表是临时杜撰的，结果这里就不贴了。</p>
<h2 id="u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2"><a href="#u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2" class="headerlink" title="在上述基础上实现链式查询"></a>在上述基础上实现链式查询</h2><p>在django的orm中，一个非常好用的功能就是使用链式查询，你可以不断连接filter等方法来过滤出想要的内容。</p>
<p>这在一些特定的场景中特别有用。比如在上面的表中，我有时候想要某个分公司或中支公司下的数据，有时候又想要单一类型下的数据。如果针对每一种条件组合分别写相应地sql查询的话，会非常复杂，而且有时候组合会特别多。而链式查询比较完美的解决了这个问题。<br>而为了让原生sql也能有个简单的链式查询，我们需要不断连接where中的条件子句。为此可以写一个简单的类来实现它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenQuerySQL</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, table)</span>:</span></span><br><span class="line">        self.table = table</span><br><span class="line">        self.group_by_fields = <span class="string">" "</span></span><br><span class="line">        self.where_conditions = <span class="string">" 1=1 "</span></span><br><span class="line">        self.fields = <span class="string">" "</span></span><br><span class="line">        self.order_by_fields = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">where</span><span class="params">(self, where_condition)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> where_condition:</span><br><span class="line">            self.where_conditions += <span class="string">" and "</span> + where_condition</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_field</span><span class="params">(self, fields)</span>:</span></span><br><span class="line">        self.fields += <span class="string">" "</span> + fields</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_by</span><span class="params">(self, group_by_field)</span>:</span></span><br><span class="line">        self.group_by_fields = group_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order_by</span><span class="params">(self, order_by_field)</span>:</span></span><br><span class="line">        self.order_by_fields = order_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sql</span><span class="params">(self)</span>:</span></span><br><span class="line">       SQL = <span class="string">'SELECT '</span> + self.fields + <span class="string">' FROM '</span> + self.table + <span class="string">' WHERE '</span> + self.where_conditions + <span class="string">' GROUP BY '</span> + self.group_by_fields + <span class="string">' ORDER BY '</span> + self.order_by_fields +  <span class="string">";"</span></span><br><span class="line">       <span class="keyword">return</span> SQL</span><br></pre></td></tr></table></figure>
<p>这个类可以简单的模拟链式查询的功能，可以这样使用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archive_statistics = GenQuerySQL(SOME_TABLE)</span><br><span class="line">raw_sql = archive_statistics.add_field(fields).where(where_condition).group_by(group_by_fields).order_by(order_by_fields).sql()</span><br></pre></td></tr></table></figure>
<p>其中.where可以多次连接。当然也可以使用另一种方式：先把where语句根据条件构造完毕，最终再拼接成sql语句。其思想是一样的：先过滤条件，最终再查询数据库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，dja]]>
    </summary>
    
      <category term="django" scheme="http://starding.github.io/tags/django/"/>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 部署gitlab]]></title>
    <link href="http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/"/>
    <id>http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/</id>
    <published>2016-01-07T07:27:22.000Z</published>
    <updated>2016-01-07T07:28:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="headerlink" title="拉取镜像及启动容器"></a>拉取镜像及启动容器</h1><p>参考：<a href="http://doc.gitlab.com/omnibus/docker/" target="_blank" rel="external">gitlab documentation</a></p>
<h2 id="u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A"><a href="#u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A" class="headerlink" title="首先使用dao加速器拉取daocker镜像："></a>首先使用dao加速器拉取daocker镜像：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<h1 id="u521B_u5EFAvolumes"><a href="#u521B_u5EFAvolumes" class="headerlink" title="创建volumes"></a>创建volumes</h1><p>简单来说volumes，就是可以映射到容器中去的容器外部存储空间。你可以将一些比价通用的配置文件，数据，或者是代码等都使用volumes的形式存储在容器所在的宿主机器上。这样不仅可以永久保留数据，保证数据的安全性。同时还可以方便的修改volumes中的内容，然后重新映射到容器中，这对于需要经常动态修改文件的容器非常有用。<br>在本次部署gitlab的时候，创建三个volumes，分别是/mnt/volumes/gitlab下的 config，logs，data目录。<br>启动一个gitlab容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \&#10;    --hostname git.xiaohuruwei.com \&#10;    --publish 8443:443 --publish 8080:80 --publish 2222:22 \&#10;    --name gitlab \&#10;    --restart always \&#10;    --volume /mnt/volumes/gitlab/config:/etc/gitlab \&#10;    --volume /mnt/volumes/gitlab/logs:/var/log/gitlab \&#10;    --volume /mnt/volumes/gitlab/data:/var/opt/gitlab \&#10;    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<p>命令参数解释：</p>
<p>–hostname<br>指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定git.xiaohuruwei.com</p>
<p>–publish<br>端口映射，冒号前面是宿主机端口，后面是容器expose出的端口</p>
<p>–volume<br>volume 映射，冒号前面是宿主机的一个文件路径，后面是容器中的文件路径</p>
<h1 id="u914D_u7F6Enginx_uFF0C_u652F_u6301https"><a href="#u914D_u7F6Enginx_uFF0C_u652F_u6301https" class="headerlink" title="配置nginx，支持https"></a>配置nginx，支持https</h1><p>参考：<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https" target="_blank" rel="external">gitlab set nginx</a><br>nginx 配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">rewrite</span><span class="regexp"> ^</span> <span class="url">https://git.xiaohuruwei.com</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="https_proxy"><a href="#https_proxy" class="headerlink" title="https proxy"></a>https proxy</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="title">server_name</span>  git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="comment"># ssl 证书配置，这里使用的是自己生成的证书，在访问时会提示证书问题，选择相信即可。</span></span><br><span class="line">    <span class="comment"># 如果想要公认的证书，需要在网络上的一些授权中心生成</span></span><br><span class="line">    <span class="title">ssl</span> <span class="built_in">on</span>;</span><br><span class="line">    <span class="title">ssl_certificate</span> /etc/nginx/ssl/getbase.crt;</span><br><span class="line">    <span class="title">ssl_certificate_key</span> /etc/nginx/ssl/getbase_nopass.key;</span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">https://localhost:8443</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u5F00_u653Egitlab_u7684https_u652F_u6301"><a href="#u5F00_u653Egitlab_u7684https_u652F_u6301" class="headerlink" title="开放gitlab的https支持"></a>开放gitlab的https支持</h1><p>仅仅由nginx反向代理https是不行的，因为还需要打开gitlab的https支持。</p>
<ul>
<li>修改配置文件，在/mnt/volumes/gitlab/config/ 目录下的gitlab.rb中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># note the &#39;https&#39; below&#10;external_url &#34;https://gitlab.example.com&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新建ssl目录，同时在该目录下添加ssl证书文件，命名要与上述域名中保持一致</p>
<p>git.xiaohuruwei.com.crt<br>git.xiaohuruwei.com.key</p>
</li>
<li><p>重新启动容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="u8BBF_u95EEgitlab_u6D4B_u8BD5"><a href="#u8BBF_u95EEgitlab_u6D4B_u8BD5" class="headerlink" title="访问gitlab测试"></a>访问gitlab测试</h1><ul>
<li>打开web界面，默认登录名为root，密码为5iveL!fe（已经改为厘米脚印的默认密码），新建一个project仓库:test</li>
<li><p>因为ssl证书是自己生成的，并不具有全网通用性，因此只能先选择相信证书。在本地设置环境变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GIT_SSL_NO_VERIFY=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后克隆仓库： git clone <a href="https://git.xiaohuruwei.com/root/test.git" target="_blank" rel="external">https://git.xiaohuruwei.com/root/test.git</a></p>
</li>
</ul>
<h1 id="u5F00_u542F_u90AE_u4EF6_u670D_u52A1"><a href="#u5F00_u542F_u90AE_u4EF6_u670D_u52A1" class="headerlink" title="开启邮件服务"></a>开启邮件服务</h1><p>默认的邮件服务不太好使，所以这里配置自己的邮件服务。参考官方<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md#examples" target="_blank" rel="external">gitlab stmp文档</a>。</p>
<p>使用163邮箱, 按照官方文档配置后，会发现发送邮件没有起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;smtp_enable&#39;] = true&#10;gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.163.com&#34;&#10;gitlab_rails[&#39;smtp_port&#39;] = 25&#10;gitlab_rails[&#39;smtp_user_name&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;gitlab_rails[&#39;smtp_password&#39;] = &#34;xxxx&#34;&#10;gitlab_rails[&#39;smtp_domain&#39;] = &#34;163.com&#34;&#10;gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;&#10;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true&#10;gitlab_rails[&#39;smtp_tls&#39;] = false&#10;gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;none&#39;</span><br></pre></td></tr></table></figure></p>
<p>查看log时，由于log比较杂乱，没有发现问题，后来在ruby社区发现有人解决过同样的问题：<br><a href="https://ruby-china.org/topics/20450" target="_blank" rel="external">GitLab 配置通过 smtp.163.com 发送邮件</a><br>以及网易的官方解释：<br><a href="http://www.mail163.cn/fault/analysis/1109.html" target="_blank" rel="external">网易服务器smtp机器要求身份验证帐号和发信帐号必须一致，如果用户在发送邮件时，身份验证帐号和发件人帐号是不同的，因此拒绝发送。</a><br>所以又添加了两行配置后测试可以正常使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;user[&#39;git_user_email&#39;] = &#34;xiaohuruwei@163.com&#34;</span><br></pre></td></tr></table></figure></p>
<h1 id="ssh_u65B9_u5F0F_u8BBF_u95EE"><a href="#ssh_u65B9_u5F0F_u8BBF_u95EE" class="headerlink" title="ssh方式访问"></a>ssh方式访问</h1><p>因为是使用docker部署的，通过ssh方式(比如git clone <a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>)访问会有两层认证:</p>
<ul>
<li>一层是freelancer服务器的认证</li>
<li>另一层是gitlab的认证。</li>
</ul>
<p>后者需要使用ssh-key<br>前者可能需要ssh本身的反向代理(现在使用的nginx不支持除http，https以外的反向代理)，</p>
<p>现在发现使用端口转发的形式比较困难，但是可以改变默认的gitlab的ssh端口为非标准端口：<br>直接修改gitlab配置文件中的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_shell_ssh_port = 2222</span><br></pre></td></tr></table></figure></p>
<p> 然后重新启动docker容器，就可以在web界面中看到相应的ssh地址发生了改变:<br>ssh://<a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>:2222/root/test.git  然后就直接可以继续使用git clone来继续操作了</p>
<h1 id="u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A"><a href="#u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A" class="headerlink" title="关于ssl证书参考："></a>关于ssl证书参考：</h1><p><a href="http://www.guokr.com/post/116169/" target="_blank" rel="external">https那些事，ssl证书</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="heade]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用daocloud持续集成应用]]></title>
    <link href="http://starding.github.io/2016/01/07/daocloud-deploy/"/>
    <id>http://starding.github.io/2016/01/07/daocloud-deploy/</id>
    <published>2016-01-07T07:24:25.000Z</published>
    <updated>2016-01-25T12:20:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762_u7684_u8BDD"><a href="#u5199_u5728_u524D_u9762_u7684_u8BDD" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>来自维基百科的：<a href="https://zh.wikipedia.org/wiki/货物崇拜编程" target="_blank" rel="external">货殖崇拜编程</a></p>
<p>为因GFW屏蔽访问不了维基百科的同学准备的：</p>
<blockquote>
<p>货物崇拜编程（Cargo Cult Programming）是一种计算机程序设计中的反模式，其特征为不明就里地、仪式性地使用代码或程序架构。货物崇拜编程通常是程序员既没理解他要解决的bug、也没理解表面上的解决方案的典型表现。</p>
<p>这个名词有时也指不熟练的或没经验的程序员从某处拷贝代码到另一处，却不太清楚其代码是如何工作的，或者不清楚在新的地方是否需要这段代码。也可以指不正确或过份的应用设计模式、代码风格或编程方法，却对其原理不明就里。</p>
<p>货物崇拜编程来源于“货物崇拜”这个词。其衍生词还有“货物崇拜软件工程”。</p>
</blockquote>
<p>在阅读任何教程类的文章时，都不要有编程上的货殖崇拜，有些内容是需要你根据自己的实际情况修改一些内容的,需要你理解它，如果不理解某些内容，就需要先熟悉一下相关的知识。</p>
<h1 id="daocloud_u4ECB_u7ECD"><a href="#daocloud_u4ECB_u7ECD" class="headerlink" title="daocloud介绍"></a>daocloud介绍</h1><p>  <a href="https://daocloud.io" target="_blank" rel="external">daocloud</a>提供基于docker进行持续集成的服务，使用它可以很方便的完成项目的自动化构建以及持续发布等功能。</p>
<p>当然，如果要使用daocloud持续化集成应用，首先你需要注册一个daocloud账号。如果你效力于某个公司的话，还要通知该公司把你的账号拉到公司用户组里，这样才能使用该公司的资源。</p>
<h1 id="u6301_u7EED_u96C6_u6210_u7B80_u5355_u7684html5_u5E94_u7528"><a href="#u6301_u7EED_u96C6_u6210_u7B80_u5355_u7684html5_u5E94_u7528" class="headerlink" title="持续集成简单的html5应用"></a>持续集成简单的html5应用</h1><h2 id="u672C_u5C0F_u8282_u4F7F_u7528_u573A_u666F"><a href="#u672C_u5C0F_u8282_u4F7F_u7528_u573A_u666F" class="headerlink" title="本小节使用场景"></a>本小节使用场景</h2><ul>
<li>拥有自己的主机</li>
<li>将主机添加到了daocloud上</li>
<li>只使用daocloud的自动构建和部署功能</li>
<li>镜像也要部署到自己的主机上。</li>
</ul>
<h2 id="u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D"><a href="#u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D" class="headerlink" title="什么是「简单的html5应用」"></a>什么是「简单的html5应用」</h2><p>只有前端页面，并且使用nginx提供服务。</p>
<h2 id="u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848"><a href="#u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848" class="headerlink" title="部署大致解决方案"></a>部署大致解决方案</h2><p>本文假设一个使用场景：拥有自己的主机，并且绑定到了daocloud上，然后想通过daocloud进行持续化地部署到自己的主机上。如果想要部署一个纯前端项目，需要把nginx集成进去，然后使用nginx来提供服务。</p>
<h2 id="u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907"><a href="#u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907" class="headerlink" title="构建应用前的准备"></a>构建应用前的准备</h2><h3 id="u5E94_u7528_u76EE_u5F55_u7ED3_u6784"><a href="#u5E94_u7528_u76EE_u5F55_u7ED3_u6784" class="headerlink" title="应用目录结构"></a>应用目录结构</h3><p>因为daocloud是基于daocker的，在使用daocloud之前，我们需要按照docker的规范，把自己的项目改成支持打包成镜像的应用，对于html5项目来说，就是添加Dockerfile文件和配置好所需要的nginx配置文件。比如我有一个应用叫jinli，其目录结构为(你的目录结构和这个可能也不一样)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinli/  # &#39033;&#30446;&#26681;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; jinli/  # &#20855;&#20307;&#30340;&#24212;&#29992;&#30446;&#24405;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; images/ # &#22270;&#29255;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.html  # &#40664;&#35748;&#30340;&#26816;&#32034;html&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; scripts/  #  js&#25991;&#20214;&#22841;&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; styles/    # &#23384;&#25918;css&#30340;&#25991;&#20214;&#22841;&#10;&#9500;&#9472;&#9472; Dockerfile   # Dockerfile&#10;&#9500;&#9472;&#9472; jinli.conf   # &#26412;&#24212;&#29992;&#30340;nginx&#37197;&#32622;&#25991;&#20214;&#10;&#9492;&#9472;&#9472; log/  # log&#25991;&#20214;</span><br></pre></td></tr></table></figure>
<p>在这个目录结构中，和docker镜像构建是就是Dockerfile这个文件，jinli.conf是个将要一起打包放入docker镜像中的文件，其他的都是应用本身的文件。</p>
<h3 id="u521B_u5EFADockerfile_u6587_u4EF6"><a href="#u521B_u5EFADockerfile_u6587_u4EF6" class="headerlink" title="创建Dockerfile文件"></a>创建Dockerfile文件</h3><p><strong>Dockerfile</strong>，就是一个daocker的规则文件，就像make的Makefile一样。Dockerfile描述了将自己的应用构建成docker镜像的过程。<br>在本例中，Dockerfile的内容如下：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择nginx服务</span></span><br><span class="line"><span class="built_in">FROM</span> nginx:<span class="number">1.9</span>.<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy代码</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">. /src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 添加nginx配置文件</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">jinli.conf /etc/nginx/conf.d/</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 去掉默认的nginx配置文件</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">rm /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile解释：</p>
<ul>
<li>首先，想象将要构建的docker镜像包含一个linux操作系统。</li>
<li><code>FROM nginx:1.9.5</code> 的意思就是，将1.9.5版本的nginx服务集成到自己的镜像中（其实操作系统就是在这一步引入的，nginx本身也是一个镜像，它是建立在一个linux操作系统之上的，拉取nginx的时候，会连把nginx连带其附着的linx系统整个一起拉下来）。</li>
<li><code>COPY . /src</code> 的意思是将当前目录下的代码复制到镜像中（的操作系统中）的 /src目录下</li>
<li><code>COPY jinli.conf /etc/nginx/conf.d/</code> 的意思是，将当前目录下写好的nginx配置文件，复制到镜像（的操作系统）中的相应目录下。</li>
<li>删掉原来默认的nginx配置（因为默认配置文件会占用掉localhost，不知道有没有更好的解决办法）</li>
</ul>
<h3 id="u914D_u7F6E_u5728docker_u4E2D_u4F7F_u7528_u7684nginx_u914D_u7F6E_u6587_u4EF6_u3002"><a href="#u914D_u7F6E_u5728docker_u4E2D_u4F7F_u7528_u7684nginx_u914D_u7F6E_u6587_u4EF6_u3002" class="headerlink" title="配置在docker中使用的nginx配置文件。"></a>配置在docker中使用的nginx配置文件。</h3><p>本示例中，nginx配置文件命名为jinli.conf。把它打包到镜像中，来给html5应用提供服务，这与平时直接在服务器上部署没有什么很大的差别，需要注意的就是：</p>
<ul>
<li>server_name 为 localhost，因为这个server_name是在docker容器内部使用的。</li>
<li>location 中的root文件夹是docker容器中的地址，不是宿主机的地址</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> localhost;</span><br><span class="line">    <span class="title">access_log</span> /src/log/jinli.access.log;</span><br><span class="line">    <span class="title">error_log</span> /src/log/jinli.<span class="built_in">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里你还可以选择根据需要配一些gzip等选项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">    <span class="title">root</span> /src/jinli/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将应用提交到github上，比如具体为：xiaohuruwei/jinli.git</p>
<p>以上已经包含全部必须的材料了，下面进入daocloud环节。</p>
<h2 id="u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03"><a href="#u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03" class="headerlink" title="使用daocloud进行持续构建镜像以及发布"></a>使用daocloud进行持续构建镜像以及发布</h2><p>因为前面的步骤已经构建好了一个支持docker的代码版本，而且不需要外联像mysql这样的外部服务，因此可以直接将其当做一个单应用的镜像来构建。</p>
<p>在这方面，daocloud已经有了完善的<a href="http://docs.daocloud.io/" target="_blank" rel="external">文档</a>，可以直接参考其中的创建新项目章节，以及持续集成章节。</p>
<ul>
<li>第四节<a href="http://docs.daocloud.io/ci-on-daocloud" target="_blank" rel="external">创建新项目</a>，根据具体情况选择要绑定需要的git源</li>
<li>第五节<a href="http://docs.daocloud.io/ci-image-build" target="_blank" rel="external">持续集成和镜像构建</a>,在简单的html部署中，不需要了解daocloud.yml的写法</li>
<li>第九节中的<a href="http://docs.daocloud.io/app-deploy-mgmt/deploy-to-cluster" target="_blank" rel="external">向自由主机集群上发布应用</a></li>
</ul>
<p>在上面的过程中，核心部分如下：</p>
<ul>
<li>绑定git源</li>
<li>选择要部署的git仓库，并构建成镜像</li>
<li>部署到<strong>自有主机</strong>上</li>
<li>将后续自动持续部署的设置打开<ul>
<li>在「代码构建」具体项目的「设置」中，将持续集成打开，设置好镜像和持续集成的触发规则，比如：在向docker-support分支提交代码时，就触发自动持续集成。</li>
<li>在「应用列表」中的「发布」设置中，将自动发布打开。</li>
</ul>
</li>
</ul>
<h2 id="u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C"><a href="#u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C" class="headerlink" title="发布完成之后需要做的工作"></a>发布完成之后需要做的工作</h2><p>发布完成之后，可以在daocloud上看到所创建的容器的具体信息。包括映射到宿主机上的端口号等等，点击端口号后可以看到该应用的访问地址，打开可以测试是否部署成功了</p>
<p>为方便后面的叙述，这里假设映射出的端口号为8888。因为是发布到自己的主机上，所以还需要自己配置域名以及nginx反向代理来对外提供访问服务。假设有一个域名已经绑定在了自己的主机上，这里假设为xiaohuruwei.com.</p>
<p>登陆自己的主机，并配置nginx文件，如果是使用apt-get一类的包管理工具安装的，那么应该是在/etc/nginx/conf.d/目录下添加 jinli.conf:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/jinli.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/jinli.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以根据需要设置其他配置项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">http://127.0.0.1:8888</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问xiaohuruwei.com就可以看到内容了</p>
<p>另外，需要在使用daocloud的时候，将自动构建和持续发布都打开，这样下次使用时，只需要往github推代码时，触发了你设定的更新规则，就会持续构建镜像并发布了。</p>
<hr>
<h1 id="u6301_u7EED_u96C6_u6210_u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528"><a href="#u6301_u7EED_u96C6_u6210_u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528" class="headerlink" title="持续集成依赖外部服务的应用"></a>持续集成依赖外部服务的应用</h1><p>以django应用为例</p>
<h2 id="u672C_u6587_u9002_u7528_u7684_u573A_u666F"><a href="#u672C_u6587_u9002_u7528_u7684_u573A_u666F" class="headerlink" title="本文适用的场景"></a>本文适用的场景</h2><ul>
<li>拥有自己的主机</li>
<li>将主机添加到了daocloud上</li>
<li>只使用daocloud的自动构建和部署功能</li>
<li><strong>所依赖的外部服务已经（以daocke容器）存在于自己的主机上</strong>，镜像也要部署在自己的主机上。在部署的同时连接主机上已经存在的外部服务（如mysql，redis等）。</li>
</ul>
<h2 id="u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528"><a href="#u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528" class="headerlink" title="依赖外部服务的应用"></a>依赖外部服务的应用</h2><p>在docker领域中，如果一个docker镜像自身需要其他镜像来提供服务，就说这个镜像是带外部服务的。</p>
<p>以一个简单的django应用为例，如果这个django应用自身无法完成任务，而需要mysql或者其他数据库作为数据的持久化服务，那么这个django应用就是依赖外部服务的。</p>
<h2 id="u6784_u5EFA_u524D_u7684_u51C6_u5907"><a href="#u6784_u5EFA_u524D_u7684_u51C6_u5907" class="headerlink" title="构建前的准备"></a>构建前的准备</h2><p>准备同html5接近，因为需要连接外部服务，而且因为uwsig服务默认不支持静态文件的处理，所以多了一些对原代码的改造。</p>
<h3 id="u9879_u76EE_u7ED3_u6784"><a href="#u9879_u76EE_u7ED3_u6784" class="headerlink" title="项目结构"></a>项目结构</h3><p>首先是django应用的目录，比如有一个应用叫taikang，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taikang&#9;# &#39033;&#30446;&#26681;&#30446;&#24405;&#9;&#10;&#9500;&#9472;&#9472; Dockerfile&#9;# Dockerfile&#25991;&#20214;&#10;&#9500;&#9472;&#9472; logs&#9;&#10;&#9500;&#9472;&#9472; manage.py&#10;&#9500;&#9472;&#9472; Makefile&#9;# makefile&#25991;&#20214;&#10;&#9500;&#9472;&#9472; requirements.txt&#9;# &#24212;&#29992;&#20381;&#36182;&#30340;python&#24211;&#10;&#9500;&#9472;&#9472; templates&#10;&#9492;&#9472;&#9472; taikang&#9;&#9;# &#24212;&#29992;&#30446;&#24405;&#10;&#9;&#9500;&#9472;&#9472; __init__.py&#10;&#9;&#9500;&#9472;&#9472; models.py&#10;&#9;&#9500;&#9472;&#9472; settings.py   # django&#30340;&#37197;&#32622;&#25991;&#20214;&#10;&#9;&#9500;&#9472;&#9472; urls.py&#10;&#9;&#9500;&#9472;&#9472; views.py&#10;&#9;&#9492;&#9472;&#9472; wsgi.py</span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile_u6587_u4EF6_u7F16_u5199"><a href="#Dockerfile_u6587_u4EF6_u7F16_u5199" class="headerlink" title="Dockerfile文件编写"></a>Dockerfile文件编写</h3><p>Dockerfile文件的含义和html5部署中是完全相同的，这里为：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用python2.7.10版本作为基础服务</span></span><br><span class="line"><span class="built_in">from</span> python:<span class="number">2.7</span>.<span class="number">10</span></span><br><span class="line"></span><br><span class="line">将当前项目中的内容全<span class="built_ins">copy</span>到镜像中的 /src 目录下</span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">. /src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 安装django应用依赖的库，这里设置为豆瓣的pypi源</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash"><span class="built_in">cd</span> /src; pip install -r  requirements.txt -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 镜像暴露出8000端口</span></span><br><span class="line"><span class="built_in">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录为代码所在目录</span></span><br><span class="line"><span class="built_in">WORKDIR</span>  <span class="bash">/src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 设置应用启动命令</span></span><br><span class="line"><span class="built_in">CMD</span> <span class="bash">[<span class="string">"make"</span>, <span class="string">"start-uwsgi"</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Makefile_u6587_u4EF6_u7F16_u5199"><a href="#Makefile_u6587_u4EF6_u7F16_u5199" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h3><p>可以注意到，上述最后的启动命令中使用了make命令，这也是前面目录结构中Makefile文件的作用所在。有关makefile的知识，这里不再详述.<br>总之可以让你更方便的管理应用，这里直接贴出makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uwsig启动的host和端口 </span></span><br><span class="line"><span class="constant">host</span>:=0.0.0.0</span><br><span class="line"><span class="constant">port</span>:=8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug的时候直接使用django自带的服务启动</span></span><br><span class="line"><span class="title">debug:</span></span><br><span class="line">    ./manage.py runserver $(host):$(port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动uwsgi服务</span></span><br><span class="line">start-uwsgi:</span><br><span class="line">    uwsgi --socket $(host):$(port) \</span><br><span class="line">        --chdir $(shell pwd) \</span><br><span class="line">        --wsgi-file taikang/wsgi.py \</span><br><span class="line">        --master \</span><br><span class="line">        --process 4 \</span><br><span class="line">        --pidfile $(shell pwd)/uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止uwsgi服务</span></span><br><span class="line">stop-uwsgi:</span><br><span class="line">    uwsgi --stop uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载uwsgi服务</span></span><br><span class="line">reload-uwsgi:</span><br><span class="line">    uwsgi --reload uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集静态文件</span></span><br><span class="line"><span class="title">collectstatic:</span></span><br><span class="line">    ./manage.py collectstatic --noinput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="phony"><span class="keyword">.PHONY</span>: debug \</span></span><br><span class="line">    collectstatic \</span><br><span class="line">    reload-uwsgi \</span><br><span class="line">    start-uwsgi \</span><br><span class="line">    stop-uwsgi</span><br></pre></td></tr></table></figure>
<h3 id="u9759_u6001_u6587_u4EF6_u652F_u6301"><a href="#u9759_u6001_u6587_u4EF6_u652F_u6301" class="headerlink" title="静态文件支持"></a>静态文件支持</h3><p>在uwsgi提供服务时，静态文件需要单独进行处理，目前推荐使用django的<a href="https://github.com/evansd/whitenoise" target="_blank" rel="external">whitenoise库</a> 。可以方便的提供静态文件服务，仅仅需要几行配置。</p>
<h3 id="u901A_u8FC7_u73AF_u5883_u53D8_u91CF_u6765_u8FDE_u63A5_u670D_u52A1"><a href="#u901A_u8FC7_u73AF_u5883_u53D8_u91CF_u6765_u8FDE_u63A5_u670D_u52A1" class="headerlink" title="通过环境变量来连接服务"></a>通过环境变量来连接服务</h3><p>在使用docker部署项目，当需要连接外部的服务时，一般通过link + 环境变量的参数进行。而为了支持环境变量的形式，我们的django应用也要做一些相应的改变。具体就是修改settings.py中的配置。</p>
<p>修改settings.py文件，以mysql为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原来的mysql配置文件</span></span><br><span class="line"><span class="comment">#DATABASES = &#123;</span></span><br><span class="line"><span class="comment">#    'default': &#123;</span></span><br><span class="line"><span class="comment">#        'ENGINE': 'django.db.backends.mysql',</span></span><br><span class="line"><span class="comment">#        'NAME': 'starding_taikang',</span></span><br><span class="line"><span class="comment">#        'USER': 'root',</span></span><br><span class="line"><span class="comment">#        'PASSWORD': 'your_password_here',</span></span><br><span class="line"><span class="comment">#        'HOST': 'localhost',</span></span><br><span class="line"><span class="comment">#        'PORT': '3306'</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过获取环境变量的形式来获取服务</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 导入os库</span></span><br><span class="line">mysql_name = os.environ.get(<span class="string">'MYSQL_INSTANCE_NAME'</span>) <span class="keyword">or</span> <span class="string">"taikang"</span>  <span class="comment"># 获取数据库名称</span></span><br><span class="line">mysql_user = os.environ.get(<span class="string">'MYSQL_USERNAME'</span>) <span class="keyword">or</span> <span class="string">"root"</span>  <span class="comment"># 获取mysql用户名</span></span><br><span class="line">mysql_password = os.environ.get(<span class="string">'MYSQL_PASSWORD'</span>) <span class="keyword">or</span> <span class="string">"your_password"</span>  <span class="comment"># 获取密码</span></span><br><span class="line">mysql_host = os.environ.get(<span class="string">'MYSQL_ADDR'</span>) <span class="keyword">or</span> <span class="string">"127.0.0.1"</span>  <span class="comment"># 获取服务地址</span></span><br><span class="line">mysql_port = <span class="string">"3306"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用上面的变量代替字符串</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">'default'</span>: &#123;</span><br><span class="line">       <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">       <span class="string">'NAME'</span>: mysql_name,</span><br><span class="line">       <span class="string">'USER'</span>: mysql_user,</span><br><span class="line">       <span class="string">'PASSWORD'</span>: mysql_password,</span><br><span class="line">       <span class="string">'HOST'</span>: mysql_host,</span><br><span class="line">       <span class="string">'PORT'</span>: mysql_port</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528daocloud_u90E8_u7F72_u6784_u5EFA_u597D_u7684taikang_u9879_u76EE"><a href="#u4F7F_u7528daocloud_u90E8_u7F72_u6784_u5EFA_u597D_u7684taikang_u9879_u76EE" class="headerlink" title="使用daocloud部署构建好的taikang项目"></a>使用daocloud部署构建好的taikang项目</h2><p>步骤基本同html5部署，假设你完成镜像构建之后，产生的镜像地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daocloud.io/xiaohuruwei/taking:latest</span><br></pre></td></tr></table></figure>
<p>下一步在使用镜像部署的时候，需要连接外部服务，具体是手动编辑yaml文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">takang_test:&#10;  image: daocloud.io/xiaohuruwei/taking:latest&#10;  restart: always&#10;  external_links:&#10;  - mysql1:mysql&#9;  # &#21069;&#38754;&#30340;mysql1&#26159;&#20320;&#20027;&#26426;&#19978;&#24050;&#32463;&#23384;&#22312;&#30340;mysql&#30340;&#23481;&#22120;&#23454;&#20363;&#65292;&#20882;&#21495;&#21518;&#38754;&#26159;&#21035;&#21517;&#10;  ports:&#10;  - &#39;8000&#39;&#10;  environment:    # &#29615;&#22659;&#21464;&#37327;    &#10;  - MYSQL_ADDR=mysql</span><br></pre></td></tr></table></figure>
<p>但是我发现这种方法似乎有一些bug，如果上面的方法不成功，那么你就先直接部署，部署成功之后，再去修改yaml文件成为上面描述的样子。在修改yaml文件的时候，daocloud会提示重新部署，选择确定即可。</p>
<p>至此，django项目也部署完成了。然后同html5项目部署一样，把各种自动构建，自动发布的功能打开就行了。</p>
<p><strong>注意：</strong> 由于django项目是使用uwsgi部署的，直接访问daocloud给出的地址是错误的，这个时候必须配置nginx反向代理。</p>
<p>附上uwsgi部署的django nginx代理配置文件：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/taikang.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/taikang.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title">gzip</span> <span class="built_in">on</span>;</span><br><span class="line">    <span class="title">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="title">gzip_buffers</span> <span class="number">16</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="title">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="title">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">    <span class="title">gzip_types</span> text/plain application/x-javascript text/javascript text/css application/xml;</span><br><span class="line">    <span class="title">gzip_vary</span> <span class="built_in">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title">include</span> uwsgi_params;</span><br><span class="line">        <span class="title">uwsgi_pass</span> <span class="number">127.0.0.1:32801</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762_u7684_u8BDD"><a href="#u5199_u5728_u524D_u9762_u7684_u8BDD" class="headerlink" title="写在前面的话"></a>写在前面的话</h1]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
</feed>
