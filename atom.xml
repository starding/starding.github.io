<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>结绳以渔</title>
  <icon>http://starding.github.io/white_logo_yao.png</icon>
  <subtitle>临渊羡鱼，不如退而结网</subtitle>
  <link href="http://starding.github.io/atom.xml" rel="self"/>
  
  <link href="http://starding.github.io/"/>
  <updated>2024-02-24T07:02:43.652Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name>XingHua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>html5 设计原理</title>
    <link href="http://starding.github.io/2016/03/19/html5-design-principle/"/>
    <id>http://starding.github.io/2016/03/19/html5-design-principle/</id>
    <published>2016-03-19T02:30:47.000Z</published>
    <updated>2024-02-24T07:02:43.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之所以取个这么大的标题，是因为这是一篇翻译稿的标题。个人认为这篇演讲的翻译稿非常符合我的思维习惯，而且网上没有一个比较好的版本，故单读整理出来，形成一篇转载文章。</p><p>前一段时间，我们小组一直有一个争论，就是在 api 中到底是使用 utc 时间，还是使用 unix 时间戳。个人坚持的观点就是「先为人设计，再为机器设计」，赞同语义化更强的 utc 时间。</p><p>上面的例子是想说明，有时候我们做出一件决策，不能仅仅根据根据一时的想法，想当然的认为某些事情应该怎样，而应该遵循一些明显经过时间检验的设计原则行事。尤其是遇到一些两难的选择时，遵循一些这个领域的原则，可能会带来意象不到的好处。</p><p>同样，我们在关注一件新事物，比如 html5 时（其实不算新了），不能只是看它出现了那些新元素，新 api 等等。而是应该考虑这背后的一些设计理念以及发展历程，它解决了什么痛点，如此我们才能更好的把握这些事物从哪里来，未来会怎样等问题的脉络。</p><br/><hr><h2 id="HTML5-设计原理"><a href="#HTML5-设计原理" class="headerlink" title="HTML5 设计原理"></a>HTML5 设计原理</h2><p>2010 年 10 月 21 日</p><p><a href="http://www.cn-cuckoo.com/category/web">Web 开发翻译</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="不清楚博主的这篇翻译文章为什么没了，但原翻译者应该是他没错，这里只进行一下整理">[1]</span></a></sup></p><p><a href="http://adactio.com/articles/1704/">Jeremy Keith 在 Fronteers 2010 上的主题演讲</a></p><p>今天我想跟大家谈一谈 HTML5 的设计。主要分两个方面：一方面，当然了，就是 HTML5。我可以站在这儿只讲 HTML5，但我并不打算这样做，因为如果你想了解 HTML5 的话，你可以 Google，可以看书，甚至可以看规范。</p><p>实际上，确实有人会谈到规范的内容。史蒂夫·福克纳（Steve Faulkner）会讲 HTML5 与可访问性。而保罗·艾里什（Paul Irish）则会讲 HTML5 提供的各种 API。因此，我今天站在这里，不会光讲一讲 HTML5 就算完事了。</p><p>说老实话，在正式开始之前，我想先交待清楚我所说的 HTML5 到底是什么意思。这话听起来有点搞笑：这会子你一直在说 HTML5，难道我们还不知道什么是 HTML5 吗？大家知道，有一个规范，它的名字叫 HTML5。我所说的 HTML5，指的就是这个规范。但问题是，有些人所说的 HTML5，指的不仅仅是这个规范，还有别的意思。比如说，用 HTML5 来代指 CSS3 就是一种常见的叫法。我可不是这样的。我所说的 HTML5，不包含 CSS3，就是 HTML5。</p><p>类似的术语问题以前也有过。Ajax 本来是一种含义明确的技术，但过了不久，它的含义就变成了“用 JavaScript 来做一切好玩的东西”。这就是 Ajax，对不对？今天，HTML5 也面临同样的问题，它本来指的是一个特定的规范，但如今含义却成了“在 Web 上做一切好玩的事。”我说的不是这种 HTML5，不是这种涵盖了最近刚刚出现的各种新东东的 HTML5。我说的仅仅是规范本身：HTML5。</p><p>刚才已经说了，我今天想要讲的内容不多，也没有打算介绍 HTML5 都包含什么。今天我要讲的是它的另一方面，即 HTML5 的设计。换句话说，我要讲的不是规范里都包含什么，而是规范里为什么会包含它们，以及在设计这个规范的时候，设计者们是怎么看待这些东西的。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>设计原理本质上是一种信念、一种想法、一个概念，是你行动的支柱。不管你是制定规范，还是制造一种有形的物品，或者编写软件，甚至发明编程语言。你都能找到背后的一个或者多个设计原理，多人协作的任何成果都是例证。不仅仅 Web 开发领域是这样。纵观人类历史，像国家和社会这样大规模的构建活动背后，同样也有设计原理。</p><p>就拿美国为例吧，美国的设计原理都写在了《独立宣言》中了。</p><blockquote><p>我们认为这些真理是不言而喻的，人人生而平等，造物主赋予了每个人不可剥夺的权利，包括生存、自由和追求幸福。</p></blockquote><p>这里有一句口号：生存、自由和追求幸福。这是被写进宪法中的核心理念，它关系到我们所有人的一切，也就是我们构建自己社会的原则。</p><p>还有一个例子，就是卡尔·马克思（Karl Marx），他的著作在 20 世纪曾被奉为建设社会主义的圭臬。其基本思想大致可以归结为下面这条设计原理：</p><blockquote><p>各尽所能，各取所需。</p></blockquote><p>这其实就是一种经济体系背后的设计原理。</p><p>还有一个例子，比前面两个的历史更久远一些，不过大同小异：</p><blockquote><p>人人为我，我为人人。</p></blockquote><p>这个极为简单的设计原理，是两千年前的拿撒勒犹太人耶稣基督提出来的。而这条原则成为了后来许多宗教的核心教义。原理与实践有时候并不是同步的。</p><p>下面是小说中的一个例子。英国小说家乔治·奥威尔（George Orwell）笔下的《动物庄园》，就是在一条设计原理的基础上构建起来的虚拟社会。这条设计原理是：</p><blockquote><p>四条腿的都是好人，两条腿的都是坏蛋！</p></blockquote><p>《动物庄园》中有意思的是，随着社会的变迁——变得越来越坏，这条设计原理也跟着发生了改变，变成了“四条腿的都是好人，两条腿的就更好了。”最关键的是，即使是在虚构的作品里，设计原理都是存在的。</p><p>还有一套虚构的作品是以三条设计原理为基础构建起来的，那就是美国著名小说家艾萨克·阿西莫夫（Issac Asimov）的机器人经典系列。阿西莫夫发明了机器人学这个术语，并提出了机器人学三大法则，然后在这三个简单的设计原理基础上创作了一系列经典作品——大约有 50 本书。无论作品的情节如何变化，实际上都是从不同的角度来阐释这三大设计原理。我想，在座各位对机器人三大法则都不应该陌生。</p><blockquote><p>机器人不得伤害人类，或袖手旁观人类受伤害。<br>机器人必须服从人类命令，除非命令违反第一法则。<br>机器人必须自卫，只要不违背第一和第二法则。</p></blockquote><p>这些恐怕是第一次出现在小说中的针对软件的设计原理了。虽然基于这三个设计原理的软件运行在虚构的机器人的“正电子脑”中，但我想这应该是软件设计原理的事实开端。从此以后，我们才看到大量优秀软件背后的设计原理。</p><p>蒂姆·伯纳斯 - 李（Tim Berners-Lee），Web 的发明者，在 W3C 的网站上发表过一份文档，其中有一个 URL 给出了他自己的一套设计原理。这些设计原理并不那么容易理解，不仅多，而且随着时时间推移，他还会不断补充、修改和删除。不过我还是觉得把自己认同的设计原理写出来放在某个地方真是个不错的主意。</p><p>实际上，CSS 的发明人之一伯特·波斯（Bert Bos），也在 W3C 的网站上放着一份文档，其中讲的都是基本的设计原理，比如怎样设计并构建一种格式，无论是 CSS 还是其他格式。推荐大家看一看。</p><p>只要你在 W3C 的站点中随便找一找，就可以发现非常多的这种设计原理，包括蒂姆·伯纳斯 - 李个人的。当然，你还会看到他从软件工程学校里借用的一些口号：分权（decentalisation）、容忍（tolerance）、简易（simplicity）、模块化（modularity）。这些都是在他发明新格式的时候，头脑中无时无刻不在想的那些关键词。</p><p>在座各位对蒂姆·伯纳斯 - 李的贡献都是非常熟悉的，因为大家每天都在用。他发明了 Web，与罗伯特·卡里奥（Robert Cailliau）共同发明了 Web，而且在发明 Web 的同时，也发明了我们每天都在 Web 上使用的语言。当然，这门语言就是 HTML：超文本标记语言。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 最早是从 2.0 版开始的。从来就没有 1.0 版。如果有人告诉你说，他最早是从 HTML 1.0 开始使用 HTML 的，那他绝对是在忽悠你。从前确实有一个名叫 HTML Tags 的文档，其中的部分标签一直用到现在，但那个文档并非官方的规范。</p><p>使用标签、尖括号、p 或 h1，等等，并不是蒂姆·伯纳斯 - 李首创的想法。当时的 SGML 里就有了这些概念，而且当时的 CERN（Conseil Europeen pour la Recherche Nucleaire，欧洲核子研究委员会）也在使用 SGML 的一个特定的版本。也就是说，即便在那个时代，他也没有白手起家；这一点在 HTML 后来的发展过程中也体现了出来：继往开来、承前启后，而不是另立门户、从头开始。</p><p>换句话说，这篇名为 HTML Tags 的文档可以算作 HTML 的第一个版本，但它却不是一个正式的版本。第一个正式版本，HTML 2.0，也不是出自 W3C 之手。HTML 2.0 是由 IETF，因特网工程任务组（Internet Engineering Task Force）制定的。在 W3C 成立之前，IETF 已经发布了不少标准。但从第三个版本开始往后，W3C，万维网联盟（World Wide Web Consortium）开始接手，并负责后续版本的制定工作。</p><p>20 世纪九十年代 HTML 有过几次快速的发展。众所周知，在那个时代要想构建网站，可是一项十分复杂的工程。浏览器大战曾令人头疼不已。市场竞争的结果就是各家浏览器里都塞满了各种专有的特性，都试图在专有特性上胜人一筹。当时的混乱程度不堪回首，HTML 到底还重不重要，或者它作为 Web 格式的前景如何，谁都说不清楚。</p><p>从 1997 年到 1999 年，HTML 的版本从 3.2 到 4.0 到 4.01，经历了非常快的发展。问题是到了 4.01 的时候，W3C 的认识发生了倒退，他们说“好了，这个版本就这样了，HTML 也就这样了；HTML 4.01 是 HTML 的最后一个版本了，我们用不着 HTML 工作组了。”</p><p>W3C 并没有停止开发这门语言，只不过他们对 HTML 不再感兴趣了。在 HTML 4.01 之后，他们提出了 XHTML 1.0。虽然听起来完全不同，但 XHTML 1.0 与 HTML 4.01 其实是一样的。我的意思是说，从字面上看这两个规范的内容是一样的，词汇表是一样的，所有的元素是一样，所有的属性也都是一样的。唯一一点不同之处，就是 XHTML 1.0 要求使用 XML 语法。也就是说，所有属性都必须使用小写字母，所有元素也必须使用小写字母，所有属性值都必须加引号，你还得记着使用结束标签，记着对 img 和 br 要使用自结束标签。</p><p>从规范本身的内容来看，实际上是相同的，没有什么不同。不同之处就是编码风格，因为对浏览器来说，读取符合 HTML 4.01、HTML 3.2，或者 XHTML 1.0 规范的网页都没有问题，对浏览器来说这些网页都是一样的，都会生成相同的 DOM 树。只不过人们会比较喜欢 XHTML 1.0，因为不少人认同它比较严格的编码风格。</p><p>到了 2000 年，Web 标准项目（Web Standards Project）的活动开展得如火如荼，开发人员对浏览器里包含的那些乱七八糟的专有特性已经忍无可忍了。大家都很生气，就骂那些浏览器厂商“遵守个规范就他妈的真有那么难吗？”当时 CSS 有了长足的发展，而且与 XHTML 1.0 结合得也很紧密，CSS 加 XHTML 1.0 基本上就可以算是“最佳实践”了。虽然在我看来 HTML 4.01 与 XHTML 1.0 没有本质上的不同，但大家都接受了。专业的开发人员能做到元素全部小写，属性全部小写，属性值也全部加引号：由于专业人员起到了模范带头作用，越来越多的人也都开始支持这种语法。</p><p>我就是一个例子！过去的 10 年，我一直都使用 XHTML 1.0 文档类型，原因是这样一来验证器就能给我帮上很大的忙，对不对？只要我写的是 XHTML 1.0，然后用验证器测试，它就能告诉我是不是忘了给属性值加引号，是不是没有结束某个标签，等等等等。而如果我写的是 HTML 4.01，同样的问题就变成了有效的了，验证器就不一定会提醒我了。</p><p>这就是我一直使用 XHTML 1.0 的原因。我估计很多人都……使用 XHTML 1.0 的朋友，请把手举起来。好的。HTML 4.01 呢？人少多了。一直没有举手的呢，大声点，你们用什么？HTML5，也很好！更早的呢，还有人使用更早的文档类型吗？没有了？</p><p>10 年来我一直使用 XHTML 1.0，就是因为验证器能够真正帮到我。有人用 XHTML 1.1 吗？你知道有人用吗？请举手，别放下。有人把网页标记为 XML 文档吗？有吗？那你们使用的就不是 XHTML 1.1。</p><p>这就是个大问题。XHTML 1.0 之后是 XHTML 1.1，只是小数点后面的数字加了一个 1，而且从词汇表的角度看，规范本身没有什么新东西，元素也都相同，属性也都相同。但对 XHTML 1.1 来说，唯一的变化是你必须把自己的文档标记为 XML 文档。在使用 XHTML 1.0 的时候，还可以把文档标记为 HTML，而我们也正是这样做的，否则把文档标记为 XML 没准真会把人逼疯的。</p><p>为什么这么说呢？首先，把文档标记为 XML 后，Internet Explorer 不能处理。当然，IE9 是可以处理了。恐怕有人会讲“真是太可爱了”，他们到现在居然都没有忘了这件事。这艘船终于靠岸了！不过那时候，作为全球领先的浏览器，IE 无法处理接收到的 XML 文档类型的文档，而规范又要求你以 XML 文档类型来发送文档，这不把人逼疯才怪呢。</p><p>所以说 XHTML 1.1 有点脱离现实，而你不想把文档以 XML 格式发送给那些能够理解 XML 的浏览器，则是因为 XML 的错误处理模型。XML 的语法，无论是属性小写，元素小写，还是始终要给属性值加引号，这些都没有问题，都很好，事实上我也喜欢这样做，但 XML 的错误处理模型却是这样的：解析器如果遇到错误，停止解析。规范里就是这么写的。如果你把 XHTML 1.1 标记为 XML 文档类型，假设你用 Firefox 打开这个文档，而文档中有一个和号（&amp;）没有正确编码，就算整个页面中就这一处错误，你看到的也将是黄屏，浏览器死掉了。Firefox 会说：“没戏了，页面中有一个错误，你看不到这个网页了。”根据 XML 规范，这样处理是正确的，对 Firefox 而言，遇到错误就停止解析，并且不呈现其他任何内容是严格按照 XML 规范做的。因为它不是 HTML，HTML 根本就没有错误处理模型，但根据 XML 规范，这样做没错。</p><p>这就是为什么你不会把文档标记为 XML 的另一个原因。接下来，新的版本是 XHTML 2，大家注意后面没有日期，因为这个规范并没有完成。</p><p>现在就说说 XHTML 2，我很愿意把问题说清楚，XHTML 2 实际上真是一个非常非常好的规范，确实非常好……从理论的角度来说。我的意思是说，制定这个规范的人都是非常非常有头脑的。直说吧，领导制定这个规范的家伙是斯蒂芬·彭伯顿（Stephen Pemberton），他应该是本地人，是一个聪明过人的家伙。规范本身也很了不起，如果所有人都同意使用的话，也一定是一个非常好的格式。只不过，还不够实际。</p><p>首先，XHTML 2 仍然使用 XML 错误处理模型，你必须保证以 XML 文档类型发送文档；这一点不言自明：没人愿意这样做。其次，XHTML 2 有意不再向后兼容已有的 HTML 的各个版本。他们甚至曾经讨论过废除 img 元素，这对每天都在做 Web 开发的人来说确实有点疯了的味道。但我们知道，他们之所以这样做，理论上确实有充足的理由——使用 object 元素可能会更好。</p><p>因此，无论 XHTML 2 在理论上是多么完美的一种格式，但却从未有机会付诸实践。而之所以难以将其付诸实践，就是因为像你我这样的开发人员永远不会支持它，它不向后兼容。同样，浏览器厂商也不会，浏览器厂商必须要保证向后兼容。</p><p>为什么 XHTML 1.1 没有像 XML 那样得到真正广泛地应用，为什么 XHTML 2 从未落到实处？因为它违反了一条设计原理，这条设计原理就是著名的伯斯塔尔法则（Postel’s Law）。大家都知道：</p><blockquote><p>发送时要保守；接收时要开放。</p></blockquote><p>没错，接收的时候要开放，而这也正是 Web 得以构建的基础。开发浏览器的人必须敞开胸怀，接收所有发送给浏览器的东西，因为它们过去一直都在接收那些不够标准的东西，对不对？Web 上的很多文档都不规范，但那正是 Web 发展的动力。从某种角度讲，Web 走的正是一条混沌发展之路，虽然混沌，但却非常美丽诱人。在 Web 上，格式不规范的文档随处可见，但那又怎样呢？如果所有人都能够写出精准的 XML，所有文档的格式都十分正确，那当然好了。可是，那不现实。现实是伯斯塔尔法则。</p><p>作为专业人士，在发送文档的时候，我们会尽量保守一些，尽量采用最佳实践，尽量确保文档格式良好。但从浏览器的角度说，它们必须以开放的姿态去接收任何文档。</p><p>有人可能会说 XML 有错误处理模型，XHTML 1.1 和 XHTML 2 都使用该模型，但那个错误处理模型太苛刻了。它绝对不符合接收时开放这个法则，遇到一个错误就停止解析怎么能叫开放呢？我们只能说它与健壮性法则（也就是伯斯塔尔法则）是对立的。</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>之后，就到了 HTML5，但 HTML5 并不是由 W3C 直接制定的。故事的经过是这样的，到 20 世纪末的时候，还没有 HTML 工作组，W3C 内部的一些人就开始琢磨了，“HTML 也许还可以更长寿一点，只要我们对它稍加扩展就行了。只要把我们放在 XHTML 上的时间和精力拿出一部分来，就可以提升一下 HTML 中的表单，可以让 HTML 更接近编程语言，就可以让它更上一层楼。”</p><p>于是，在 2004 年 W3C 成员内部的一次研讨会上，当时 Opera 公司的代表伊恩·希克森（Ian Hickson）提出了一个扩展和改进 HTML 的建议。他建议新任务组可以跟 XHTML 2 并行，但是在已有 HTML 的基础上开展工作，目标是对 HTML 进行扩展。W3C 投票表决的结果是——“反对”，因为 HTML 已经死了，XHTML 2 才是未来的方向。然后，Opera、Apple 等浏览器厂商，以及其他一些成员说：“那好吧，不指望他们了，我们自已一样可以做这件事，我们脱离 W3C。”他们成立了 Web Hypertext Applications Technology Working Group（Web 超文本应用技术工作组，WHATWG）——可巧的是，他们自称工作组，而不是特别小组（task force），这就为 HTML5 将来的命运埋下了伏笔。</p><p>WHATWG 决定完全脱离 W3C，在 HTML 的基础上开展工作，向其中添加一些新东西。这个工作组的成员里有浏览器厂商，因此他们不仅可以说加就加，而且还能够一一实现。结果，大家不断提出一些好点子，并且逐一做到了浏览器中。</p><p>WHATWG 的工作效率很高，不久就初见成效。在此期间，W3C 的 XHTML 2 没有什么实质性的进展。特别是，如果从实现的角度来说，用原地踏步形容似乎也不为过。</p><p>结果，一件有意思的事情发生了。那是在 2006 年，蒂姆·伯纳斯 - 李写了一篇博客，说：“你们知道吗？我们错了。我们错在企图一夜之间就让 Web 跨入 XML 时代，我们的想法太不切实际了，是的，也许我们应该重新组建 HTML 工作组了。”善哉斯言，后来的故事情节果真就是这样发展的。W3C 在 2007 年组建了 HTML5 工作组。这个工作组面临的第一个问题，毫无疑问就是“我们是从头开始做起呢，还是在 2004 年成立的那个叫 WHATWG 的工作组既有成果的基础上开始工作呢？”答案是显而易见的，他们当然希望从已经取得的成果着手，以之为基础展开工作。于是他们又投了一次票，同意“在 WHATWG 工作成果的基础上继续开展工作”。好了，这下他们要跟 WHATWG 并肩战斗了。</p><p>第二个问题就是如何理顺两个工作组之间的关系。W3C 这个工作组的编辑应该由谁担任？是不是还让 WHATWG 的编辑，也就是现在 Google 的伊恩·希克森来兼任？于是他们又投了一次票，赞成“让伊恩·希克森担任 W3C HTML5 规范的编辑，同时兼任 WHATWG 的编辑，更有助于新工作组开展工作。”</p><p>这就是他们投票的结果，也就是我们今天看到的局面：一种格式，两个版本。WHATWG 的网站上有这个规范，而 W3C 的站点上同样也有一份。</p><p>如果你不了解内情，很可能会产生这样的疑问：“哪个版本才是真正的规范？”当然，这两个版本内容是一样的……基本上相同。实际上，这两个版本将来还会分道扬镳。现在已经有了分道扬镳的迹象了。我的意思是说，W3C 最终要制定一个具体的规范，这个规范会成为一个工作草案，定格在某个历史时刻。</p><p>而 WHATWG 呢，他们还在不断地迭代。即使目前我们说的 HTML5，也不能完全涵盖 WHATWG 正在从事的工作。最准确的理解是他们正在开发一项简单的 HTML 或 Web 技术，因为这才是他们工作的核心目标。然而，同时存在两个这样的工作组，这两个工作组同时开发一个基本相同的规范，这无论如何也容易让人产生误解。误解就可能造成麻烦。</p><p>其实这两个工作组背后各自有各自的流程，因为它们的理念完全不同。在 WHATWG，可以说是一种独裁的工作机制。我刚才说了，伊恩·希克森是编辑。他会听取各方意见，在所有成员各抒己见，充分陈述自己的观点之后，他批准自己认为正确的意见。<br>W3C 则截然相反，可以说是一种民主的工作机制。所有成员都可以发表意见，而且每个人都有投票表决的权利。这个流程的关键在于投票表决。从表面上看，WHATWG 的工作机制让人不好接受。岂止是不好接受，简直是历史的倒退。相信谁都会认为“运作任何项目都不能采取这种方式！”</p><p>W3C 的工作机制听起来让人很舒服。至少体现了人人平等嘛。但在实践中，WHATWG 的工作机制运行得非常非常好。我认为之所以会这样，主要归功于伊恩·希克森。他的的确确是一个非常称职的编辑。他在听取各方意见时，始终可以做到丝毫不带个人感情色彩。</p><p>从原理上讲，W3C 的工作机制很公平，而实际上却非常容易在某些流程或环节上卡壳，造成工作停滞不前，一件事情要达成决议往往需要花费很长时间。那到底哪种工作机制最好呢？我认为，最好的工作机制是将二者结合起来。而事实也是两个规范制定主体在共同制定一份相同的规范，我想，这倒是非常有利于两种工作机制相互取长补短。</p><p>两个工作组之所以能够同心同德，主要原因是 HTML5 的设计思想。因为他们从一开始就确定了设计 HTML5 所要坚持的原则。结果，我们不仅看到了一份规范，也就是 W3C 站点上公布的那份文档，即 HTML5 语言规范，还在 W3C 站点上看到了另一份文档，也就是 HTML 设计原理。而这份文档的一位编辑今天也来到了我们大会的现场，他就是安妮·奇泰丝（Anne Van Kesteren）。如果大家对这份文档有问题，可以请教安妮。</p><p>这份文档非常好，真的非常出色。这份文档，可以说见证了 W3C 与 WHATWG 同心协力共谋发展的历程。难道你们不觉得他们像是一对欢喜冤家吗？那他们还怎么同心同德呢？这份文档忠实地记录了他们一道做了什么，他们共同拥护什么。</p><p>接下来，我想要讲的就是这份文档。因为，既然他们能就这份文档达成共识，那么我相信，HTML5 必将是一个伟大的规范，而他们已经认可这就是他们的共同行动纲领。为此，你才会看到诸如兼容性、实用性、互用性之类的概念。即便 W3C 与 WHATWG 之间再有多大的分歧——确实相当多——至少他们还有这份文档中记录的共识。这一点才是至关重要的。正因为他们有了共识，才有了这份基于共识描述设计原理的文档。</p><h2 id="避免不必要的复杂性"><a href="#避免不必要的复杂性" class="headerlink" title="避免不必要的复杂性"></a>避免不必要的复杂性</h2><p>下面我就给大家介绍一些这份文档中记载的设计原理。第一个，非常简单：避免不必要的复杂性。好像很简单吧。我用一个例子来说明。</p><p>假设我使用 HTML 4.01 规范，我打开文档，输入 doctype。这里有人记得 HTML 4.01 的 doctype 吗？好，没有，我猜没有。除非……我的意思是说，你是傻冒。现场恐怕真有人背过，这就是 HTML 4.01 的 doctype：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C/DTD HTML 4.01//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我不记这个两行代码，不然还要记事本、要 Google、要模板有什么用呢？</p><p>要是我使用 XHTML 1.0 呢，这个规范我都已经用了 10 年了。有谁记得住这个 doctype 吗？没错，它的长度跟 HTML 4.01 的差不太多：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C/DTD XHTML 1.0 Strict//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是，基本上相同。它要告诉浏览器的是：这个文档是 XHTML 1.0 的文档。那么在 HTML 5 中，省掉不必要的复杂性，doctype 就简化成了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仅此而已。好了，就连我也能过目不忘了。我用不着把这几个字符记在记事本里了。我得说，在我第一次看到这个 doctype 的时候——我当然以为这是一个 HTML 文档的 doctype——被它吓了一跳：“是不是还少一个数字 5 啊？”我心里想：“这个 doctype 想告诉浏览器什么呢？就说这个文档是 HTML 吗？难道这是有史以来唯一一个 HTML 版本吗，这件事我得首先搞清楚，HTML 今后永远不会再有新版本了吗？”好一副唯我独尊的架式！我错了，因为这个 doctype 并没有这个意思。为此，必须先搞清楚为什么文档一开头就要写 doctype。它不是写给浏览器看的。Doctype 是写给验证器看的。也就是说，我之所以要在文档一开头写那行 XHTML 1.0 的 doctype，是为了告诉验证器，让验证器按照该 doctype 来验证我的文档。</p><p>浏览器反倒无所谓了。假设我写的是 HTML 3.2 文档，文档开头写的是 HTML 3.2 的 doctype。而在文档中某个地方，我使用了 HTML 4.01 中才出现的一个元素。浏览器会怎么处理这种情况？它会因为这个元素出现在比 doctype 声明的 HTML 版本更晚的规范中，就不解释呈现该元素吗？不会，当然不会！它照样会解释呈现该元素，别忘了伯斯塔尔法则，别忘了健壮性。浏览器在接收的时候必须要开放。因此，它不会检查任何格式类型，而验证器会，验证器才关心格式类型。这才是存在 doctype 的真正原因。</p><p>而按照 HTML5 的另一个设计原理，它必须向前向后兼容，兼容未来的 HTML 版本——不管是 HTML6、HTML7，还是其他什么——都要与当前的 HTML 版本，HTML5，兼容。因此，把一个版本号放在 doctype 里面没有多大的意义，即使对验器证也一样。</p><p>刚才，我说 doctype 不是为浏览器写的，这样说大多数情况下没有问题。在有一种情况下，你使用的 doctype 会影响到浏览器，相信在座诸位也都知道。但在这种情况下，Doctype 并非真正用得其所，而只是为了达到某种特殊的目的才使用 doctype。当初微软在引入 CSS 的时候，走在了标准的前头，他们率先在浏览器中支持 CSS，也推出了自己的盒模型——后来标准发布了，但标准中使用了不一样的盒模型。他们怎么办？他们想支持标准，但也想向后兼容自己过去推出的编码方式。他们怎么知道网页作者想使用标准，还是想使用他们过去的方式？</p><p>于是，他们想出了一个非常巧妙的主意。那就是利用 doctype，利用有效的 doctype 来触发标准模式，而不是兼容模型（quiks mode）。这个主意非常巧妙。我们今天也都是这样在做，在我们向文档中加入 doctype 时，就相当于声明了“我想使用标准模式”，但这并不是发明 doctype 的本意。这只是为了达到特殊的目的在利用 doctype。</p><p>下面我出一道有奖抢答题，听好：“一分钟后开始，如果你手快的话，第一个在文档前面写完 doctype html，然后我用 Internet Explorer 打开你的文档，会触发它的标准模式，还是会触发它的兼容模式？”</p><p>答案是，这是在 Internet Explorer 中触发标准模式的最少字符数目。我认为这也说明了 HTML5 规范的本质：它不追求理论上的完美。HTML5 所体现的不是“噢，给作者一个简短好记的 doctype 不好吗？”，没错，简短好记是很好，但如果这个好记的 doctype 无法适应现有的浏览器，还不如把它忘了更好。因此，这个平衡把握得非常好，不仅理论上看是个好主意——简短好记的 doctype，而且实践中同样也是个好主意——仍然可以触发标准模式。应该说，Doctype 是一个非常典型的例子。</p><p>还有一个例子，同样可以说明规范是如何省略不必要的复杂性，避免不必要的复杂性的。如果前面的文档使用的是 HTML 4.01，假设我要指定文档的字符编码。理想的方式，是通过服务器在头部信息中发送字符编码，不过也可以在文档这个级别上指定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样，我也不会把这行代码背下来。我还想省下自己的脑细胞去记点别的更有价值的东西呢。不过，如果我想指定文档使用 UTF-8 编码，只能添加这行代码。这是在 HTML 4.01 中需要这样做。要是你在 XHTML 1.0 指定同样的编码，就得多敲一下键盘，因为你还得声明 meta 元素位于一个开始的 XML 标签中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在 HTML5 中，你要敲的字符只有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简短好记。我能背下来。</p><p>同样，这样写也是有效的。它不仅适用于最新版本的浏览器，只要是今天还有人在用的浏览器都同样有效。为什么？因为在我们把这些 meta 元素输入浏览器时，浏览器会这样解释它：“元数据（meta）点点点点点，字符集（charset）utf-8。”这就是浏览器在解释那行字符串时真正看到的内容。它必须看到这些内容，根据就是伯斯塔尔法则，对不对？</p><p>我多次提到健壮性原理，但总有人不理解。我们换一种说法，浏览器会想“好，我觉得作者是想要指定一个字符集……看，没错，utf-8。”这些都是规范里明文规定的。如今，不仅那个斜杠可以省了，而且总共只要写 meta charset&#x3D;”utf-8″就行了。</p><p>关于省略不必要的复杂性，或者说避免不必要的复杂性的例子还有不少。但关键是既能避免不必要的复杂性，还不会妨碍在现有浏览器中使用。比如说，在 HTML5 中，如果我使用 link 元素链接到一个样式表，我说了 rel&#x3D;”stylesheet”，然后再说 type&#x3D;”text&#x2F;css”，那就是重复自己了。对浏览器而言，我就是在重复自己。浏览器用不着同时看到这两个属性。浏览器只要看到 rel&#x3D;”stylesheet”就够了，因为它可以猜出来你要链接的是一个 CSS 样式表。所以就不用再指定 type 属性了。你不是已经说了这是一个样式表了嘛；不用再说第二次了。当然，愿意的话，你可以再说；如果你想包含 type 属性，请便。</p><p>同样地，如果你使用了 script 元素，你说 type&#x3D;”text&#x2F;javascript”，浏览器差不多就知道是怎么回事了。对 Web 开发而言，你还使用其他的脚本语言吗？如果你真想用其他脚本语言，没人会阻拦你。但我要奉劝你一句，任何浏览器都不会支持你。<br>愿意的话，你可以添加一个 type 属性。不过，也可以什么都不写，浏览器自然会假设你在使用 JavaScript。避免 - 不必要的 - 复杂性。</p><h2 id="支持已有的内容"><a href="#支持已有的内容" class="headerlink" title="支持已有的内容"></a>支持已有的内容</h2><p>支持已有的内容。这一点非常重要，因为很多人都认为 HTML5 很新，很闪亮；它应该代表着未来发展的方向，应该把 Web 推向一个新的发展阶段。这就是 HTML5，对吗？显然，我们都会考虑让 Web 的未来发展得更好，但他们则必须考虑过去。别忘了 W3C 这个工作组中有很多人代表的是浏览器厂商，他们肯定是要考虑支持已有内容的。只要你想构建一款浏览器，就必须记住这个原则：必须支持已有的内容。</p><p>下面我们就来看一个 HTML5 支持已有内容的例子。</p><p>这个例子展示了编写同样内容的四种不同方式。上面是一个 img 元素，下面是带一个属性的段落元素。四种写法唯一的不同点就是语法。把其中任何一段代码交给浏览器，浏览器都会生成相同的 DOM 树，没有任何问题。从浏览器的角度看，这四种写法没有区别。因而在 HTML5 中，你可以随意使用下列任何语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;bar&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello world</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">ALT</span>=<span class="string">&quot;bar&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">P</span> <span class="attr">CLASS</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">foo</span> <span class="attr">alt</span>=<span class="string">bar</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">foo</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，看到这几段代码，恐怕有人会说“不对不对不对。其中只有一个是对的，另外三个——说不好。”不对，应该给属性值加引号！拜托，我们可是一直都给属性值加引号的！元素名大写对吗？这种做法 10 年不是就被抛弃了吗？</p><p>看到 HTML5 同时允许这些写法，我心里忍不住一阵阵想吐。我写了 10 年的 XHTML 1.0，已经非常适应严格的语法了。但你必须明白，站在浏览器的角度上，这些写法实际上都是一样的。确实没有什么问题。</p><p>还有谁也感到不舒服了吗？有谁看到这些之后想“噢，这不是乱写嘛，这样做不对”？只有我这样想吗？还有别人吗？</p><p>但是，HTML5 必须支持已经存在的内容，而已有的内容就是这个样子的。不是吗？根据伯斯塔尔法则，浏览器没有别的选择。</p><p>有人可能会说“这样不行。我觉得语言本身应该提供一种开关，让作者能够表明自己想做什么。”比如说，想使用某种特定的语法，像 XHTML，而不是使用其他语法。我理解这些人的想法。但我不赞成在语言里设置开关。因为我们讨论的只是编码风格或者写作风格，跟哪种语法正确无关。对于像我们这样的专业人士，我认为可以使用 lint 工具（一种软件质量保证工具，或者说是一种更加严格的编译器。它不仅可以象普通编译器那样检查出一般的语法错误，还可以检查出那些虽然完全合乎语法要求，但很可能是潜在的、不易发现的错误），对其他技术我们不是也在使用 lint 工具嘛。</p><p>比如说对 JavaScript 使用 lint 工具。JavaScript 同样也是比较混乱、不严谨的例子，但它非常强大，原因恰恰是它混乱、不严谨，而且有很多不同的编码方式。在 JavaScript，你可以在每条语句末尾加上分号，但不是必需的，因为 JavaScript 会自动插入分号……是不是听起来有点不好接受？</p><p>正因为如此，才有了像 JSlint 这样的工具，在道格拉斯·克劳克福德（Douglas Crockford）的网站 jslint.org 上面。有个网页上写着“JSlint 可能会伤害你的感情。”但这确实是个非常棒的工具，它可以把 JavaScript 代码变得完美无瑕。如果你通过 JSlint 运行 JavaScript，它会告诉你“好，你的 JavaScript 代码有效，但写法不妥。你这种编码风格啊，我不喜欢。不赞成你这样写。这样写不好。”特别是对团队，对于要使用统一的编码风格的团队，JSlint 是非常方便的工具。</p><p>我个人认为，不仅对团队来说，就算是你自己写代码，也要坚持一种语法风格。从浏览器解析的角度讲，不存在哪种语法比另一种更好的问题，但我认为，作为专业人士，我们必须能够自信地讲“这就是我的编码风格。”然而，我不认为语言里应该内置这种开关。你可以使用 lint 工具来统一编码风格。现在就来说说 lint 工具。大家可以登录 htmllint.com，在其中运行你的 HTML5 文档，它会帮你检查属性值是否加了引号，元素是否小写，你还可以通过勾选复选框来设置其他检查项。</p><p>但这不意味着拒绝粗心大意的标记，做不做清理完全取决于你自己。我说过，因为浏览器必须支持已有的内容，HTML5 自然也不能例外。归根结底还是伯斯塔尔法则。我们始终离不开伯斯塔尔法则。</p><p>解决现实的问题<br>HTML5 的另一个设计原理是解决现实的问题。显而易见的是，解决各种问题的格式和规范已经比比皆是了，但是在我看来，那些格式和规范要解决的都是理论问题，而非现实问题。这条设计原理才是真正要解决今天的人们所面临的现实问题、令人头疼的问题。</p><p>下面我来举个例子。相信这个例子有不少人都遇到过。假设我使用 HTML 4 或 XHTML 1，页面中已经有了一块内容，我想给整块内容加个链接，怎么办？问题是这块内容里包含一个标题，一个段落，也许还有一张图片。如果我想给它们全部都可以点击，必须使用 3 个链接元素。于是，我得先把光标放在标题（比如说 h2 元素）中，写一个链接标签，然后再选中所有要包含到链接里面来的文本。接着，再把光标放在段落里，写一个链接标签，然后把段落中的文本放在链接里……</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/resource&quot;</span>&gt;</span>Headline text<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/resource&quot;</span>&gt;</span>Paragraph text.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 HTML5 中，我只要简单地把所有内容都包装在一个链接元素中就行了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/resource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Headline text<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没错，链接包含的都是块级元素，但现在我可以用一个元素包含它们。这样太好了。因为我碰到过类似的情形，必须给几个块级元素加上相同的链接，所有能这样写就太好了。为此，我就非常欢迎 HTML5 这个新标准。</p><p>它解决了一个现实的问题。我敢说在座不少朋友都曾遇到过这个问题。</p><p>那这到底解决的是什么问题呢？浏览器不必因此重新写代码来支持这种写法。这种写法其实早就已经存在于浏览器中了，因为早就有人这样写了，当然以前这样写是不合乎规范的。所以，说 HTML5 解决现实的问题，其本质还是“你都这样写了很多年了吧？现在我们把标准改了，允许你这样写了。”</p><h2 id="求真务实"><a href="#求真务实" class="headerlink" title="求真务实"></a>求真务实</h2><p>在所有设计原理中，这一条恐怕是最响亮的了——求真务实。不知道大家有没有在公司里开会时听到过这种口号：“开拓进取，求真务实。”实际上，除了作为企业的口号，它还是一条非常重要的设计原理，因为求真务实对于 HTML 的含义是：在解决那些令人头痛的问题之前，先看看人们为应对这些问题都想出了哪些办法。集中精力去理解这些“民间的”解决方案才是当务之急。</p><p>HTML5 中新的语义元素就是遵循求真务实原理的反映。新增的元素不算多，谈不上无限的扩展性，但却不失为一件好事。尽管数量屈指可数，但意义却非同一般。这些新元素涉及头部（header）、脚部（footer）、分区（section）、文章（article）……，相信大家都不会觉得陌生。我的意思是说，即便你不使用 HTML5，也应该熟悉这些称呼，这些都是你曾经使用过的类名，比如 class&#x3D;”header”&#x2F;“head”&#x2F;“heading”，或 class&#x3D;”footer”&#x2F;“foot”。当然，也可能是 ID，id&#x3D;”header”，id&#x3D;”footer”。这些不都是我们已经司空见惯了的嘛。</p><p>好，举个例子吧，假设你今天写了下面这个文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有一个 div 使用了 id&#x3D;”header”，另一个 div 使用了 id&#x3D;”navigation”，……。怎么样，都轻车熟路了吧？在 HTML5 中，这些元素都可以换掉。说起新增的语义元素，它们价值的一方面可以这样来体现：“嘿，看啊，这样多好，用 HTML5 新增的元素可以把这些 div 都替换掉。”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span>...<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span>...<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然了，你可以这样做。在文档级别上使用这些元素没有问题。但是，假如新增这些元素的目的仅仅是为了取代原来的 div，那就真有点多此一举了。</p><p>虽然在这个文档中，我们用这些新元素来替换的是 ID，但在我个人看来，将它们作为类的替代品更有价值。为什么这么说呢？因为这些元素在一个页面中不止可以使用一次，而是可以使用多次。没错，你可以为文档添加一个头部（header），再添加一个脚部（footer）；但文档中的每个分区（section）照样也都可以有一个头部和一个脚部。而每个分区里还可以嵌套另一个分区，被嵌套的分区仍然可以有自己的头部和脚部，是这样吧？</p><p>这四个新元素：section、article、aside 和 nav，之所以说它们强大，原因在于它们代表了一种新的内容模型，一种 HTML 中前所未有的内容模型——给内容分区。迄今为止，我们一直都在用 div 来组织页面中的内容，但与其他类似的元素一样，div 本身并没有语义。但 section、article、aside 和 nav 实际上是在明确地告诉你——这一块就像文档中的另一个文档一样。位于这些元素中的任何内容，都可以拥有自己的概要、标题，自己的脚部。</p><p>其中最为通用的 section，可以说是与内容最相关的一个。而 article 则是一种特殊的 section。Aside 呢，是一种特殊的 section。最后，Nav 也是一种特殊的 section。</p><p>好，即便是现在，你照样可以使用 div 和类来描述页面中不同的部分，就像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;meta&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;links&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中包含可能是有关内容作者的元数据，而下面会给出一些链接，差不多就这样。在 HTML5 中，我完全可以说这块内容就是一个文档，通过对内容分区，使用 section 或 article 或 aside，我可以说“这一块完全是可以独立存在的。”因此，我当然可以使用 header 和 footer。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;meta&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;links&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意，即便是 footer，也不一定非要出现在下面，不是吗？这几个元素，header、footer、aside、nav，最重要的是它们的语义；跟位置没有关系。一想到 footer 这个词，我们总会不由自主地想，“噢，应该放在下面。”同样，我们把 aside 想象成一个侧边栏。可是，如果你看一看规范，就会发现这些元素只跟内容有关。因此，放在 footer 中的内容也可以是署名，文章作者之类的，它只是你使用的一个元素。这个元素并没有说“必须把我放在文档或者分区的下面。”</p><p>这里，请注意，最重要的还不是我用几个新元素替换了原来的 div 加类，而是我把原来的 H2 换成了 H1——震撼吧，我看到有人发抖了。我碰到过不少职业的 Web 开发人员，多年来他们一直认为规范里说一个文档中只能有一个 H1。还有一些自诩为万能的 SEO 秘诀同样说要这样。很多 SEO 的技巧其实是很教条的。所谓教条，意思就是不相信数据。过去，这种教条表现为“不行，页面中包含两个以上的 H1，你就会死掉的。”在 HTML5 中，只要你建立一个新的内容块，不管用 section、article、aside、nav，还是别的元素，都可以在其中使用 H1，而不必担心这个块里的标题在整个页面中应该排在什么级别；H2、H3，都没有问题。</p><p>这个变化太厉害了。想一想吧，这个变化对内容管理是革命性的。因为现在，你可以把每个内容分区想象一个独立的、能够从页面中拿出来的部分。此时，根据上下文不同，这个独立部分中的 H1，在整个页面中没准会扮演 H2 或 H3 的角色——取决于它在文档中出现的位置。面对这个突如其来的变化，也许有人的脑子会暂时转不过弯来。不要紧，但我可以告诉你，我认为这才是 HTML5 中这些新语义标记的真正价值所在。换句话说，我们现在有了独立的元素了，这些元素中的标题级别可以重新定义。</p><p>我的文档中可能会包含一个分区，这个分区中可能会嵌套另一个分区，或者一篇文章，然后文章再嵌套分区，分区再嵌套文章、嵌套分区，文章再嵌套文章。而且每个分区和文章都可以拥有自己的 H1 到 H6。从这个意义上讲，H 元素真可谓“子子孙孙，无穷匮也”了。但是，在你在编写内容或者内容管理系统的时候，它们又都是独立的，完全独立的内容块。这才是真正的价值所在。<br>实际上，这个点子并不 HTML5 工作组拍脑门想出来的，也不是 W3C 最近才提出来的。下面这几句话摘自蒂姆·伯纳斯 - 李 1991 年的一封邮件，邮件是发给丹·康纳利（Dan Connolly）的。他在邮件中解释了对 HTML 的理解，他说：“你知道……知道我的想法，我认为 H1、H2 这样单调地排下去不好，我希望它成为一种可以嵌套的元素，或者说一个通用的 H 元素，我们可以在其中嵌套不同的层次。”但后来，我们没有看到通用的 H 元素，而是一直在使用 H1 和 H2——那是因为我们一直在支持已有的内容。20 年后的今天，这个理想终于实现了。</p><h2 id="平稳退化"><a href="#平稳退化" class="headerlink" title="平稳退化"></a>平稳退化</h2><p>下一条原理大家应该都很熟悉了，那就是平稳退化。毕竟，我们已经遵守这条规则好多年了。渐进增强的另一面就是平稳退化。</p><p>有关 HTML5 遵循这条原理的例子，就是使用 type 属性增强表单。下面列出了可以为 type 属性指定的新值，有 number、search、range，等等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最关键的问题在于浏览器在看到这些新 type 值时会如何处理。现有的浏览器，不是将来的浏览器，现有的浏览器是无法理解这些新 type 值的。但在它们看到自己不理解的 type 值时，会将 type 的值解释为 text。</p><p>无论你写的是 input type&#x3D;”foo”还是 input type&#x3D;”bar”，现有的任何浏览器都会说：“嗯，也许作者的意思是 text。”因而，你从现在开始就可以使用这些新值，而且你也可以放心，那些不理解它们的浏览器会把新值看成 type&#x3D;”text”，而这真是一个浏览器实践平稳退化原理的好例子。</p><p>比如说，你现在输入了 type&#x3D;”number”。假设你需要一个输入数值的文本框。那么你可以把这个 input 的 type 属性设置为 number，然后理解它的浏览器就会呈现一个可爱的小控件，像带小箭头图标的微调控件之类的。对吧？而在不理解它的浏览器中，你会看到一个文本框，一个你再熟悉不过的文本框。既然如此，为什么不能说输入 type&#x3D;”number”就会得到一个带小箭头图标的微调控件呢？</p><p>当然，你还可以设置最小和最大值属性，它们同样可以平稳退化。这是问题的关键。</p><p>再看 input type&#x3D;”search”。你也可以考虑一下这种输入框，因为这种输入框在 Safari 中会被呈现为一个系统级的搜索控件，右边还有一个点击即可清除搜索关键词的 X。而在其他浏览器中，你得到的则是一个文本框，就像你写的是 input type&#x3D;”text”一样，也就是你已经非常熟悉的文本框。那为什么还不使用 input type&#x3D;”search”呢？它不会有什么副作用，没有，对不对？</p><p>HTML5 还为输入元素增加了新的属性，比如 placeholder（占位符）。有人不知道这个属性的用处吗，没有吧？没错，就是用于在文本框中预先放一些文本。不对，不是标签（label）——占位符和标签完全不是一回事。占位符就是文本框可以接受的示例内容，一般颜色是灰色的。只要你一点击文本框，它就消失了。如果你把已经输入的内容全部删除，然后单击了文本框外部，它又会出现。</p><p>使用 JavaScript 编写一些代码当然也可以实现这个功能，但 HTML5 只用一个 placeholder 属性就帮我们解决了问题。</p><p>当然，对于不支持这个属性的浏览器，你还是可以使用 JavaScript 来实现占位符功能。通过 JavaScript 来测试浏览器支不支持该属性也非常简单。如果支持，后退一步，把路让开，乐享其成即可。如果不支持，可以再让你的 JavaScript 来模拟这个功能。</p><p>现在，我不得不提到另一个话题了：HTML5 对 Flash。也许你早听说过了，或者在哪里看到了这方面的讨论。说实话，我一点也不明白。我搞不懂人们怎么会仅仅凭自己的推测来展开争论。<br>首先，他们所说的 HTML5 对 Flash，并不是指的 HTML5，也不是指的 Flash。而是指 HTML5 的一个子集和 Flash 的一个子集。具体来说，他们指的是视频。因此，不管你在哪里听到别人说“HTML5 对 Flash”，那很可能说的只是 HTML5 视频对 Flash 视频。</p><p>其次，一说 HTML5 对 Flash，就好像你必须得作出选择一样：你站在哪一边？实际上不是这样的。HTML5 规范的设计能够让你做到鱼和熊掌兼得。</p><p>好，下面就来看看这个新的 video 元素；真是非常贴心的一个元素，而且设计又简单，又实用。一个开始的 video 元素，加一个结束的 video 元素，中间可以放后备内容。注意，是后备内容，不是保证可访问性的内容，是后备内容。下面就是针对不支持 video 元素的浏览器写的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后备内容 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，在后备内容里面放些什么东西呢？好，你可以放 Flash 影片。这样，HTML5 的视频与 Flash 的视频就可以协同起来了。你不用作出选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;movie.swf&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，你的代码实际上并没有这么简单。因为这里我使用了 H264，部分浏览器支持这种视频格式。但有的浏览器不支持。</p><p>对不起，请不要跟我谈视频格式，我一听就心烦。不是因为技术。技术倒无所谓，关键是会牵扯到一大堆专利还有律师、知识产权等等，这些都是 Web 的天敌，对我建网站一点好处都没有。</p><p>可你实际上要做的，仅仅就是把后备内容放在那而已，后备内容可以包含多种视频格式。如果愿意的话，可以使用 source 元素而非 src 属性来指定不同的视频格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;movie.swf&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;movie.mp4&quot;</span>&gt;</span>download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中包含了 4 个不同的层次。</p><ol><li>如果浏览器支持 video 元素，也支持 H264，没什么好说的，用第一个视频。</li><li>如果浏览器支持 video 元素，支持 Ogg，那么用第二个视频。</li><li>如果浏览器不支持 video 元素，那么就要试试 Flash 影片了。</li><li>如果浏览器不支持 video 元素，也不支持 Flash，我还给出了下载链接。</li></ol><p>不错，一开始就能考虑这么周到很难得啊。有了这几个层次，已经够完善了。</p><p>总之，我是建议你各种技术要兼顾，无论是 HTML5，还是 Flash，一个也不能少。如果只使用 video 元素提供视频，难免搬起石头砸自己的脚，我个人认为。而如果只提供 Flash 影片，情况也好不到哪去，性质是一样的。所以还是应该两者兼顾。</p><p>为什么要兼顾这两种技术呢？假设你需要面向某些不支持 Flash 的手持设备——只是举个例子——提供视频，你当然希望手持设备的用户能够看到视频了，不是吗？</p><p>至于为什么要使用不同的格式，为什么 Flash 视频和音频如此成功，我想可以归结为另一个设计原理，即梅特卡夫定律 (Metcalfe’s Law)：</p><blockquote><p>网络价值同网络用户数量的平方成正比。</p></blockquote><p>梅特卡夫的这个定律虽然是针对电话网提出来的，但在很多领域里也是适用的。使用网络的用户越多，网络的价值也就越大。人人都上 Facebook，还不是因为人人都上 Facebook 嘛。虽然 Facebook 真正的价值不在于此，但只有人人都上才会让它的变得如此有价值。</p><p>梅特卡夫定律也适用于传真机。如果只有一个人购买了传真机，当然没有什么用处。但如果其他人也陆续购买了传真机，那么他的投资会就得到回报。</p><p>当然，面对竞争性的视频格式和不同的编码方式，你感觉不到梅特卡夫定律的作用，我也很讨厌以不同的方式来编码视频，但只向浏览器发送用一种方式编码的视频是行不通的。而这也正是 Flash 在视频&#x2F;音频领域如此成功的原因。你只要把 Flash 影片发送给浏览器就好了，然后安装了插件的浏览器都能正常播放。本质上讲，Flash 利用了梅特卡夫定律。</p><h2 id="最终用户优先"><a href="#最终用户优先" class="headerlink" title="最终用户优先"></a>最终用户优先</h2><p>今天我要讲的最后一个设计原理，也是我个人最推崇的一个，但没有要展示的代码示例。这个原理更有哲学的味道，即最终用户优先。</p><p>这个设计原理本质上是一种解决冲突的机制。换句话说，当你面临一个要解决的问题时，如果 W3C 给出了一种解决方案，而 WHATWG 给出了另一种解决方案，一个人这么想，另一个人那么想……这时候，有人站出来说：“对这个问题我们这样来解决。”</p><blockquote><p>一旦遇到冲突，最终用户优先，其次是作者，其次是实现者，其次标准制定者，最后才是理论上的完满。</p></blockquote><p>理论上的完满，大致是指尽可能创建出最完美的格式。标准制定者，指的是工作组、W3C，等等。实现者，指的是浏览器厂商。作者，就是我们这些开发人员，对吧？看看我们在这个链条里面的位置多靠上啊！我们的地位仅次于最终用户——事情本来就该这个样子。用户是第一位的。而我们的声音在标准制定过程中也同样非常非常重要。</p><p>Hixie（即 Ian Hickson，Acid2、Acid3 的作者及维护者，HTML5、CSS 2.1 规范的制定者）经常说，在有人建议了某个特性，而 HTML5 工作组为此争论不下时，如果有浏览器厂商说“我们不会支持这个特性，不会在我们的浏览器中实现这个特性”，那么这个特性就不会写进规范。因为即使是把特性写进规范，如果没有厂商实现，规范不过是一纸空文，对不对？实现者可以拒绝实现规范。</p><p>而根据最终用户优先的原理，我们在链条中的位置高于实现者，假如我们发现了规范中的某些地方有问题，我们想“这样规定我们不能同意，我们不支持实现这个特性”，那么就等于把相应的特性给否定了，规范里就得删除，因为我们的声音具有更高的权重。我觉得这样挺好！本质上是我们拥有了更大的发言权，对吧？我认为开发人员就应该拥有更多的发言权。</p><p>我觉得这应该是最重要的一条设计原理了，因为它承认了你的权利，无论是设计一种格式，还是设计软件，这条原理保证了你的发言权。而这条原理也正道出了事物运行的本质。难道还不够明显吗？用户的权利大于作者，作者的权利大于实现者，实现者的权利大于标准制定者。然而，反观其他规范，比如 XHTML2，你就会发现完全相反的做法。把追求理论的完满放在第一位，而把用户——需要忍受严格错误处理带来的各种麻烦的用户——放在了链条的最底端。我并没有说这种做法就是错误的，但我认为这是一种完全不同的思维方式。</p><p>因此，我认为无论你做什么，不管是构建像 HTML5 这样的格式，还是构建一个网站，亦或一个内容管理系统，明确你的设计原理都至关重要。</p><blockquote><p>软件，就像所有技术一样，具有天然的政治性。代码必然会反映作者的选择、偏见和期望。</p></blockquote><p>下面我们讲一个例子。Drupal 社区曾联系马克·博尔顿（Mark Boulton）和丽莎·雷贺特（Leisa Reichilt）设计 Drupal 的界面。他们计划遵循一些设计原理。为此，他们并没有纸上谈兵，而是经过了一段时间的思考和酝酿，提出指导将来工作的 4 个设计原理：</p><blockquote><p>简化最常见的任务，让不常见的任务不至于太麻烦。<br>只为 80% 设计。<br>给内容创建者最大的权利。<br>默认设置智能化。</p></blockquote><p>实际上，我在跟马克谈到这个问题时，马克说主要还是那两个，即“只为 80% 设计。给内容创建者最大的权利。”这就很不错了，至少它表明了立场，“我们认为内容创建者比这个项目中的任何人都重要。”在制定设计原理时，很多人花了很多时间都抓不住重点，因为他们想取悦所有人。关键在于我们不是要取悦所有人，而是要明确哪些人最重要。他们认为内容创建者是最重要的。</p><p>另一条设计原理，只为 80% 设计，其实是一条常见的设计原理，也是一种通用模式，即帕累托原理（Pareto principle）。</p><p>帕累托是意大利经济学家，他提出这个比例，80&#x2F;20，说的是世界上 20% 的人口拥有 80% 的财富。这个比例又暗合了自然界各个领域的幂律分布现象。总之，无论你是编写软件，还是制造什么东西，都是一样的，即 20% 的努力可以触及 80% 的用例。最后 20% 的用例则需要付出 80% 甚至更多的努力。因此，有时候据此确定只为 80% 设计是很合理的，因为我们知道为此只要付出 20% 的努力即可。</p><p>再比如，微格式同样也利用了帕累托原理，只处理常见用例，而没有考虑少数情形。他们知道自己不会让所有人都满意；而他们的目标也不是让所有人都满意。他们遵循的设计原理很多，也都非常有价值，但最吸引人的莫过于下面这条了：</p><blockquote><p>首先为人类设计，其次为机器设计。</p></blockquote><p>同样，你我都会觉得这是一条再明显不过的道理，但现实中仍然有不少例子违反了这条原理：容易让机器理解（解析）比容易让用户理解更重要。</p><p>所以，我认为平常多看一看别人推崇的设计原理，有助于做好自己手头的工作。你可以把自己认为有道理的设计原理贴在墙上。当然，你可以维护一个 URL，把自己认为有价值的设计原理分享出来，就像 Mozilla 基金会那样，对不对，以下是 Mozilla 的设计原理：</p><blockquote><p>Internet 作为一种公共资源，其运作效率取决于互通性（协议、数据格式、内容）、变革及全球范围内的协作。</p><p>基于透明社区的流程有助于增进协作、义务和信任。</p></blockquote><p>我觉得像这样的设计原理都非常好。而有了设计原理，我认为才更有希望设计出真正有价值的产品。设计原理是 Web 发展背后的驱动力，也是通过 HTML5 反映出来的某种思维方式。我想，下面这条原理你绝对不会陌生：</p><blockquote><p>大多数人的意见和运行的代码。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="1992 年，大卫·克拉克（David Clark）教授在 IETF 会议上总结了这样一句话“We reject: kings, presidents, and voting. We believe in: rough consensus and running code”（我们拒绝国王、总统和投票，我们相信大多数人的意见和运行的代码）。这就是广为流传的“互联网哲学”（Internet Philosophy）。——译者注">[2]</span></a></sup></p></blockquote><p>对不对？这句话经常在我脑际回响，它囊括了 Web 的真谛，触及了 HTML5 的灵魂。</p><p>也许我该把这条原理打印出来贴到办公室的墙上，让它时刻提醒我，这就是 Web 的设计原理：大多数人的意见和运行的代码。</p><p>我想，今天的演讲就到这里了。如果大家有什么想法可以在 twitter 上通过@adactio 找到我。有时候我也会在自己的博客，adactio.com 上写写有关这个主题的文章。最后，可能还要顺便给我自己做个广告，我刚出了一本书，希望大家关注。</p><p>非常感谢大家。<br>[全文完]</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">不清楚博主的这篇翻译文章为什么没了，但原翻译者应该是他没错，这里只进行一下整理<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">1992 年，大卫·克拉克（David Clark）教授在 IETF 会议上总结了这样一句话“We reject: kings, presidents, and voting. We believe in: rough consensus and running code”（我们拒绝国王、总统和投票，我们相信大多数人的意见和运行的代码）。这就是广为流传的“互联网哲学”（Internet Philosophy）。——译者注<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;之所以取个这么大的标题，是因为这是一篇翻译稿的标题。个人认为这篇演讲的翻译稿</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在计算机学习中，为什么我们应该问为什么</title>
    <link href="http://starding.github.io/2016/03/18/why-should-we-ask-why/"/>
    <id>http://starding.github.io/2016/03/18/why-should-we-ask-why/</id>
    <published>2016-03-18T02:23:14.000Z</published>
    <updated>2024-02-24T02:29:35.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在使用 bootstrap 的时候，遇到一个下拉菜单（dropdown menu）的设计问题。bootstrap 默认的下拉菜单组件是使用 list 作为 html 基础完成的，而不是<code>&lt;select&gt;&lt;/select&gt;</code>。我想这背后一定有设计者的意图，但是对于刚入门前端的我来说很难考究。不过问了一些人之后，发现似乎并没有关注这些实现背后的设计意图问题。</p><p>在之前的一篇博客——<a href="">open questions</a>中，提过一个问题，大意是说在计算机领域，为什么我们要去追问一件事情的动机。最近在学习前端的时候，对这个问题有了更深一步的体会，所以开始将这个问题单独提出来进行阐述。</p><h2 id="科学哲学中的「四因说」"><a href="#科学哲学中的「四因说」" class="headerlink" title="科学哲学中的「四因说」"></a>科学哲学中的「四因说」</h2><p>早在古希腊时代，就有哲学家开始思索事物的本质了。有一个很有名的哲学家提出了一些解释事物运动与变化的论点，其核心思想也就是标题中所描述的<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%9B%A0%E8%AA%AA">「四因说」</a>。当然，如你所料，这位哲学家的名字叫「亚里士多德」。</p><p>为了省去时间解释「四因说」的概念，摘出吴国盛老师博客：<a href="https://blog.sina.com.cn/s/blog_51fdc06201009s7z.html">海德格尔的技术哲思</a>中的几段话来稍作说明，当然你也可以参考英文版的维基百科词条，或者是更专业的科哲书籍：</p><blockquote><p>导致一个物出现的东西被称为该物的原因。亚里士多德曾经主张原因有四种，即「质料因」、「形式因」、「目的因」和「动力因」。比如造一顶皇冠，金子是它的质料因；皇冠的形状是它的形式因；皇帝用来举行大典、显示威仪和华贵是它的目的因；工匠汇总各方面的要求和准备并发挥自己的作用从而最终将皇冠拿出来，工匠是它的动力因。</p><p>今日我们对这四因说不是太理解，不知道为什么要提出四种原因，更不知道为什么单单提出这四种原因。因为当我们说到“原因”时，指的往往只是那直接产生作用并造成和带来最终结果的东西，也就只是亚里士多德意义上的动力因（也可以称之为「直推因」 ——引用注）。皇冠作为被造出来的结果，在我们今天看来，工匠是其唯一的原因。</p><p> 动力因成为四因中起决定作用的方面，并最终决定了对因果性的规定。这件事情发生在 16、17 世纪之后 (也就是机械自然观开始成型的那些年 ——引用注)，非同寻常，里面包含着近代思想对于目的因的排除。一个物的出现被描述为另一个早先的物加上某个作用力的结果，物在某种意义上成了现成的东西，即所谓“物质”。物不再“出现”（coming to），它根本就在场，恒久的在场。因果性说的也不再是那种使物“出现”的东西，而是根本上在场的物质的在数量方面的变化。<br> 这种对因果性的规定使我们无法理解希腊人的四因说，特别是，使我们对希腊人四因说中的动力因的理解打上我们时代的烙印：对物产生作用，使其发生改变。但是那种希腊意义上四因之间的内在联系就完全丢失了。海德格尔提醒说，对工具之本质的理解依赖于对因果性之本质的理解，而对因果性的本质我们至今还茫然无知，这一茫然无知特别表现在我们对希腊四因说的误解</p></blockquote><p>上面的吴老师的文字，基本上已经很清楚的解释了什么是「四因说」以及为什么在今天我们提到一件事情的「原因」时，我们暗示的语境是「一个原因（cause）」而不是「四个原因（cause）」。这是因为 16，17 世纪发生的自然观的范式转变造成的，这些转变把四因说中的「动力因」（也可以说是直推因）当成事物变化的首要因素，以及「四因说」中的其他几个原因被淡化了。</p><h2 id="动力因（直推因）——-传统自然科学探究的有效方式"><a href="#动力因（直推因）——-传统自然科学探究的有效方式" class="headerlink" title="动力因（直推因）—— 传统自然科学探究的有效方式"></a>动力因（直推因）—— 传统自然科学探究的有效方式</h2><p>在传统科学中，我们说一件事情的原因的时候，往往指的就是它的直推因。比如曾经在知乎上回答的一个问题：<a href="https://www.zhihu.com/question/30546364/answer/50020320">为啥乙醇没毒，而甲丙丁醇都有毒？</a></p><p>然后可以观察下面的答案，得票最高的答案描述了醇类的分子结构以及相应的化学性质，不同醇类在人类体内所产生的不同影响，并且给出了相当专业的答案。从这种角度出来，所阐述的就是「醇类毒性的直推因」。也就说「当前是什么样」。</p><p>在科学革命之后，上述回答中体现出的思想一直是自然科学研究的指导思想。这种追问「直推因」的研究模式有非常巨大的优势：它可以引导人类先将那些最根本的追问放到一旁，集中精力研究在当前阶段下能研究的东西，对于不能研究的或者研究暂时够不着的地方保持沉默。比如研究物体的运动，最直接的是去研究推动物体的力，研究在不同力的作用下，产生的不同效果。同时将牛顿所讲的第一推动力放到一旁，暂时不予考虑。正是这样按照一种内在的逻辑精密的步步前行，不断积累，并且如我们所见，这种研究形式取得了重大的成果。</p><p>但是这并没有给「我们的期待」一个显得更更本质的解释：对，这个答案说的是非常准确，非常符合人类目前掌握的生理化学知识，但是仍然可以在这个基础上问一句，为什么是这样？是什么原因造成了生理化学上的这种现状？</p><h2 id="目的因-——-我们的期待"><a href="#目的因-——-我们的期待" class="headerlink" title="目的因 —— 我们的期待"></a>目的因 —— 我们的期待</h2><p>正如上面小结结尾所提出的问题，我们人类心理上总是想要一种「更为本质」的解释，而且有些偏执的认为这种「更为本质的解释应该存在」，虽然目前来看很多都只是「因果关系上的错觉」。这一点在达尔文的进化论中表现的更为明显，正如我在：为啥乙醇没毒，而甲丙丁醇都有毒？问题下的回答。</p><blockquote><p>这题明显是一个生理学加进化论的问题，一旦牵扯到进化论，「因果关系」就会变得微妙起来。</p><p>我们说一件事物「有毒」的时候，是暗含着语境的——对生物来说。甲乙丙丁醇，结构相似，为什么乙醇毒性最小？从生理化学方面回答，只能回答出这种毒性表现「是什么」，从因果关系上讲，这样推理找到的是“有毒”的「直推因」。</p><p>「直推因」是指与所要研究的事情本身最直接的原因。探寻直推因也是物理和化学中最常见的研究形式。这个来历与十六七世纪发生的科学革命有很大关系，具体情况比较复杂，这里不细说。</p><p>但是在生物学上，只研究直推因，能很好的说明“表现为什么样，是什么样”，但并不能很好的说明“为什么是这样”。在回答「是什么样」的时候，生理化学做的很好了。至于「为什么这样」，只能求助于进化论。</p><p>大胆的猜测就是因为：乙醇在自然条件下更容易出现 (至于为什么更容易出现，又是另一个问题了)，生命接触乙醇的机会比其他醇类多。这样就导致了生命对于乙醇的不敏感。</p><p>至于证据问题，只能说这个猜测和进化论的逻辑是相符合的。如果要拿出具体的数据很难。</p><p>这个答案的正确性暂且不论，而且关于进化论中令人头疼的因果关系也姑且不去考虑，我想说的就是即便是上面这样的「半吊子目的因答案」也会给我们一种：『吖，就是这样！』的感觉，仿佛满足了我们灵魂最深处的某种渴望一样。</p><p>其实这就是「目的因」的魅力——它满足我们人类某种对真相的神秘渴求。即便有时候这种目的因是虚妄的。</p></blockquote><h2 id="计算机科学中的「目的因」"><a href="#计算机科学中的「目的因」" class="headerlink" title="计算机科学中的「目的因」"></a>计算机科学中的「目的因」</h2><p>上面讲述了传统自然科学中的研究或者学习方式。但是对于计算机科学来说却不是这样。在自然界内，各种事物都是独立于人类存在的，多数事物更是早早先于人类就存在无数年头了，我们很难甚至可以说基本没有办法追溯回去，看看当初事物出现时的样子，以及在自然界这个复杂系统中所处的位置。</p><p>但在计算机领域内却大不一样，有非常多的内容是「人类创造的」，这些内容出于某些动机而构建出来，非常符合人类的直觉——这么干，背后肯定有一种「更为本质的原因」，而这种本质的原因，就是创造者的目的和意图。</p><p>这些现象基本上可以推广到所有与人造事物有关的事物上去。我们设计或者创造一种事物，都是有着某种根植于当时环境的目的在里面的。以一个普通桌子椅子为例，每一种设计，都有创造者背后想要表达的目的，它们都不是凭空出现的，而是伴生着创造者所种下的意向而来。有折叠的椅子，那设计师考虑的可能是节省空间，有纯榫卯的椅子，那可能是创造者为了自然环保，或者追溯往日的情怀。</p><p>在计算机领域，我们同样应该追问一件事情的「目的因」，也就是这件事物背后创造者的初衷。通过追问这些初衷可以更加了解一件事物内在的意向，以及深化对于这件事物的认识。比如设计模式，为什么要有这些设计模式，有没有其他的？当我们了解到这些之后，就会意识到这些东西不是铁板一块，进而解放我们的创造力。</p><h2 id="前端领域"><a href="#前端领域" class="headerlink" title="前端领域"></a>前端领域</h2><p>在前端领域更是如此，前端纯粹是人类建构出来的，我们可以追问许多东西，比如 html5 的作用是什么？为什么提出 html5，提出者们是怎么考虑的？</p><p>通过这些追问，可以让我们根据问题回溯到设计者的意图上去，了解初衷，从而产生更深入的理解以及对未来的把握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;最近在使用 bootstrap 的时候，遇到一个下拉菜单（dropdown </summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>隐喻</title>
    <link href="http://starding.github.io/2016/02/26/metaphor/"/>
    <id>http://starding.github.io/2016/02/26/metaphor/</id>
    <published>2016-02-26T02:13:33.000Z</published>
    <updated>2024-02-24T02:18:18.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h2><h3 id="为什么明确概念如此重要"><a href="#为什么明确概念如此重要" class="headerlink" title="为什么明确概念如此重要"></a>为什么明确概念如此重要</h3><p>在美剧中，我们常常能见到演员们提及或使用「隐喻」这种修辞手法，而且模糊的知道这种修辞和「类比」相似，但是缺少对这种修辞的清晰认知。实际上，我们平时日常交谈时，常常会无意识的使用到这种修辞，而造成这种无意识的原因是我们对「隐喻」没有一个明确的概念。</p><p>不止隐喻是这样，在日常生活中，常常会遇到这样的情景：在你明确一件事物的概念之前，即使这件事物在身边常常见到，你也不会过多的去留意它，这个时候对这件事物的认知，就处于一种「无意识」的状态，而你一旦掌握了这样事物的概念之后，就会脱离那种混沌的无意识状态，转而开始有意的留意身边的这些事物，就会吃惊的发现，啊，原来它早已存在。</p><p>用一个比较哲学的说法，这叫「有之非有，存在的无」。人类根据经验在语言上建立起一种事物的概念，然后这个语言学上的概念，反过来又会促进人类更加留意对应的事物，最终加深对概念和事物更深刻的认识。</p><p>在《写给大家看的设计书》中，作者开篇就写了约书亚树的例子。</p><blockquote><p>约书亚树</p><p>很多年前的一个圣诞节，我收到一份圣诞礼物，是一本关于如何认识各种树的书。那时我住在父母的家里，所有礼物都打开后，我决定出去走走，认一认邻居家的树。出去之前我读了书的一部分。其中提到的第一种树是约书亚树，只需要两个线索就能认出它。由于约书亚树相当怪异，所以看到书中它的照片时，我对自己说：“哦，北加利福尼亚绝对没有这种树。这种树太怪异了。如果我见过，肯定应该有印象，可我以前从来没有见过。”</p><p>之后我拿着这本书走出去。我的父母住在一个小巷子里，这里共有 6 家住户。其中 4 家的前院里都赫然立着约书亚树。我住在那里已经有 13 年了，而我此前从来没有注意过约书亚树。我在这个街区转了转，发现似乎每一家布置新居时苗圃里都有约书亚树卖，至少 80% 的住家前院都种有约书亚树。而我在此之前居然从来没有注意过！在我知道了这种树之后，我是说在我能够说出它的名字后，它就无处不在了。这正是我要说的：一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，使它在你的控制中。</p></blockquote><p>这个例子所讲述的内容并不是特殊的情况，它背后有着关于语言和认知的更深层次的问题。概念是思维的最基本单元，其重要性我们怎样重视都不会过分。现在有一些认知，语言上的方向专门来研究这些问题，而本文就简单介绍「隐喻」的概念，以及讲述在计算机科学中「隐喻」的重要性。</p><p>原本对隐喻的介绍是在其他文章中完成的，但是后来越来越感觉到这个概念的重要性，以至于不得不单独提出来特别讲述一下。就如前面所描述，一旦「隐喻」的概念明确之后，你就会开始摆脱原来的无意识使用状态，有意识地使用这种修辞来表达一些原来难以言状的概念，事物等。而且也会发现，「隐喻」这种修辞随处可见，并且深刻意识到它带来的好处。</p><h3 id="《代码大全》对隐喻的态度"><a href="#《代码大全》对隐喻的态度" class="headerlink" title="《代码大全》对隐喻的态度"></a>《代码大全》对隐喻的态度</h3><p>在《代码大全》中，作者在欢迎章节之后，就开始介绍软件开发中的隐喻，并且强调了隐喻的重要性：</p><blockquote><p>计算机科学领域中有着所有学科中最为丰富多彩的语言。你走进一间安全严密，温度精确控制在 20℃的房间，并在里面发现了病毒（virus），特洛伊木马（Trojan horse），蠕虫（worm），臭虫（bug），逻辑炸弹（bomb），崩溃（crash），论坛口水战（flame），双绞线转换头（twisted sex changer），还有致命错误（fatal error）……在其他领域中，你能遇到这些吗？</p></blockquote><p>这些形象的隐喻描述了软件领域总各种特定的现象和事物，像这样生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻，我们能更深刻的理解软件开发的过程。</p><h2 id="那么什么是隐喻？"><a href="#那么什么是隐喻？" class="headerlink" title="那么什么是隐喻？"></a>那么什么是隐喻？</h2><p>隐喻是比喻的一种，其字面意思是「隐含的比喻」。与普通的比喻，也就是「明喻」相对。</p><p>对比来讲，明喻这种修辞手法在日常用语中是使用最多的比喻形式，例如「貌美如花」，「父爱如山」等。使用「明喻」主要是因为某些审美上的倾向，希望将一种事物上的审美特点添加到另一种事物上，比如上面的词语中，想要将花朵的美好赋予到人类身上，或是将山的厚重，巍峨的特性赋予到父亲身上。</p><p>而「隐喻」则有所不同，它多数不是因为审美上的倾向才使用，而是想要表达出两种事物之间有某种实实在在的联系。比如莎士比亚的著名隐喻：</p><blockquote><p>All the world’s a stage,<br>And all the men and women merely players;<br>They have their exits and their entrances. and one man in his time plays many parts…<br>—William Shakespeare</p><p>世界是舞台，男人和女人都是演员。他们都有下场的时候，也都有上场的时候。一个人的一生中扮演着好几个角色。<br>——莎士比亚</p></blockquote><p>莎士比亚使用这个隐喻，并不是想将舞台和演员某些审美上的特点赋予世界和人类，而是实实在在的认为，世界的运行机制和舞台剧的运行机制，有某些相似点。</p><p>很多人（通常是认知语言学家）认为，「隐喻」这种修辞具有认知学上的意义。换句话说，它可以帮助人类更好的认识一件事物，所使用的手段就是将一种比较新的陌生的概念，与已知的比较容易理解的其他概念联系起来，利用两件事物之间的相似性辅助认知。</p><h2 id="一些例子——那些我们曾注意或不曾注意的隐喻"><a href="#一些例子——那些我们曾注意或不曾注意的隐喻" class="headerlink" title="一些例子——那些我们曾注意或不曾注意的隐喻"></a>一些例子——那些我们曾注意或不曾注意的隐喻</h2><p>在语言中，一种新事物的产生需要一个词汇来命名时，一种手段是在原来有的词汇的基础上进行引申，而这种引申并不是随性而为的，往往是新事物之间和之前的旧事物之间有某些特殊的相似性。</p><p>一些典型的例子：</p><ul><li>socket：原意是插头，插座。在计算机通信传输时，引申为一种信息交互的机制。特点就像是插座那样，有对接的意思。</li><li>docker：原意是码头工人。现在出现了一种常用的虚拟化技术，叫 docker。它同样借助了码头工人，集装箱一类的隐喻，来表达标准化交付的意思。</li><li>待续</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;隐喻&quot;&gt;&lt;a href=&quot;#隐喻&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>问题记录</title>
    <link href="http://starding.github.io/2016/02/25/questions-record/"/>
    <id>http://starding.github.io/2016/02/25/questions-record/</id>
    <published>2016-02-25T01:25:29.000Z</published>
    <updated>2024-02-24T02:07:55.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Meta: 本文章用来记录平时遇到的问题以及相应的解决方案</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="linux-crontab-django-command-定时执行命令"><a href="#linux-crontab-django-command-定时执行命令" class="headerlink" title="linux crontab + django command 定时执行命令"></a>linux crontab + django command 定时执行命令</h3><h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h4><p>在做一个档案管理系统时，有一个需要定时从 DB2 数据库中取出数据，处理之后，存入 mysql 中的任务。这意味着需要在 django 中单独跑一个脚本，这个脚本使用 django 的环境。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>django 提供了一种用户自定义命令来实现这个功能：</p><blockquote><p><a href="https://docs.djangoproject.com/en/1.9/howto/custom-management-commands/">Writing custom django-admin commands¶</a></p></blockquote><p>而 linux 则提供了定时执行任务方面的好用工具：</p><blockquote><p><a href="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/crontab.html">linux crontab</a></p></blockquote><h3 id="往-mysql-中写大量数据时，出现错误：2006‘mysql-server-has-gone-away’"><a href="#往-mysql-中写大量数据时，出现错误：2006‘mysql-server-has-gone-away’" class="headerlink" title="往 mysql 中写大量数据时，出现错误：2006‘mysql server has gone away’"></a>往 mysql 中写大量数据时，出现错误：2006‘mysql server has gone away’</h3><h4 id="问题场景-1"><a href="#问题场景-1" class="headerlink" title="问题场景"></a>问题场景</h4><p>在做一个档案管理系统时，使用 django+mysql，当一次性往 mysql 中写入了近 3w 条数据时，就出现了这个错误</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>调查发现是因为 mysql 默认的有一个写入数据大小限制。只需要在<code>/etc/my.cnf</code>(如果没有这个文件就自己建立一个) 下加上下面的代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">max_allowed_packet = 16M</span><br></pre></td></tr></table></figure><p>当然，也可以限制一下自己每次往 mysql 中写入数据的数量来解决这个问题。</p><h3 id="vim-分屏与-ctrl-p-插件"><a href="#vim-分屏与-ctrl-p-插件" class="headerlink" title="vim 分屏与 ctrl p 插件"></a>vim 分屏与 ctrl p 插件</h3><p>之前总是听说 <code>ctrl p</code> 插件如何如何好用。不过我开始试用的时候，确实没有体会到太强大的地方，知道后来发现 vim 的分屏功能。</p><p>试用 vim 分屏功能，加上 ctrl p 实现了不退出 vim 直接打开多个文件的功能，节省了大量在命令行下各种 cd 目录 的时间。</p><p>参考：<a href="https://coolshell.cn/articles/1679.html">Vim 的分屏功能</a></p><h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><p>有一次，我需要在一个包含很多行短文字的后面补上的空格，将每一行补成相同的宽度。<br>刚开始使用各种列编辑，块编辑尝试都没有用。难道必须写一个程序来专门处理这件事情？</p><p>后来发现正则表达式基本能满足这一要求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">s/$/ n_spaces /g</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">在 vim 中，$符有丰富的含义，这里指的是行尾前一个字符</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前端</span></span></span><br><span class="line">主要记录一下前端学习中遇到的容易混淆的地方，个人感觉在 html，css 和 javascript 中。当属 css 最令人难以捉摸，由于浏览器默认样式或是限制，css 继承，层叠规则等的存在，综合作用之下，很多时候都觉得 css 效果与预期不一致。因此 css 的内容或许会更多一些。</span><br><span class="line">仅仅是零散的记录，暂时没有整理成单独文章的精力。以后或许会把一些可以扩展的地方扩展成文章式的内容。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## CSS 伪类和伪元素区别</span></span></span><br><span class="line">伪类：Pseudo-elements</span><br><span class="line">伪元素：Pseudo-classes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### 概念辨析</span></span></span><br><span class="line">stackoverflows 上的回答</span><br><span class="line">[What is the difference between a pseudo-class and a pseudo-element in CSS?](https://stackoverflow.com/questions/8069973/what-is-the-difference-between-a-pseudo-class-and-a-pseudo-element-in-css)</span><br><span class="line"></span><br><span class="line">W3C 上的说明</span><br><span class="line">[pseudo-elements](https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-elements)</span><br><span class="line">[pseudo-classes](https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-classes)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## CSS font-size 相对大小继承</span></span></span><br><span class="line">font-size 使用 em 等相对大小时，会发生计算叠加。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">摘自《css 设计指南》</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; 一般来说，em 以浏览器默认值为基本单位，也就是 1em=16px。如果你想使用 em，但又需要设定具体的像素大小，可以把 body 的 font-size 设定为 62.5%。这样，就等于把基准大小从 16 像素改为 10 像素 (16×62.5%=10)。然后，em 与像素的对应关系就十分明确了，比如 1em 等于 10 像素，1.5em 等于 15 像素，2em 等于 20 像素，等等。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; p 元素的文本为 12 像素 (body 的 16 像素基准大小×.75=12px), strong 是 p 的子元素，它的文本相对大小会逐层复合，应该是 16px 0.75 0.75=9px。</span></span><br><span class="line"></span><br><span class="line">**注意与 text-indent 的区别：** font-size 会叠加复合计算，text-indent 则是后面的值覆盖前面的值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">text-indent 可以被子元素继承。如果你 在一个 div 上设定了 text-indent 属性，那么 div 中的所有段落都会继承该缩进值。然而，与 所有继承的 CSS 值一样，这个缩进值并不是祖先元素中设定的值，而是计算的值。下面举一个 例子说明。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; 假设有一个 400 像素宽的 div，包含的文本缩进 5%,则缩进的距离是 20 像素 (400 的 5%)。在这个 div 中有一个 200 像素宽的段落。作为子元素，它继承父元素的 text-indent 值，所以 它包含的文本也缩进。但继承的缩进值是多少呢？不是 5%,而是 20 像素。也就是说，子元素 继承的是根据父元素宽度计算得到的缩进值。结果，虽然段落只有父元素一半宽，但其中的文 本也会缩进 20 像素。这样可以确保无论段落多宽，它们的缩进距离都一样。当然，在子元素 上重新设定 text-indent 属性，可以覆盖继承的值。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## inline-block 的表现</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This value causes an element to generate an inline-level block container. The inside of an inline-block is formatted as a block box, and the element itself is formatted as an atomic inline-level box.</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">大致意思就是：inline-block 后的元素创建了一个行级的块容器，该元素内部（内容）被格式化成一个块元素，同时元素本身则被格式化成一个行内元素。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; 直白一点的意思就是：inline-block 的元素既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，比如 inline-block 元素也可以设置 vertical-align 属性。简而言之：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">inline-block 后的元素就是一个格式化为行内元素的块容器 ( Block container )</span></span><br><span class="line"></span><br><span class="line">疑问：</span><br><span class="line"></span><br><span class="line">inline-block 的 margin 边距会撑开父元素的高度，而普通的 block 的边距则会与父元素的 margin 边距重合？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">[inline-block 前世今生](http://ued.taobao.org/blog/2012/08/inline-block/)</span><br><span class="line"></span><br><span class="line">[w3c: the ‘display’ property](https://www.w3.org/TR/CSS2/visuren.html#display-prop)</span><br><span class="line"></span><br><span class="line">[mozilla: vertical-align](https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## rem 使用</span></span></span><br><span class="line">今天在 chrome 中实验 rem 相对单位，刚开始的实验代码为：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;test rem&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">html&#123;</span><br><span class="line">font-size: 62.5%;  // 这里的表现有点奇怪</span><br><span class="line">&#125;</span><br><span class="line">body&#123;</span><br><span class="line">font-size: 1.2rem;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-color: red;</span><br><span class="line">padding: 1rem;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;测试字体大小&lt;/p&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>但是这个时候，font-size 并不是 10px，之前在网上看到将 root 元素的 font-size 设置为 10px，方便后文计算。但是在这里似乎并没有起到效果。</p><p>原因是因为 chrome 默认所允许的最小字体为 12px，如果设定值小于此值，就会被重置成 12px。这个时候，<code>1rem=12px</code>，关于 chrome 最小字体限制，</p><p>参考：<a href="https://banri.me/web/webkit-text-size-adjust.html">Chrome 取消-webkit-text-size-adjust 后的那些事</a></p><h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><ul><li>块级元素（block level element）<ul><li>独占一行</li><li>可设置 width，height</li><li>默认</li></ul></li><li>内联元素（inline element）<ul><li>设置 width height 无效</li></ul></li></ul><p>参考：<a href="https://geekplux.com/posts/several_core_concepts_of_css.html">CSS 最核心的几个概念</a></p><h3 id="width-和-height"><a href="#width-和-height" class="headerlink" title="width 和 height"></a>width 和 height</h3><p>定义元素「内容区」的宽度，默认值为 auto 无继承性。浏览器会计算出实际的宽度。</p><p>height 和 width 实用百分数相对单位时，相对的是父元素宽度计算（父元素的宽度同理）。如果不指定，默认值就是图片本身的宽高，如果图片加载失败，会显示 alt 属性值，或者浏览器自带的加载失败效果。</p><h3 id="各种居中方法的使用场景"><a href="#各种居中方法的使用场景" class="headerlink" title="各种居中方法的使用场景"></a>各种居中方法的使用场景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 水平居中</span><br><span class="line">// 使用 <span class="attribute">margin</span> 水平居中元素的时候，</span><br><span class="line">// 需要指定要居中元素的 <span class="attribute">width</span> 值（与父元素的宽度无关）</span><br><span class="line">// 显然这里只适用于块级元素</span><br><span class="line">// 居中被设置该属性的元素自身，不是子元素，也不是父元素 </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>, auto;   </span><br><span class="line"><span class="attribute">text-align</span>： center</span><br></pre></td></tr></table></figure><h3 id="如果内部盒大小超出了外部盒所能包含的大小时表现会如何"><a href="#如果内部盒大小超出了外部盒所能包含的大小时表现会如何" class="headerlink" title="如果内部盒大小超出了外部盒所能包含的大小时表现会如何"></a>如果内部盒大小超出了外部盒所能包含的大小时表现会如何</h3><h2 id="使用过的工具"><a href="#使用过的工具" class="headerlink" title="使用过的工具"></a>使用过的工具</h2><ul><li>reactjs react router</li><li>underscore</li><li>project-path（npm 模块）</li><li>fixed-data-table（react 组件）</li></ul><h2 id="程序中的过度设计"><a href="#程序中的过度设计" class="headerlink" title="程序中的过度设计"></a>程序中的过度设计</h2><h3 id="什么是程序中的过度设计"><a href="#什么是程序中的过度设计" class="headerlink" title="什么是程序中的过度设计"></a>什么是程序中的过度设计</h3><p>所谓过度设计或者过度工程，顾名思义就是在编写代码的时候，过多的假想了一些本来不存在的场景，并且在这些假想的场景中做出对应的设计，比如处处考虑将来可能出现的变动等等。而实际上，这个时候代码离考虑这些还有很远的距离。</p><h3 id="我遇到的过度设计"><a href="#我遇到的过度设计" class="headerlink" title="我遇到的过度设计"></a>我遇到的过度设计</h3><p>在之前开发产品的时候，实际上在有些地方过度强调了将来可能面临的风险或变动，比如产品中的图片采用 qiniu 云存储，刚开始存储的统一都是 url，但是这时候工程师假想了一个场景：「如果将来七牛的域名改变了，或者将来不适用七牛了怎么办？」然后将原来的统一 url 改为 key，但是发现实际的改写操作并不是一件容易的事情，最后只好作罢。</p><p>另一件事情则是产品中的过度设计，在我们开发一个产品的时候，产品经理给出的产品原型变动了无数次，最后的一些变动甚至改变了最基本的数据信息，导致之前写的代码完全失效。而这个产品正是一个需要快速迭代的产品，直到现在第一版还没有做出来。其实这个例子不能算是过度设计，姑且写在这里吧。</p><p>不清楚经常强调 mvp(minimum viable product，最小化可行产品) 的我们，为何在做自己的产品的时候，却完全不予考虑了。</p><p>当然对于编程经验还不够丰富的我来说，考虑这些还为时尚早，暂且先记录下来，以待将来反思。</p><h2 id="产品体验"><a href="#产品体验" class="headerlink" title="产品体验"></a>产品体验</h2><h3 id="iOS-初体验"><a href="#iOS-初体验" class="headerlink" title="iOS 初体验"></a>iOS 初体验</h3><p>最近服役了三年的 nexus 终于老态龙钟，光荣退伍了。纠结于 android 的多种多样，最终直接选了 iphone。一上手就感觉有几个地方特别的别扭，这里面自然有一些不同系统之前切换带来的生疏感，但是有些地方明显是设计有问题。</p><h4 id="鸡肋的下拉菜单"><a href="#鸡肋的下拉菜单" class="headerlink" title="鸡肋的下拉菜单"></a>鸡肋的下拉菜单</h4><p>对比 Android 强大的下拉菜单，iOS 的下拉菜单仅用于消息通知或是近期使用的软件功能，而将一部分设置放在了从底部向上拉的菜单中，即便是这些设置也是不完整的，比如 wifi 设置，只能设定开关，而不能由此作为入口进一步设置 wifi。如果想设置 wifi 需要去设置页中去找。</p><p>再来看 Android 的下拉菜单设置，不管是 wifi 还是手电筒等功能，都无比的实用与方便，而且使用频率很高。</p><h4 id="捉急的闹钟设置"><a href="#捉急的闹钟设置" class="headerlink" title="捉急的闹钟设置"></a>捉急的闹钟设置</h4><p>这个就更明显了，android 的闹钟设置一步到位。而 iOS 的闹钟设置页面，要先点击左上角的编辑，进入编辑页，再点击时间才能选择。一步能完成的功能愣是给拆成了好几个步骤。用的时候简直无比纠结。</p><h4 id="难以捉摸的输入法和全局赋值粘贴"><a href="#难以捉摸的输入法和全局赋值粘贴" class="headerlink" title="难以捉摸的输入法和全局赋值粘贴"></a>难以捉摸的输入法和全局赋值粘贴</h4><p>九宫格输入法中的各个按键占比无比蛋疼，主要区域占比不够，而一个大大的确认按钮放在了右侧，占据了 n 多面积。</p><p>再者是输入法和全局复制粘贴的表现简直匪夷所思，它们的各种表现简直难以寻找规律。感觉一会儿是这样，一会儿是那样。</p><h4 id="没有充分利用触屏优势的短信界面"><a href="#没有充分利用触屏优势的短信界面" class="headerlink" title="没有充分利用触屏优势的短信界面"></a>没有充分利用触屏优势的短信界面</h4><p>ios 短信界面的编辑功能，仍然是左上角有一个编辑按钮，点击之后才能进行编辑。而触摸短信只能进入短信详情，长触摸则没有响应动作。</p><p>「编辑按钮」这个功能在 iOS 中随处可见，诸如上面提到的闹钟编辑。这和 Android 有很大的区别，在 Android 中，长触摸一般都表示对触摸项的编辑功能。而 iOS 则没有为长触摸指定动作。这样就又多出一步。实在是没有充分利用触屏本身的交互优势。</p><h3 id="厨房里的酱油瓶"><a href="#厨房里的酱油瓶" class="headerlink" title="厨房里的酱油瓶"></a>厨房里的酱油瓶</h3><p>有一种酱油叫海天，有着一个无比蛋疼的封口设计。打开瓶盖，拉开拉环，倒出香醇的酱油后，你会发现，瓶盖合不上了！酱油这种长期使用产品，不清楚这种汽水拉环一样的一次性设计是为了什么。</p><p>而对比厨房里的另一瓶调料——白醋，就明显看出设计上的差距。白醋有一个方便拧开的大瓶盖，为了方便控制倒醋时的流速，还在内部加了一个控制流速的狭缝，可谓方便至极。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Meta: 本文章用来记录平时遇到的问题以及相应的解决方案&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 犀牛书（第六版）</title>
    <link href="http://starding.github.io/2016/01/19/learn-javascript-follow-definitive-guide/"/>
    <id>http://starding.github.io/2016/01/19/learn-javascript-follow-definitive-guide/</id>
    <published>2016-01-19T05:01:58.000Z</published>
    <updated>2024-02-21T05:11:23.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录阅读《javascript 权威指南》中，个人认为比较核心或是比较容易混乱的地方。<br>同时会加入在阅读过程中参阅的一些优秀的扩展文章。</p><p><strong>更新记录</strong></p><blockquote><p>2016-01-18 更新到 try-except-finally 语句<br>2016-04-07 文章改名。将文章结构分为核心和模糊点</p></blockquote><p><strong>我认为书中的核心部分</strong></p><blockquote><ol><li>语言核心部分</li><li>变量类型</li><li>strict 模式</li><li>词法作用域、函数，闭包、this、call、apply、bind</li><li>原型系统</li></ol></blockquote><h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><h3 id="语言核心"><a href="#语言核心" class="headerlink" title="语言核心"></a>语言核心</h3><h4 id="变量及变量类型"><a href="#变量及变量类型" class="headerlink" title="变量及变量类型"></a>变量及变量类型</h4><p>javascript 中的变量本身没有类型，给一个变量赋值时，其实是这个变量引用了这个值。这根 python 中是一致的。 </p><p>他们都区别于 C 语言等固定类型的变量，在 C 语言中，当声明一个变量时，需要指定它的类型，这个变量其实就是一个固定大小的空间，直接用于存放变量的值。数组也是一样，一个数组只能存储同样类型的值，C 语言需要根据类型决定如何分配内存大小，比如 int 是 4 个字节。</p><p>而 javascript 和 Python 中，无需声明变量类型。变量只是对数据的引用，而类型是数据本身决定的，这个变量引用了什么类型，这个变量就是什么类型，javascript 中的数据类型分为两类（貌似是借鉴了 java）:</p><h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><ul><li>原始类型 primitive type（5 种）<ul><li>数字</li><li>字符串</li><li>布尔值</li><li>null</li><li>undefined</li></ul></li></ul><p><strong>注意：</strong>原始类型不是对象，但你可能会见过 APrimitiveType.method 的调用形式，这是因为数字，字符串，布尔值存在「包装对象」这个概念。</p><h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><ul><li>对象类型（object）（除了 5 种原始类型的数据类型，都是对象类型）<ul><li>普通对象（名值对对象）</li><li>数组</li><li>函数 - javascript 可以将 function 对象当做普通对象对待</li></ul></li></ul><h4 id="严格模式：use-strict"><a href="#严格模式：use-strict" class="headerlink" title="严格模式：use strict"></a>严格模式：use strict</h4><p>如果你了解一些 javascript 的历史，就会清楚 javascript 是 Brendan Eich 花了十天时间设计出来的，主要参考了 Scheme，Self，C，Java 等语言。虽然有现成的语言可以借鉴，但是在如此短的时间内，想要完成一个非常严格的设计是不太现实的。因此 Javascript 本身在设计之初就带有一些隐藏的缺陷。再加上浏览器大战时的迅速推广，这些缺陷没有足够的时间得到修正，便开始成为标准。所以使得这些缺陷一直保留了下来。</p><p>关于这些缺陷，可以简单参考阮一峰的文章：<a href="https://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html">javascript 的十个设计缺陷</a>，以及书籍：《javascript: the good parts》</p><p>use strict 其实是 ECMAscript 5 中加入的指令，非常接近于语句，但又有所区分：不包含关键字，只是个字符串字面量，而且只能出现在特定的位置。</p><p>use strict 的目的是使其后的代码使用 js 的「严格模式」执行，它是 js 的一个子集，修正了一些语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式与非严格模式有一些重要的区别。</p><ul><li>严格模式中不能使用 with 语句</li><li>严格模式中变量都要先 var 声明（非严格模式不声明使用会给全局对象添加一个新属性）</li><li>严格模式中，函数调用时 this 值为 undefined，而不是全局对象。</li></ul><h2 id="模糊点"><a href="#模糊点" class="headerlink" title="模糊点"></a>模糊点</h2><h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>原始类型不是对象，但你可能会见过 APrimitiveType.method 的调用形式，这是因为数字，字符串，布尔值存在「包装对象」这个概念。也就是说，档使用上面的。运算时，javascript 会自动调用 new String(s) | new Number(s) | new Boolean(s) 的方式将这三种基本类型临时转换为对象，并继承相应类型的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个经典的例子</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">s.<span class="property">len</span> = <span class="number">4</span>;  <span class="comment">//因为点运算，这里会临时建立一个 string 对象，但是随即又销毁了</span></span><br><span class="line"><span class="keyword">var</span> t = s.<span class="property">len</span>; <span class="comment">//这里也会创建一个 string 对象，但是已经不是上面那个了，故 undefined</span></span><br></pre></td></tr></table></figure><ul><li>null 和 undefined 没有包装对象</li><li>可以使用构造函数显式地构造包装对象。</li></ul><h3 id="变量声明提前和变量可配置性"><a href="#变量声明提前和变量可配置性" class="headerlink" title="变量声明提前和变量可配置性"></a>变量声明提前和变量可配置性</h3><ul><li>声明提前<ul><li>指的是 var 声明变量时，会提前到其所在作用域的顶部</li></ul></li><li>可配置性<ul><li>全局变量是全局对象的属性，但局部变量没有此规定</li><li>var 声明的全局变量是不可配置的，无法通过 delete 运算符删除</li></ul></li></ul><h3 id="eval-运算符"><a href="#eval-运算符" class="headerlink" title="eval 运算符"></a>eval 运算符</h3><p>eval() 实际上是个函数，但它早已被当成运算符看待。ECMAscript 会尽量约束 eval() 的表现，使其看起来像个表达式。</p><p>这是因为如果将 eval 当做普通的函数对待，不做任何限制的话，会有很多缺点。一是因为 eval() 会动态的执行代码段，破坏原来的代码结构，解释器难以优化。二是因为如果 eval 是普通的函数，那么它就可以被赋值给其他的变量名，比如 g &#x3D; eval, 这样导致任何使用 g 的地方，也会产生上述问题，导致 javascript 的代码优化变得困难，性能堪忧。</p><p>综上所述，如果 eval 的表现行为像一个运算符的话，就不会有上述这么严重的问题。所以在 ECMAscript 语法中不断的约束它，让其表现更接近为运算符。</p><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>主要用于配合 continue 和 break 使用，来实现更灵活一些的跳转。</p><h3 id="throw-try-catch-finally-语句"><a href="#throw-try-catch-finally-语句" class="headerlink" title="throw&#x2F;try&#x2F;catch&#x2F;finally 语句"></a>throw&#x2F;try&#x2F;catch&#x2F;finally 语句</h3><p>之前写过一篇<a href="">那些年我在 python 中扑过的街</a>，在其中提到过 python 中，try&#x2F;except&#x2F;finally 中容易进的坑。</p><p>这个坑在 javascript 中也是同样的，就像那篇文章里说的那样，因为 finally 的设计目的就是无论如何都会执行，那么一旦 finally 中出现了跳转语句，其他语句中的返回内容就会被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">finallyTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;catch&#x27;</span>, y = <span class="string">&#x27;except&#x27;</span>, z = <span class="string">&#x27;finally&#x27;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k = x + y;</span><br><span class="line">        a = b;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;here is try------------&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;here is catch----------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;here is finally---------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="title function_">finallyTest</span>()</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line">here is <span class="keyword">catch</span>----------</span><br><span class="line">here is <span class="keyword">finally</span>---------</span><br><span class="line"><span class="string">&#x27;finally&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接声明函数是具有函数名的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">foo.<span class="property">name</span>  <span class="comment">// 函数名为 foo</span></span><br><span class="line"><span class="keyword">var</span> bar = foo</span><br><span class="line">bar.<span class="property">name</span>  <span class="comment">// 将函数赋值给一个变量，只是让变量指向了函数结构，并不会改变函数结构本身</span></span><br><span class="line"><span class="comment">// 函数表达式生成的是匿名函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">foo.<span class="property">name</span> <span class="comment">// &quot;&quot; (空字符串)</span></span><br><span class="line"><span class="comment">// 函数名称只存在于函数自身结构内，被传递时不会改变这个结构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o =&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">bar</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line">o.<span class="property">bar</span>.<span class="property">name</span> <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><h3 id="this-引用丢失"><a href="#this-引用丢失" class="headerlink" title="this 引用丢失"></a>this 引用丢失</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数被多次传递时可能发生</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;oops, global&quot;</span>;</span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">//&quot;oops, global&quot;</span></span><br><span class="line"><span class="comment">// 回调函数中可能发生（异步）</span></span><br><span class="line"><span class="comment">// 代码同上</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">100</span>); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;记录阅读《javascript 权威指南》中，个人认为比较核心或是比较容易混</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>docker-gitlab 数据迁移</title>
    <link href="http://starding.github.io/2016/01/18/gitlab-migrate/"/>
    <id>http://starding.github.io/2016/01/18/gitlab-migrate/</id>
    <published>2016-01-18T01:22:59.000Z</published>
    <updated>2024-02-21T05:12:05.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题来源：docker-的-file-system-神坑"><a href="#问题来源：docker-的-file-system-神坑" class="headerlink" title="问题来源：docker 的 file system 神坑"></a>问题来源：docker 的 file system 神坑</h2><p>我们的 gitlab 是使用 docker 部署的，方便快捷。</p><p>但是后来服务器上的某个应用出现了内存泄露，没想到重启服务器之后整个 docker 就跪了，启动容器时总是遇到一系列比较底层的 filesystem unkown 错误，而且报错细节不止一种。调查之后，发现是 docker 使用的 devicemapper 出现了 bug，而且查看 docker 官方的 github，有不少人遇到这个 bug，讨论话题在此：<a href="https://github.com/moby/moby/issues/4036">docker fails to mount the block device for the container on devicemapper</a>，感觉掉到一个深不见底的神坑里了。</p><p>stackoverflow 或 github 上给出的解决办法是：关掉 docker，删除&#x2F;var&#x2F;lib&#x2F;docker 中的所有内容，然后重启 gilab。我觉得可能是另一个神坑，没敢往里跳。于是选择慢慢研究这个问题，先在另外一台服务器上重新部署一下 gitlab，并且把数据迁移过去就行了。</p><h2 id="gitlab-数据迁移"><a href="#gitlab-数据迁移" class="headerlink" title="gitlab 数据迁移"></a>gitlab 数据迁移</h2><p>原以为迁移会很简单，没想到也有不少坑等着跳。</p><p>先把原服务器上的 gitlab 的 volumes 备份了一下，直接把备份好的 volumes 文件拷贝到新服务器上，按照原来的方法挂载，启动。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>首先发现是 redis 啥啥没有权限，于是 google 了一番，把权限都改了。<br>然后出了一个 unfoudmethod 错误。调查是<a href="https://gitlab.com/gitlab-org/gitlab-foss/-/commit/ff98c631c1004247656677568989e5ed68fc88f3">数据库没有 migrate</a> 的造成的。</p><p>还有一个隐藏的坑是 gitlab 的版本问题。类似的关键服务应用，尽量不要使用 latest 作为版本号，不然出了问题，还得去找自己使用的究竟是什么版本，如果找不到…准备拼人品吧。</p><h3 id="最终的解决办法"><a href="#最终的解决办法" class="headerlink" title="最终的解决办法"></a>最终的解决办法</h3><p>感觉这么一个一个坑的跳太二了，后来发现原来已经有人把坑都填好了：<a href="https://cmanios.wordpress.com/2015/12/04/migrate-a-gitlab-docker-container-from-version-8-0-4-to-8-2-0/">Migrate a Gitlab Docker container from version 8.0.4 to 8.2.0</a></p><h2 id="附录：下面是原文（已翻译）"><a href="#附录：下面是原文（已翻译）" class="headerlink" title="附录：下面是原文（已翻译）"></a>附录：下面是原文（已翻译）</h2><p>前几天，我需要将 docker 部署的 gitlab 实例从 8.04 版迁移到 8.2.0 版本。我完全是按照 Gitlab Docker 镜像文档中的步骤进行的，但是出了一堆问题，简直日了狗。不过谢天谢地，在经过数小时的搜索挣扎之后，我终于搞定了。</p><p>在本教程中，假定 Gitlab 的 volumes 存储在 &#x2F;home&#x2F;bob&#x2F;docker-data&#x2F;gitlab 目录中 (当然，你需要根据你的实际目录结构来适当改写本教程)。然后下面是我成功迁移 gitlab 时遵循的所有步骤：</p><h3 id="1-停止-Gitlab-容器"><a href="#1-停止-Gitlab-容器" class="headerlink" title="1.停止 Gitlab 容器"></a>1.停止 Gitlab 容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop gitlab</span><br></pre></td></tr></table></figure><h3 id="2-备份所有-Docker-Volumes-所有的-gitlab-文件"><a href="#2-备份所有-Docker-Volumes-所有的-gitlab-文件" class="headerlink" title="2.备份所有 Docker Volumes (所有的 gitlab 文件)"></a>2.备份所有 Docker Volumes (所有的 gitlab 文件)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backupDate=$(<span class="built_in">date</span> +<span class="string">&quot;%Y%m%d%H%M%S&quot;</span>) \</span><br><span class="line">  &amp;&amp; <span class="built_in">cd</span> /home/bob/docker-data/ \</span><br><span class="line">  &amp;&amp; sudo tar zvcf gitlab-data-<span class="variable">$&#123;backupDate&#125;</span>.tar.gz gitlab/</span><br></pre></td></tr></table></figure><h3 id="3-备份-gitlab-镜像（可选）"><a href="#3-备份-gitlab-镜像（可选）" class="headerlink" title="3.备份 gitlab 镜像（可选）"></a>3.备份 gitlab 镜像（可选）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o /home/bob/gitlab-ce-image.tar gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><h3 id="4-删除-gitlab-容器-译注：如果你是把数据迁到其他服务器的-docker-gitlab-实例下的话，本步骤可选"><a href="#4-删除-gitlab-容器-译注：如果你是把数据迁到其他服务器的-docker-gitlab-实例下的话，本步骤可选" class="headerlink" title="4.删除 gitlab 容器 ( 译注：如果你是把数据迁到其他服务器的 docker gitlab 实例下的话，本步骤可选)"></a>4.删除 gitlab 容器 ( 译注：如果你是把数据迁到其他服务器的 docker gitlab 实例下的话，本步骤可选)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> gitlab</span><br></pre></td></tr></table></figure><h3 id="5-拉取最新的-gitlab-镜像"><a href="#5-拉取最新的-gitlab-镜像" class="headerlink" title="5.拉取最新的 gitlab 镜像"></a>5.拉取最新的 gitlab 镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><h3 id="6-拉取完毕后，创建并运行容器"><a href="#6-拉取完毕后，创建并运行容器" class="headerlink" title="6.拉取完毕后，创建并运行容器"></a>6.拉取完毕后，创建并运行容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --hostname 192.168.1.1 \</span><br><span class="line">  --publish 8443:443 --publish 8082:80 --publish 2224:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume /etc/localtime:/etc/localtime \</span><br><span class="line">  --volume /home/bob/docker-data/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume /home/bob/docker-data/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume /home/bob/docker-data/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><h3 id="7-容器启动后，观察运行日志："><a href="#7-容器启动后，观察运行日志：" class="headerlink" title="7.容器启动后，观察运行日志："></a>7.容器启动后，观察运行日志：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f --<span class="built_in">tail</span> 10 gitlab</span><br></pre></td></tr></table></figure><p>日志内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[2015-11-26T15:12:26+02:00] INFO: Retrying execution of execute[create gitlab database user], 19 attempt(s) left</span><br><span class="line">[2015-11-26T15:12:28+02:00] INFO: Retrying execution of execute[create gitlab database user], 18 attempt(s) left</span><br><span class="line">... (some lines omitted) ...</span><br><span class="line">[2015-11-26T15:13:09+02:00] INFO: Retrying execution of execute[create gitlab database user], 0 attempt(s) left</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Error executing action `run` on resource &#x27;execute[create gitlab database user]&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Mixlib::ShellOut::ShellCommandFailed</span><br><span class="line"> </span><br><span class="line">Expected process to exit with [0], but received &#x27;2&#x27;</span><br><span class="line">---- Begin output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &quot;CREATE USER gitlab&quot; ----</span><br><span class="line">STDOUT: </span><br><span class="line">STDERR: psql: could not connect to server: No such file or directory</span><br><span class="line">Is the server running locally and accepting</span><br><span class="line">connections on Unix domain socket &quot;/var/opt/gitlab/postgresql/.s.PGSQL.5432&quot;?</span><br><span class="line">---- End output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &quot;CREATE USER gitlab&quot; ----</span><br><span class="line">Ran /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &quot;CREATE USER gitlab&quot; returned 2</span><br><span class="line"> </span><br><span class="line">Resource Declaration:</span><br><span class="line"> </span><br><span class="line"># In /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb</span><br><span class="line"> </span><br><span class="line">153:   execute &quot;create #&#123;sql_user&#125; database user&quot; do</span><br><span class="line">154:     command &quot;#&#123;bin_dir&#125;/psql --port #&#123;pg_port&#125; -h #&#123;postgresql_socket_dir&#125; -d template1 -c \&quot;CREATE USER #&#123;sql_user&#125;\&quot;&quot;</span><br><span class="line">155:     user postgresql_user</span><br><span class="line">156:     # Added retries to give the service time to start on slower systems</span><br><span class="line">157:     retries 20</span><br><span class="line">158:     not_if &#123; !pg_helper.is_running? || pg_helper.user_exists?(sql_user) &#125;</span><br><span class="line">159:   end</span><br><span class="line">160: </span><br><span class="line"> </span><br><span class="line">Compiled Resource:</span><br><span class="line"> </span><br><span class="line"># Declared in /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb:153:in `block in from_file&#x27;</span><br><span class="line"> </span><br><span class="line">execute(&quot;create gitlab database user&quot;) do</span><br><span class="line">action [:run]</span><br><span class="line">retries 20</span><br><span class="line">retry_delay 2</span><br><span class="line">default_guard_interpreter :execute</span><br><span class="line">command &quot;/opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c \&quot;CREATE USER gitlab\&quot;&quot;</span><br><span class="line">backup 5</span><br><span class="line">returns 0</span><br><span class="line">user &quot;gitlab-psql&quot;</span><br><span class="line">declared_type :execute</span><br><span class="line">cookbook_name &quot;gitlab&quot;</span><br><span class="line">recipe_name &quot;postgresql&quot;</span><br><span class="line">not_if &#123; #code block &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>有两个已知的权限问题，在 <a href="https://docs.gitlab.com/omnibus/docker/">official documentation</a> 和 <a href="https://github.com/gitlabhq/gitlabhq/issues/9611">#9611</a> 中描述。为了解决这两个问题，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab update-permissions</span><br><span class="line">docker <span class="built_in">exec</span> gitlab <span class="built_in">chown</span> -R gitlab-redis /var/opt/gitlab/redis</span><br></pre></td></tr></table></figure><p>然后重启 gitlab 容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure><h3 id="8-然后我们需要检查数据库迁移是否成功以及避免-3255-问题。"><a href="#8-然后我们需要检查数据库迁移是否成功以及避免-3255-问题。" class="headerlink" title="8.然后我们需要检查数据库迁移是否成功以及避免#3255 问题。"></a>8.然后我们需要检查数据库迁移是否成功以及避免#3255 问题。</h3><p>登录到 gitlab 容器中的 shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -t -i gitlab /bin/bash</span><br></pre></td></tr></table></figure><p>检查数据库迁移状况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure><p>如果所有状态都显示为 up 状态，是没问题的。如果发现 down 状态，类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up     20150920161119  Add line code to sent notification</span><br><span class="line">down    20150924125150  Add project id to ci commit</span><br><span class="line">down    20150924125436  Migrate project id for ci commits</span><br></pre></td></tr></table></figure><p>就必须重新手动执行数据库 migration 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate</span><br></pre></td></tr></table></figure><p>当执行结束时，重新检查数据库 migrate 状态，确保所有状态都为 up：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure><h3 id="9-继续在容器内部的-bash-shell-上，重新配置-gitlab"><a href="#9-继续在容器内部的-bash-shell-上，重新配置-gitlab" class="headerlink" title="9.继续在容器内部的 bash shell 上，重新配置 gitlab:"></a>9.继续在容器内部的 bash shell 上，重新配置 gitlab:</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>然后检查是不是所有内容都正常运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:check</span><br></pre></td></tr></table></figure><h3 id="10-如果一切正常，执行下面的命令："><a href="#10-如果一切正常，执行下面的命令：" class="headerlink" title="10.如果一切正常，执行下面的命令："></a>10.如果一切正常，执行下面的命令：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:<span class="built_in">env</span>:info RAILS_ENV=production</span><br></pre></td></tr></table></figure><p>会返回类似下面这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System information</span><br><span class="line">System:   Ubuntu 14.04</span><br><span class="line">Current User: git</span><br><span class="line">Using RVM:  no</span><br><span class="line">Ruby Version: 2.1.7p400</span><br><span class="line">Gem Version:  2.2.5</span><br><span class="line">Bundler Version:1.10.6</span><br><span class="line">Rake Version: 10.4.2</span><br><span class="line">Sidekiq Version:3.3.0</span><br><span class="line"> </span><br><span class="line">GitLab information</span><br><span class="line">Version:  8.2.0</span><br><span class="line">Revision: d6bcf44</span><br><span class="line">Directory:  /opt/gitlab/embedded/service/gitlab-rails</span><br><span class="line">DB Adapter: postgresql</span><br><span class="line">URL:    http://192.168.1.1:8082</span><br><span class="line">HTTP Clone URL: http://192.168.1.1:8082/some-group/some-project.git</span><br><span class="line">SSH Clone URL:  git@192.168.1.1:some-group/some-project.git</span><br><span class="line">Using LDAP: yes</span><br><span class="line">Using Omniauth: no</span><br><span class="line"> </span><br><span class="line">GitLab Shell</span><br><span class="line">Version:  2.6.7</span><br><span class="line">Repositories: /var/opt/gitlab/git-data/repositories</span><br><span class="line">Hooks:    /opt/gitlab/embedded/service/gitlab-shell/hooks/</span><br><span class="line">Git:    /opt/gitlab/embedded/bin/git</span><br></pre></td></tr></table></figure><h3 id="11-最后，清除-Redis-的缓存"><a href="#11-最后，清除-Redis-的缓存" class="headerlink" title="11.最后，清除 Redis 的缓存"></a>11.最后，清除 Redis 的缓存</h3><p>不然可能会遇到这个问题： <a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/3619">#3619</a> 或这个问题 <a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/3609">#3609</a>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake cache:clear</span><br></pre></td></tr></table></figure><h3 id="12-访问测试"><a href="#12-访问测试" class="headerlink" title="12.访问测试"></a>12.访问测试</h3><p>完成上述步骤之后，访问 <a href="http://localhost:8082/">http://localhost:8082</a> 应该能正常登陆</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;问题来源：docker-的-file-system-神坑&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机领域中的概念辨析</title>
    <link href="http://starding.github.io/2016/01/15/learn-in-computer-sciense/"/>
    <id>http://starding.github.io/2016/01/15/learn-in-computer-sciense/</id>
    <published>2016-01-15T01:14:51.000Z</published>
    <updated>2024-02-21T01:17:29.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念辨析？"><a href="#概念辨析？" class="headerlink" title="概念辨析？"></a>概念辨析？</h2><p>概念，摘自维基百科，为了保持概念的完整性，这里摘录了比较长的内容：</p><blockquote><p>概念也称观念，是抽象的、普遍的想法、观念或充当指明实体、事件或关系的范畴或类的实体。在它们的外延中忽略事物的差异，如同它们是同一的去处理它们，所以概念是抽象的。它们等同的适用于在它们外延中的所有事物，所以它们是普遍的。概念也是命题的基本元素，如同词是句子的基本语义元素一样。</p><p>概念是意义的载体，而不是意义的主动者。一个单一的概念可以用任何数目的语言来表达；术语则是概念的表达形式。狗的概念可以表达为德语的 Hund，法语的 chien 和西班牙语的 perro。概念在一定意义上独立于语言的事实使得翻译成为可能 - 在各种语言中词有同一的意义，因为它们表达了相同的概念。</p><p>概念是人类对一个复杂的过程或事物的理解。从哲学的观念来说概念是思维的基本单位。在日常用语中人们往往将概念与一个词或一个名词（术语）同等对待。传统上认为中国文化不强调定义概念，因此没有发展出逻辑和相关的哲学、科学。</p></blockquote><p>所谓概念辨析，就是去追溯词语的意思，来历，以及其可能的语境。这在哲学中是非常常见的，甚至在讨论每一个问题之前，都首先要把问题中的每一个概念辨析清楚，彻底搞清楚问题中的每一个词汇是什么意义，然后讨论才能继续往下进行。</p><h2 id="修辞学以及翻译中的失真"><a href="#修辞学以及翻译中的失真" class="headerlink" title="修辞学以及翻译中的失真"></a>修辞学以及翻译中的失真</h2><p>需要概念辨析的原因是多种多样的，可能是一个概念因为时间的关系，经历了意义的变化；也有可能是因为一个词是完全的外来词汇，在翻译中流失了原来的意义。而在计算机科学本身就是引入的科学，其专业术语基本都是翻译过来的。所以这里词汇辨析也就更倾向于消除翻译中的失真问题。</p><p>在计算机科学中，至少我目前所接触到的诸多书籍，甚至是在之前所受的专业的计算机教育中，都没有词语辨析这一块。而且由于汉语本身重修辞，轻辨析的特点，在原来英文词汇中存在的比较直白的意象，到了汉语翻译时，就可能为了优美，意向等加入一些隐含的修辞手法，开始变得玄妙起来。这个时候去追寻原来的词汇就非常重要了。</p><p>相应的翻译有：</p><ul><li>handle 翻译为「句柄」</li><li>socket 翻译为「套接字」</li><li>meta-programming 翻译为「元编程」<br>等等，这些翻译在英文中的含义都比较直白，但是到了汉语中，为了兼顾概念的简洁，雅致，借用了很多本土化的意象，但是这些意象本身就是比较朦胧的意思。导致原来明确地意思，变得朦胧，难以理解。这些翻译都是历史和当时技术背景下的产物。其实如果放到今天，可能根本不会像原来那样去翻译，甚至关键的词直接就保留了。</li></ul><p>遇到这些词汇的时候我们就需要考察它翻译的时期，以及翻译成中文之前的源词汇是什么。找到这些源词汇后，在源词汇中的上下文中去理解。但是即便是在源词汇中，也是很有辨析的必要的。因为源词汇也不是凭空而来的，计算机是一门非常新的科学，其词汇也有很多是新构造的词。这些词有的是直接造出来的，有的则也是用了一定的修辞，在原来的意义上引申到进计算机领域中来。</p><p>一个词汇的引申并不是毫无理由的，其背后的动机往往是某些概念具有内在的联系，而这也常常构成一种修辞手法：「隐喻」</p><h2 id="概念背后的隐喻"><a href="#概念背后的隐喻" class="headerlink" title="概念背后的隐喻"></a>概念背后的隐喻</h2><p>概念辨析另一层好处就是，它能让我们看到概念背后的隐喻。进而我们更好，也更深刻地理解一个概念的核心思想。</p><p>举例来说，个人比较喜欢的几个隐喻是：</p><ul><li>docker 码头工人的隐喻</li><li>handle 把手的隐喻</li><li>callback 回电的隐喻</li><li>hook 钩子的隐喻</li></ul><p>隐喻的共同点就是，其本身直白的原意以一种比较隐含的方式与其在计算机科学中的概念关联，它们之间有一种很相似的结构，含义等。想要快速理解一个词汇的含义，将其隐喻与现有语境结合起来是非常重要的。</p><h2 id="概念辨析背后的哲学思想"><a href="#概念辨析背后的哲学思想" class="headerlink" title="概念辨析背后的哲学思想"></a>概念辨析背后的哲学思想</h2><p>「直推因」和「目的因」的辨析</p><p>待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;概念辨析？&quot;&gt;&lt;a href=&quot;#概念辨析？&quot; class=&quot;he</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>python 中的装饰器和迭代器</title>
    <link href="http://starding.github.io/2016/01/15/python-iterator-generator/"/>
    <id>http://starding.github.io/2016/01/15/python-iterator-generator/</id>
    <published>2016-01-15T01:01:40.000Z</published>
    <updated>2024-02-21T01:13:47.388Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不是很靠谱，很明显甚至连官方文档都没有看，就只根据经验就直接写文章来总结了，很容易误导人。</p><h2 id="Iterator-Types"><a href="#Iterator-Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h2><p>迭代器类型</p><h3 id="先看-python2-7-官方文档中关于迭代的部分："><a href="#先看-python2-7-官方文档中关于迭代的部分：" class="headerlink" title="先看 python2.7 官方文档中关于迭代的部分："></a>先看 python2.7 官方文档中关于迭代的部分：</h3><p>在阅读之前，需要明确几个词的含义：</p><ul><li>「iterator」迭代器</li><li>「iteration」迭代</li><li>「iterable」可迭代的</li><li>「container」容器对象，也就是可以存放其他对象的对象，比如列表，字典等</li></ul><blockquote><p>New in version 2.2.<br>Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods.<br>python 提供一种基于容器对象（container）的迭代概念。并且使用了两个特的方法来实现这一概念；这些方法允许自定义的类支持迭代。符合下面详细描述的序列（sequences），都将支持迭代方法。</p></blockquote><blockquote><p>One method needs to be defined for container objects to provide iteration support:<br>第一个在容器对象中定义的方法用于支持迭代（iteration）<br><code>container.__iter__()</code><br>Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example of an object supporting multiple forms of iteration would be a tree structure which supports both breadth-first and depth-first traversal.) This method corresponds to the tp_iter slot of the type structure for Python objects in the Python&#x2F;C API.<br>返回一个迭代器对象（iterator object）。这个对象需要支持下面描述的迭代器协议（iterator protocal）。如果一个容器对象需要支持不同类型的迭代方式，也可以往容器对象中添加更多的方法来支持那些迭代方式。（一个对象支持多种跌打方式的例子是同时支持深度优先遍历和广度优先遍历的树结构）</p></blockquote><blockquote><p>The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:<br>迭代器本身也需要支持下面的两个方法，『这两个方法一起构成了迭代器协议』</p></blockquote><blockquote><p><code>iterator.__iter__()</code><br>Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python&#x2F;C API.<br>返回迭代器对象自身。如果在 for 语句以及 in 语句中，使用容器对象和迭代器对象的话，那么它们都需要拥有此方法。</p></blockquote><blockquote><p><code>iterator.next()</code><br>Return the next item from the container. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python&#x2F;C API.<br>返回容器中的下一个元素。如果没有下一个元素，则产生一个 StopIteration 异常。<br>Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms. The specific types are not important beyond their implementation of the iterator protocol.<br>python 基于一些或通用或特定的序列类型，字典或其他更特殊的类型，定义了一系列的迭代器对象来支持迭代。这些对象的核心内容就是其中的迭代器协议。<br>The intention of the protocol is that once an iterator’s next() method raises StopIteration, it will continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. (This constraint was added in Python 2.3; in Python 2.2, various iterators are broken according to this rule.)<br>这个协议的目的是，一旦一个迭代器的 next() 方法产生了一个 StopIteration 异常，后续再度调用时，就会一直保持产生一个 StopIteration 的状态。如果不按照这个特性实现，就被认为是有问题的（这个约束是在 python2.3 中添加的；在 python2.2 中，有很多迭代器不遵守这个规则）</p></blockquote><h3 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h3><p>上面大致就是 python2.7 中关于迭代的核心内容，整理一下就是：</p><p>对于容器对象（container）来说，要支持迭代的话，需要在容器内部实现一个__iter__() 方法。这个方法返回一个「迭代器对象」（iterator）。如果一个容器实现了这个方法，那么我们称这个容器是「可迭代的」（iterable）。</p><p>对于迭代器来说，它也需要一个__iter__() 方法，用于返回这个迭代器自身。同时需要一个 next() 方法，来返回下一个元素。迭代器本身当然是「可迭代的」。迭代器的这两个方法，合在一起，叫做「迭代器协议」。</p><p>在 for，in 语句中，无论是使用容器对象（如列表），还是迭代器对象，它们内部都需要支持__iter__() 方法。对于容器对象来说这个方法会返回一个迭代器，对于迭代器对象来说，这个方法会返回自身。然后用于迭代，换句话说，即使是容器对象，也是先转换为迭代器对象再进行迭代的。这在 python 的文档中也有说明：</p><h3 id="The-for-statement"><a href="#The-for-statement" class="headerlink" title="The for statement"></a>The for statement</h3><blockquote><p>The for statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_stmt ::=  <span class="string">&quot;for&quot;</span> target_list <span class="string">&quot;in&quot;</span> expression_list <span class="string">&quot;:&quot;</span> suite [<span class="string">&quot;else&quot;</span> <span class="string">&quot;:&quot;</span> suite]</span><br></pre></td></tr></table></figure><p>The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the expression_list. The suite is then executed once for each item provided by the iterator, in the order of ascending indices. Each item in turn is assigned to the target list using the standard rules for assignments, and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.</p></blockquote><h2 id="Generator-Types"><a href="#Generator-Types" class="headerlink" title="Generator Types"></a>Generator Types</h2><p>生成器类型</p><h3 id="官方文档的定义："><a href="#官方文档的定义：" class="headerlink" title="官方文档的定义："></a>官方文档的定义：</h3><blockquote><p>Python’s generators provide a convenient way to implement the iterator protocol. If a container object’s <code>__iter__()</code> method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the <code>__iter__()</code> and next() methods. More information about generators can be found in the documentation for the yield expression.<br>python 的生成器提供了应用迭代器协议的便捷方式。如果一个容器对象的<code>__iter__()</code> 方法被用于生成器，它会自动地返回一个迭代器对象（技术上讲，是一个生成器对象），并且提供_<code>_iter__()</code> 和 <code>next()</code> 方法。</p></blockquote><h3 id="概念辨析-1"><a href="#概念辨析-1" class="headerlink" title="概念辨析"></a>概念辨析</h3><p>上述内容的意思是，生成器对象不过是一种应用迭代器协议的快捷方式。平时我们需要一个自定义的迭代器<br>时，需要手动的去实现需要的<code>__iter__()</code> 和 <code>next()</code> 方法，但是使用生成器对象的话，可以自动返回一个支持迭代协议的迭代器。而创建一个生成器，只需要在函数中使用 yield 表达式就可以了，这样会创建一个生成器函数，当它被调用时，会返回一个迭代器（通常被叫做生成器），它会控制生成器函数的执行。</p><blockquote><p>The yield expression is only used when defining a generator function, and can only be used in the body of a function definition. Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.</p><p>When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generator’s methods is called. At that time, the execution proceeds to the first yield expression, where it is suspended again, returning the value of expression_list to generator’s caller. By suspended we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack. When the execution is resumed by calling one of the generator’s methods, the function can proceed exactly as if the yield expression was just another external call. The value of the yield expression after resuming depends on the method which resumed the execution.</p><p>All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator’s caller</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>从快播案看技术中性论的地位</title>
    <link href="http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/"/>
    <id>http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/</id>
    <published>2016-01-11T15:09:07.000Z</published>
    <updated>2024-02-20T15:16:37.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。</p><blockquote><p>technological neutrality<br>中文意思为「技术中性论」，核心主张是技术是纯粹的，价值中立的，其本身不存在是非善恶这些性质；技术的归宿是人类的使用，而最终产生的结果，也应该由人类自身来承担。</p></blockquote><h2 id="快播案中的技术中性论"><a href="#快播案中的技术中性论" class="headerlink" title="快播案中的技术中性论"></a>快播案中的技术中性论</h2><p>最近的快播案中的辩论，有关技术价值部分，可以说是「技术中性论」在科学哲学中所受讨论的缩影：技术中性论在科学哲学中，持续了非常长的一段时间，而且直到今天还非常有市场。在普通民众群体中，技术中性论甚至更是唯一的关于技术的价值观。</p><p>「技术中性论」价值观中，有一些非常常见的论据：</p><ul><li>日常生活中的例子：用刀杀了人，有罪的是人，而不是刀，也不是生产刀的厂家。</li><li>科学中的例子：原子弹是无罪的，有罪的是滥用它们的人。</li><li>互联网的例子：木马是无罪的，有罪的是用它们来进行非法活动的人。</li></ul><p>这些主张都是在论证技术的价值中立特点。后面会说这些论据的漏洞在哪里。</p><h3 id="科学哲学中的技术中性论"><a href="#科学哲学中的技术中性论" class="headerlink" title="科学哲学中的技术中性论"></a>科学哲学中的技术中性论</h3><p>其实「技术中性论」的观点，在科学哲学中很早就出现了，而且因为技术本身的「自我隐蔽性」，技术所附带的价值天然倾向于中立性。在近代工业革命之后，技术的弊病逐渐显露出来，而对技术价值的反思，也在科学哲学中有了新的进展。</p><h3 id="讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？"><a href="#讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？" class="headerlink" title="讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？"></a>讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？</h3><p>『技术没有价值偏向。一切技术的使用，所产生的后果，归根结底都应该由人类承担，不管它是好的或是坏的』。从根本上讲，这句话是对的，因为如果不是人类，根本就不会有技术，那也就不会有技术带来的副作用。在这种意义下，说『所有的罪，最终都归于人类』也无可厚非。</p><p>但是在现实中，并不能这样去讨论问题。即便是技术哲学中，在上面的意义下讨论问题也是无意义的，这种意义下的讨论不会给人类理解技术带来任何实质的帮助。</p><p>讨论技术价值的前提是：</p><p><strong>『技术是人类创建出来的，也是由人类使用的。技术并不是「死的」，它对人类是有影响的』</strong></p><p>在这种前提下，我们在讨论技术价值时，我们讨论的是：技术本身是否真的是纯粹的，技术会不会在某些方面对人类产生副作用。更准确地说，技术是人类创造出来的，那么这种创造物，对人类的自我建构会不会产生影响？</p><h3 id="技术的意向结构"><a href="#技术的意向结构" class="headerlink" title="技术的意向结构"></a>技术的意向结构</h3><p>试想这样一种情景：</p><p>有两个民族，一个民族在族人很小的时候，就送他们刀与马。而另一个民族，则送他们诗与书。那么在这两个民族成长之后会发生什么呢？可以想象，第一个民族，刀会成为他们首选的说话方式。而第二个民族，诗书则会成为他们选择的说话方式。</p><p>再举一个更贴近生活的例子，又一次老板问我，mac 用着爽吗？是不是用 mac，用着这些比较好的工具，就是想写东西，想写代码？用 mac，你就是想写代码，用 windows，你就是想玩儿游戏。</p><p>上面的例子是想要说明，技术本身是有它的意向结构的，这种意向结构带有一种附加的价值，不自觉地对人类产生副作用。这种副作用的产生，不是人类可以选择的，在群体中更是如此。人类身处自身范式之中，没有这种能力，去清晰的分辨一种意向结构长期带来的影响。</p><p>需要注意的是，这里只是说技术有自己的意向结构，反过来对人类产生不自觉地副作用。并没有对这种意向结构，做出价值上的判断，即没有判断它是好还是坏。实际上，这是一个相当艰巨，甚至多数时候是不能完成的任务。</p><p>另一方面，说技术对人类的自我建构有副作用，也不像传统哲学中的「决定论」那样，会出现人类没有自由意志，做出的任何决定，犯下的任何过错，都不用，也不能承担后果的局面。</p><p>在技术哲学中，技术的非中性论论题主张『技术与人类是互相构建的』</p><h3 id="回到快播案中的技术中性论点"><a href="#回到快播案中的技术中性论点" class="headerlink" title="回到快播案中的技术中性论点"></a>回到快播案中的技术中性论点</h3><p>技术的意向结构，决定了它必然会对人类产生副作用，也揭示出前面所列举论据的一个非常大的漏洞：它假设了一个前提，就是人类可以完全清醒的判断，一样技术的使用会有什么潜在的副作用。换句话说，人类可以清楚的知道，并且控制技术所带来的反作用，包括那些非常明显的和潜伏的效果。</p><p>但这是不现实的，很多技术的副作用是难以察觉的，你很难清楚的知道，长期使用微信这项技术，对你会产生，或者已经产生了怎样的影响。更何况人类身处一个技术交织成的大网之中了。</p><p>另一方面是，技术对于群体产生的副作用比起对个人产生的副作用，要更为复杂了，因为一个群体中的行为并不是简单个人行为的叠加，一种技术对群体带来的影响更为深远。以编程语言为例，纯粹的 c 程序员和 python 程序员必然是有差别的，而这些差别体现到群体上，基本就反映出了 C 和 python 设计哲学中的差别，也就是其本身意向结构的差别。</p><p>也就是说，技术在群体中产生的作用，最终会更接近技术本身意向结构：如果快播可以方便的传播淫秽资料，那么在目前文明阶段的自然情况下，它必然会传播淫秽资料，而不是学习资料。如果明白了这一点，也就能清楚的直到关键点在哪——控制，监管，批判，反思。</p><p>这也是技术批判理论主张的：</p><p><strong>『即使技术是由自身的意向结构的，但这对于我们的指导是更谨慎，更批判的去处理它，而不是直接对其做出价值判断来肯定或否定它』</strong></p><h2 id="科学哲学与社会技术决策"><a href="#科学哲学与社会技术决策" class="headerlink" title="科学哲学与社会技术决策"></a>科学哲学与社会技术决策</h2><p>待续</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>关于技术的哲学，之前从未有过深思。仅从《娱乐至死》一书中体会到技术与人类的关系不是一分为二那么简单。后来也思考过技术中性论的问题，总觉得什么地方有问题，但是又说不上来，直到读了吴国盛老师的《技术哲学演讲录》，得到了一个迄今为止，我最为满意的一个答案：</p><blockquote><p>『技术与人类是互相构建的』</p></blockquote><h3 id="《技术哲学演讲录》内容要点摘录："><a href="#《技术哲学演讲录》内容要点摘录：" class="headerlink" title="《技术哲学演讲录》内容要点摘录："></a>《技术哲学演讲录》内容要点摘录：</h3><h4 id="技术的人文本质"><a href="#技术的人文本质" class="headerlink" title="技术的人文本质"></a>技术的人文本质</h4><ul><li><p>什么是技术？</p><ul><li>技术是人的存在方式，技术与人并非是一分为二的</li></ul></li><li><p>人的本质是什么？</p><ul><li>人是一种没有本质的动物，人的本质是自我建构的</li></ul></li><li><p>技术的特性</p><ul><li>技术是自我隐蔽的，而西方学术史是只重视内在理路的历史</li><li>技术中性论的问题：技术是有意象结构的，包含着特定的价值取向</li><li>技术是构造人和世界的环节：身体技术，人类都是早产儿，身体塑造，知觉塑造。ppt 的使用。</li></ul></li></ul><h4 id="技术与政治"><a href="#技术与政治" class="headerlink" title="技术与政治"></a>技术与政治</h4><ul><li><p>技术有政治吗</p><ul><li>技术与政治是相关的。政治干预技术，技术影响政治：火药消灭骑士阶层，是封建制度的掘墓者。水利社会与集权制度。</li></ul></li><li><p>技术的政治批判</p><ul><li>手推磨产生了封建制度，蒸汽磨产生了资本主义制度。</li></ul></li><li><p>泰勒制与福特制</p><ul><li>技术导致人性的退让：新闻上看到死人慢慢无视</li></ul></li><li><p>三种技术观</p><ul><li>技术乐观主义：技术中性论者，技术带来的问题只能用技术解决</li><li>技术悲观主义：技术自主论，有内在的发展逻辑，认为现代社会进入了一个单向度社会，差异感消失，技术的触角深入到每一个领域。但它是以整体观点看待技术，把技术看做铁板一块，没搞清楚技术各种可能性，只有深入细节，才能走出悲观主义。</li><li>技术批判理论：深入技术的细节，考察各方面。：技术转化论。流水线，计算机，通信，交通，宣传技术。一切新技术都要问谁受益，谁吃亏。</li></ul></li></ul><h4 id="技术与哲学"><a href="#技术与哲学" class="headerlink" title="技术与哲学"></a>技术与哲学</h4><ul><li><p>技术哲学的历史性缺席</p><ul><li>美，正义，善，艺术，科学，都是哲学关注点，技术却不是。</li><li>技术本身：自身隐蔽性，和长期的技术中性论</li><li>哲学：哲学注重说理，讲内在逻辑。：本质主义</li></ul></li><li><p>技术哲学的兴起</p><ul><li>技术本身的变化：近来技术的问题出现了，不再透明</li><li>哲学：本质主义的瓦解与现象主义的出现。经验论传承唯名论。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。&lt;</summary>
      
    
    
    
    <category term="科哲和科学史" scheme="http://starding.github.io/categories/%E7%A7%91%E5%93%B2%E5%92%8C%E7%A7%91%E5%AD%A6%E5%8F%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>那些年我在 python 中扑过的街</title>
    <link href="http://starding.github.io/2016/01/10/traps-in-python/"/>
    <id>http://starding.github.io/2016/01/10/traps-in-python/</id>
    <published>2016-01-10T15:03:01.000Z</published>
    <updated>2024-02-20T15:07:08.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>前事不忘，后事之师。 ——《战国策·赵策一》</p></blockquote><h2 id="python-中的模块导入"><a href="#python-中的模块导入" class="headerlink" title="python 中的模块导入"></a>python 中的模块导入</h2><h3 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a>包导入</h3><p>这个比较简单，一个例子带过吧，但刚开始确实扑街了…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件结构：</span></span><br><span class="line">packages</span><br><span class="line">├── __init__.py</span><br><span class="line">└── my_module.py</span><br><span class="line"><span class="comment"># 这种是包导入</span></span><br><span class="line"><span class="keyword">import</span> packages</span><br><span class="line"><span class="comment"># 后续是从__init__.py 中定义的属性中获取的</span></span><br><span class="line">packages.some_module.some_method</span><br><span class="line"><span class="comment"># 这种是把包当做搜索路径上的一环</span></span><br><span class="line"><span class="keyword">from</span> packages <span class="keyword">import</span> some_module</span><br><span class="line">some_module.some_method</span><br></pre></td></tr></table></figure><h3 id="模块导入搜索路径"><a href="#模块导入搜索路径" class="headerlink" title="模块导入搜索路径"></a>模块导入搜索路径</h3><p>例如下面的使用场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># django 中有一个 common app，并且已经添加到已安装 app 列表中</span></span><br><span class="line"><span class="comment"># common app 文件结构</span></span><br><span class="line">common</span><br><span class="line">├── __init__.py</span><br><span class="line">├── common.py</span><br><span class="line">├── others.py</span><br><span class="line">└── somethings.py</span><br><span class="line"><span class="comment"># somethings.py 中存在导入语句</span></span><br><span class="line"><span class="keyword">from</span> common.others <span class="keyword">import</span> some_func   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p>在上面的代码示例中，由于 common 的名称相同，以及搜索路径默认是先从当前执行代码所在目录开始搜索，所以 common 文件 会在 common 包之前被搜索到，造成搜索路径上的覆盖。而一旦搜索到 common 时，就会去 common 文件中查找 some_func，但是无法找到，这样就会报错。</p><h2 id="try-except-finally-中语句执行顺序"><a href="#try-except-finally-中语句执行顺序" class="headerlink" title="try-except-finally 中语句执行顺序"></a>try-except-finally 中语句执行顺序</h2><p>在 python 的异常处理中，无论 try 语句中是否有异常抛出，finally 语句总会被执行。由于这个特性，finally 语句经常被用来做一些清理工作，例如关闭文件，数据库等等。</p><p>如果当 try-except-finally 中出现异常，并且未被妥善处理时，python 会先把发生的异常暂存，当 finally 中的动作执行完毕之后，把保存的异常返回给上级。try-except-finally 中的语句执行顺序，决定了它会有一些潜在的陷阱。</p><p>看以下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">finallyTest</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;start------&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>  <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;running------&quot;</span></span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;r&quot;</span>)   <span class="comment">#抛出异 IndexError 异常</span></span><br><span class="line">        <span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;NameError happended &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;finally executed&#x27;</span></span><br><span class="line">            <span class="keyword">break</span> <span class="comment">#finally 语句中有 break 语句</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 执行测试函数</span></span><br><span class="line">FinallyTest()</span><br><span class="line"><span class="comment">#输出结果为：</span></span><br><span class="line">start------</span><br><span class="line">running------</span><br><span class="line"><span class="keyword">finally</span> executed</span><br></pre></td></tr></table></figure><p>在上面的例子中，在 try 语句中，raise 出了一个 IndexError 异常，而且 except 语句也没有捕获这个错误。按照平常的理解，这个错误会向上级（也就是调用这个函数的程序）传递，在本例中会传递到解释器，并引发一个 IndexError 错误。但是整个函数执行完之后并没有异常出现。</p><p>原因就在于在当 try 块中发生异常的时候，如果在 except 语句中找不到对应的异常处理，异常将会被「临时保存起来」。当 finally 执行完毕的时候，临时保存的异常将会「再次被抛出」，但如果 finally 语句中产生了新的异常或者执行了 return 或者 break 语句，那么临时保存的异常将会被丢失，从而导致「异常屏蔽」。</p><p>另外一个稍微复杂一些例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.Logger(__name__)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">returnTest</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> a == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;data can not be False&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a  </span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">&quot;exception!, &#123;detail&#125;&quot;</span>).fomat(detail)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;return exception in except statement&quot;</span> </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;return in finally statement&quot;</span></span><br><span class="line"><span class="built_in">print</span> returnTest(<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span> returnTest(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>按照平常理解，第一个 print 语句会触发错误，然后进入 except 语句打印异常，而同时 finally 部分中的语句必然会执行，所以这里会返回一个’return in finally statement’值。第二个则会返回 True。实际上则不然，返回值竟然都是’return in finally statement’。</p><p>原因是和上面的例子中是一样的，无论是 try 复合语句中，还是 except 复合语句中的 return&#x2F;break 语句，这种会产生程序跳转的语句会先被保存起来。然后再去执行 finally 中的语句，而一旦 finally 中出现了跳转语句，就会直接跳转了，这样早成的结果就是上面保存状态的消失。</p><h2 id="字典推导的限制"><a href="#字典推导的限制" class="headerlink" title="字典推导的限制"></a>字典推导的限制</h2><p>在做一个项目的时候，遇到一个需要多次请求数据库的操作，详细情况就是，有一些公司，这些公司本身有名字，公司代号这样的组织，如果每次都从数据库中取公司信息，会有性能问题。于是就采用用字典缓存下来，于是想使用字典推导。发现推导时只能生成单元素，之前我没有留意过这一点，在此记录一下。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样是可以的</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key: model.value <span class="keyword">for</span> Modle <span class="keyword">in</span> models &#125;</span><br><span class="line"><span class="comment"># 结果就是个普通的字典</span></span><br><span class="line">&gt;&gt;&gt;&#123;key1: value1, key2: value2, ...&#125;</span><br><span class="line"><span class="comment"># 但是想要下面这样使用是不支持的</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key1: model.value1, moedel.key2: model.value2 <span class="keyword">for</span> model <span class="keyword">in</span> models&#125;</span><br><span class="line"><span class="comment"># 折中的办法是将上面的 value 值换成一个字典，或者是使用列表推导再封装一层列表</span></span><br><span class="line">&gt;&gt;&gt;&#123;model.key1: &#123;models.key1: models.value1, model.key2: model.value2, ...&#125; <span class="keyword">for</span> model <span class="keyword">in</span> models&#125;</span><br></pre></td></tr></table></figure><p>补充一下实际的例子，其中 branch 相关的是分公司信息，subbranch 相关的是中支公司信息，目的是构造一个，分公司名称为 key 值，分公司的主键，编号，以及该分公司辖下的中支公司为 value 值的字典，其中的中支公司也是一个字典：以中支公司名称为 key 值，中支公司的其他信息为 value 值。这样就构成了一个公司数据的二阶字典缓存列表。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">companys_by_name = &#123;</span><br><span class="line">        branch.name: &#123;</span><br><span class="line">            <span class="string">&quot;pk&quot;</span>: branch.pk,</span><br><span class="line">            <span class="string">&quot;number&quot;</span>: branch.number,</span><br><span class="line">            <span class="string">&quot;subbranch&quot;</span>: &#123;</span><br><span class="line">                subbranch.name: &#123;<span class="string">&quot;pk&quot;</span>:subbranch.pk, <span class="string">&quot;number&quot;</span>:subbranch.number&#125; <span class="keyword">for</span> subbranch <span class="keyword">in</span> SubbranchCompany.objects.<span class="built_in">filter</span>(branch_company=branch)</span><br><span class="line">            &#125; <span class="keyword">for</span> branch <span class="keyword">in</span> BranchCompany.objects.<span class="built_in">all</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 详细含义如下，其中中支公司是分工司辖下的公司</span></span><br><span class="line">公司信息字典 = &#123;</span><br><span class="line">     分公司名字:&#123;</span><br><span class="line">        <span class="string">&quot;主键&quot;</span>: 当前迭代分公司主键，</span><br><span class="line">        <span class="string">&quot;公司号&quot;</span>: 当前迭代公司公司号，</span><br><span class="line">        <span class="string">&quot;中支公司&quot;</span>:&#123;</span><br><span class="line">            中支公司名字:&#123;</span><br><span class="line">                <span class="string">&quot;主键&quot;</span>: 当前迭代中支公司主键,</span><br><span class="line">                <span class="string">&quot;中支公司号&quot;</span>: 当前迭代中支公司号,</span><br><span class="line">            &#125; <span class="keyword">for</span> 中支公司 <span class="keyword">in</span> 当期迭代分公司下中支公司集合</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">for</span> 分公司 <span class="keyword">in</span> 分公司集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;前事不忘，后事之师。 ——《战国策·赵策一》&lt;/p</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Open Questions</title>
    <link href="http://starding.github.io/2016/01/10/open-questions/"/>
    <id>http://starding.github.io/2016/01/10/open-questions/</id>
    <published>2016-01-10T14:59:11.000Z</published>
    <updated>2024-02-20T15:00:42.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文专门用于汇总一些平时遇到的问题。<br>这些问题有的有一些我的初步思考，但可能存在很大的缺陷，甚至根本上就是错误的。而有的是刚遇到，或者是刚刚想到的问题，因为身处于自己的范式之中，我目前甚至都判断不清楚这些问题是不是幼稚的，这些问题本身是不是就有问题。</p><p>或许是受过一点科学哲学教育的原因，总是想着在学习的过程中，试着了解一件事物的目的因。虽然在自然科学研究中，追寻直推因是知识增长的最佳方式，目的因的追求往往产生问题，而且不现实。但是，在计算机科学中，有非常多的事物是人类直接定义的，可以说计算机世界大部分都是人类自己创造的，在这样的情况下，追求目的因才是最好，也是最深刻的知识增长方式。</p><p>总之，我把问题以及目前的思路记录下来了。<br>对于我来说，能提出问题的时候，才是真正开始理解的时候</p><h2 id="工程类问题"><a href="#工程类问题" class="headerlink" title="工程类问题"></a>工程类问题</h2><ul><li>RESTful 与 ROA（面向资源的架构）之间的关系是什么？<ul><li>RESTful 我是大致了解的，而且也简单实践过。</li><li>面向资源的架构，按照字面意思来理解，就是以资源为中心的架构，比如在后台，按照资源分类，实现各个资源的切分，然后按照比较独立的资源进行组合出想要的内容。</li><li>以一个隐喻来说，就像是在建造一幢大楼时，所有的原材料（资源）都以比较细分的方式给出来了，而且，理论上利用这些原材料，能构建出大部分结构的大楼。</li></ul></li></ul><h2 id="Meta-问题"><a href="#Meta-问题" class="headerlink" title="Meta 问题"></a>Meta 问题</h2><ul><li>计算机科学与自然科学学习中的不同。<ul><li>主要是有关方法论的。在自然科学中，比如物理学中，我们可能试着找出一件事物的目的因，比如为什么光速是有限的之类的，或是像生物学中的，为什么对于人类来说，乙醇没毒，而甲醇等相似结构的毒性却很大。在自然科学的研究中，我们会直接去寻找它表现为什么样，这叫做直推因，而且这种研究方式在自然科学中，很容易获得知识的增加。</li><li>在计算机科学中，大部分世界都是人类创造的，人类直接定义，制造了这个世界，所以很多时候，我们是可以追问目的因的，虽然追问到最后，仍有一部分问题会回到自然科学中，或是形式科学中。但是追寻目的因可以让我们更快速的深入一个问题的本质。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;本文专门用于汇总一些平时遇到的问题。&lt;br&gt;这些问题有的有一些我的初步思考，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的前端笔记之理解 html 篇</title>
    <link href="http://starding.github.io/2016/01/09/my-front-end-introduction/"/>
    <id>http://starding.github.io/2016/01/09/my-front-end-introduction/</id>
    <published>2016-01-09T13:03:40.000Z</published>
    <updated>2024-02-20T14:57:40.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像 html 的某个元素啦，或是某个 css 的具体意思了，再或者是写一点 javascript 啦之类的内容。但总是感觉对前端缺乏一种比较顶层的认识。</p><p>虽然偶尔也会听说一些关于网页三剑客的比喻。类似 html 是网页的骨骼，负责网页的骨架部分；css 是网页的皮肤，负责网页的外观部分；javascript 则是网页的肌肉，给网页上的交互提供动力。不过这种说法似乎又太过于宽泛了，难以让人形成具体的认识。</p><p>所以本文试着整理一种介于上述比喻，以及底层细节之间的一些内容。通过分别叙述 html，css，javascript 的核心角色，试着能不能找到那种高屋建瓴的感觉。</p><p>首先辨析一下前端两个概念：「排版」和「布局」</p><p>参考知乎的两个回答：<a href="https://www.zhihu.com/question/38795148/answer/78177006">排版和布局是两个不同的东西</a>和<a href="https://www.zhihu.com/question/19588854/answer/13243044">布局和排版是有差异的</a></p><p>「布局」指的是宏观 GUI 的划分，比如你有多个大块的东西，想要按照指定方式排布。</p><p>「排版」指的是，比如你有一些段落，段落中有不同的字体，不同字号，按照不同基线对齐、折行、断词，并且合理处理溢出的部分。</p><h2 id="从网页说起"><a href="#从网页说起" class="headerlink" title="从网页说起"></a>从网页说起</h2><h3 id="网页是现实生活中各种信息载体的网络聚合版"><a href="#网页是现实生活中各种信息载体的网络聚合版" class="headerlink" title="网页是现实生活中各种信息载体的网络聚合版"></a>网页是现实生活中各种信息载体的网络聚合版</h3><p>网页，是前端最直接的展示部分。它的目的在于「展示信息」，其他的一切活动都是为展示信息服务的。网页和其他的展示信息的载体，并没有什么本质的差别。想象一下我们日常生活中常见的信息载体：一个 word 文档，一份 PDF，一份调查问卷，一份财务报表等等。而网页就是这些信息载体的网络聚合版本。</p><h3 id="人类在关注网页时，人类在关注什么"><a href="#人类在关注网页时，人类在关注什么" class="headerlink" title="人类在关注网页时，人类在关注什么"></a>人类在关注网页时，人类在关注什么</h3><p>就像我们对待生活中的那些信息载体以及其所附带的信息那样，我们也会以类似的态度对待网页：首先关注的是文档本身展示出的内容，如果这些内容展示的格式非常漂亮，那可能会让我们阅读时更愉快，也更愿意去阅读更多的内容，另外，如果这些信息载体要是再多一些互动就更容易吸引人了。</p><p>也就是说，人类在关注网页时，仍然是：内容-&gt;样式，交互 的顺序，当然在网页越来越丰富多彩的今天，样式和交互也越来越被看重，甚至已经和内容一样重要的程度了。</p><p>而内容，对应着 html；样式和交互，则由 css 和 javascript 共同决定</p><h2 id="html——带语义的文档流"><a href="#html——带语义的文档流" class="headerlink" title="html——带语义的文档流"></a>html——带语义的文档流</h2><h3 id="网页的「两种语义」"><a href="#网页的「两种语义」" class="headerlink" title="网页的「两种语义」"></a>网页的「两种语义」</h3><p>当然网页作为信息载体和日常生活中的实体还是有区别的。虽然网页上的信息最终受众是人类，但它要通过浏览器，搜索引擎，或是一些其他能够处理网页的程序来实现这一功能。这也就形成了网页的两种语义：</p><p>第一种语义是最终展示出来的语义，由人类来理解，也就是平时理解的语义。<br>第二种语义是由浏览器，搜索引擎等机器程序可理解，属于「机器可读的语义」<br>最终呈现出的语义，是由人类的知识结构来决定的，人类会将页面上不同的内容，理解成为「标题」，「内容」， 「脚注」， 「导航」等具有特定语义的元素。也正是因为这个原因，有些 html 元素，生来就带有一定的样式，比如 h1~h6 这些标题，字号会比较大，同时也会加粗。这是符合人类的常识的，也与最终要展示的语义贴合，因此这样的设定会非常方便。</p><p>而第二种语义，也就是机器可读的语义，从上面的意义上说，是为第一种语义服务的。浏览器，搜索引擎等程序会识别 html 代码中的语义元素，然后加上样式等最终展示出来。语义化越强的 html，越方便于机器去理解。在软件领域，语义化往往是建立在合理的「结构化」之上的，所谓「结构化」指的就是不同语义部分的内容，采用不同的结构加以区分，而 html 中的结构化，其实就是使用各类 html 标签完成的。</p><p>让第一种语义更友好的展示，是网页的整体目标。这需要设计师，信息架构师，程序员的通力合作。</p><p>让第二种语义更好的服务于第一种语义，是程序员的本质工作。</p><h3 id="为什么第二种语义是重要的"><a href="#为什么第二种语义是重要的" class="headerlink" title="为什么第二种语义是重要的"></a>为什么第二种语义是重要的</h3><p>有一个非常合适的例子可以说明第二种语义的重要性。不知道你在使用智能手机的时候有没有遇到过这样的情况：</p><p>有时候需要在某个网站上输入东西时，会弹出输入法。但是不同的输入框，弹出的输入法的界面又有所不同，当你输入邮箱时，会弹出带@符号的键盘，当你需要输入密码时，弹出的是全键盘等等。而且更奇怪的时，这个功能有时候灵，有时候不灵。这个功能好用的时候，你会感觉输入内容时非常顺畅，不灵时，你就要手动切换输入法的不同的界面，找到你需要的符号。感觉就非常不爽。</p><p>这背后就是第二种语义在起作用：在 html 中，输入框有很多不同的类型，有的是 email，有的是 password，有的是 text。如果一个网站很好的对这些语义做了区分，并且应用在了他们的 html 中。那么上述的输入法弹窗表现的就会很智能。因为机器可以根据 html 中不同的语义来选择弹出什么样的界面。如果是 emai，就弹出带@符号的界面，如果是密码，就弹出全键盘等等。但是如果语义化做的不好的网站，就做不到这一点，只会统一弹出通用界面，需要人类去判断，切换。</p><p>这个例子是要说明，在浏览器等软件越来越智能化的今天，html 的语义化也变得越来越重要。</p><p>上面也提到，浏览器一般会给一些特定的 html 元素以特定的样式，但是这只是因为这样做比较符合人类尝试，能够提供便利性。千万不要因为想要某个样式去使用元素，而是应该给要标记的内容选择最合适语义的元素。至于样式，则应该交由 css 去处理。『html 只关注语义，不关注布局，也不关注样式或交互』，这样的总结，也是出于这个原因。</p><h3 id="以-html-的语义来理解网页"><a href="#以-html-的语义来理解网页" class="headerlink" title="以 html 的语义来理解网页"></a>以 html 的语义来理解网页</h3><p>上面说完语义的重要性，接着来看如何通过理解这些第二类语义元素来理解网页。这部分内容涉及的元素比较多，这里只是粗略说明一下。</p><p>首先网页有不少展示用的语义化元素用来展示信息。</p><p>像最基本的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--尾部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--章节--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--独立片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artical</span>&gt;</span><span class="tag">&lt;/<span class="name">artical</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以及更具体的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些都是普通的语义化的来展示信息的元素。但是像现实生活那样，信息展示还有其他的方式，有助于人类更好的阅读和理解。比如：</p><ul><li><p>列表<br>它分条分类的列出比较核心的信息，可以让人更快的理解清楚一件事物的各方面重点。html 中</p></li><li><p>嵌入式的元素<br>如图片，所谓一图胜千言。<br>再如音乐，视频等等</p></li></ul><p>另外，现实生活中，我们常会遇到通过分发纸质的表单，用来收集信息。还有报表，用来清楚的展示分门分类的比较格式化的信息。这在 html 中也有相应的语义元素，分别是：</p><ul><li>表单（form）</li><li>表格（table）</li></ul><p>他们的作用也和现实生活中的大同小异，而且 html 中的表单有多种多样的类型，单选框，复选框，输入框（输入框本身也有更细的语义化的类型）。这和现实中的多种多样的调查表单都是相似的。</p><p>另外，html 中还多了一些独特的语义元素。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接，可能是最重要的独特元素，它把各个页面通过网络组合了起来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他一些元素，这些元素或描述了网页关系，或是描述网页信息等等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本的 html 元素，就是上述这些种类，可以看到，这些元素组合起来，即有收集信息的部分，又有展示信息的部分，而且为了更好的展示信息，html 又提供了许多语义化的元素。</p><p>这些元素组合在一起，一起形成了网页的全部语义信息，几乎可以实现和模仿现实中的所有信息载体，某些方面犹有胜之。</p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>除了前面所说的一些元素会根据常识带有一些样式外（如果说这算排版样式的话），html 还有一种简单的默认的布局方式（姑且这叫布局样式）：也就是从上到下，从左至右依次排列元素。用更形象的说法是，这叫 html 文档流。</p><p>这种默认的文档流，给 html 提供了符合常识的，也是最基础的布局，不至于说所有元素都乱糟糟的堆在一起。但还是强调那句话，虽然浏览器给 html 提供了一些默认的样式和布局，但这都是基于人类直觉和常识的：『html 只关注语义，不关注布局，也不关注样式或交互』</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 全称为 Document Object Module，也即文档对象模型。来看 <a href="https://dom.spec.whatwg.org/">W3.org 上的解释</a></p><h3 id="什么是-Document-Object-Model"><a href="#什么是-Document-Object-Model" class="headerlink" title="什么是 Document Object Model?"></a>什么是 Document Object Model?</h3><blockquote><p>The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page.<br>文档对象模型是「平台和语言无关的接口」，允许程序或脚本来动态地获得和更新文档的内容，结构以及样式等。这样，文档就可以以后再被处理（further processed），而且处理的结果反过来合并入目前的页面上。</p></blockquote><h3 id="Why-the-Document-Object-Model"><a href="#Why-the-Document-Object-Model" class="headerlink" title="Why the Document Object Model?"></a>Why the Document Object Model?</h3><blockquote><p>“Dynamic HTML” is a term used by some vendors to describe the combination of HTML, style sheets and scripts that allows documents to be animated. The W3C has received several submissions from members companies on the way in which the object model of HTML documents should be exposed to scripts. These submissions do not propose any new HTML tags or style sheet technology. The W3C DOM Activity is working hard to make sure interoperable and scripting-language neutral solutions are agreed upon.<br>“动态 html”是一些厂商描述 HTML，style sheet（样式表）和 scripts（脚本）结合起来实现文档动态化的说法。W3C 已经收到了来自一些团体组织的 submission，描述了 HTML 文档对象模型应该以何种方式暴露给 scripts。这些 submission 不建议任何新的 HTML 标签和样式表技术。W3C 组织的 DOM 运动累成狗，就是为了尽量协调多方需求以及形成平台和语言中立的解决方案。</p></blockquote><h3 id="上面两段在说啥？"><a href="#上面两段在说啥？" class="headerlink" title="上面两段在说啥？"></a>上面两段在说啥？</h3><p>也就是说，DOM 呢，是文档对象模型，它不是属于某个具体语言的标准库啥的，它是一种与语言和平台无关的模型。其他语言想要操作 HTML 文档（其实不仅是 HTML，还有 XML 等一些结构化语言）呢，就必须按照这个对象模型设计自己的操作方式。</p><p>推出 DOM 这个东西的原因就是原来有一批人在撕逼，你有你的想法，我有我的思路。W3C 为了一统武林，就提出了 DOM，并且不断的规范它，这样对大家都好。</p><p>DOM 本身是挺复杂的东西，但是我们平常所用的 DOM，只用了解到它的大致模样，以及知道如何操作就算入门了。我们平常说的 DOM，其实就是一种 HTML 的树形结构：</p><p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="DOM tree"></p><p>通过上图中的树形结构，可以使用其他实现了 DOM 操作的语言，如 javascript 等，按照一定的规则来操作这些节点。而这棵 DOM 树本身也定义了一些继承的概念，用于更方便的控制其中的节点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上基本上就是 html 核心的全部了，用几个词来总结一下就是：语义，基于常识的元素默认样式，文档流，以及 DOM。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像 html 的某</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>《三体》，《行尸走肉》与社会达尔文主义</title>
    <link href="http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/"/>
    <id>http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/</id>
    <published>2016-01-07T12:23:35.000Z</published>
    <updated>2024-02-20T01:26:45.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘的七七八八。刚开始看《行尸走肉》时，还以为是个单纯的丧尸剧，但随着剧情的不断深入，发现它描述了更多的东西。在某些重要的方面，比如场景的设定上，是非常相似的。不过是一个把达尔文主义推广到整个宇宙，建立了较为极端的达尔文性质的宇宙社会学。另一个则是将人类放入一个充满死亡的世界，以小团体进行黑暗森林式的生存，让自人类开始出现以来，数百万年形成的世界秩序重新洗牌，重新审视人类这一物种，同样渗透着浓厚的达尔文思想。</p><h2 id="《三体》与《行尸走肉》的基本设定"><a href="#《三体》与《行尸走肉》的基本设定" class="headerlink" title="《三体》与《行尸走肉》的基本设定"></a>《三体》与《行尸走肉》的基本设定</h2><p>二者的设定都充满了浓厚的达尔文色彩，非常强调生存竞争。</p><h3 id="进化论的基础"><a href="#进化论的基础" class="headerlink" title="进化论的基础"></a>进化论的基础</h3><p>特定环境中，资源是有限的，仅能支持一定数量的生命体，而生命的数量是不断增长，为了争夺有限的生存资源必须进行生存斗争，获胜的将存活下来，而失败的遭到淘汰。</p><h3 id="《三体》设定"><a href="#《三体》设定" class="headerlink" title="《三体》设定"></a>《三体》设定</h3><p>大刘将上述思想扩展到整个宇宙，在宇宙层面设定了一种类似的社会学，即宇宙整体资源也是有限的，宇宙中生存着各种各样的文明，而且越是高层次的文明，所需求的资源越多，同时，各文明的最高标准是“生存是文明的第一需要”，要想生存。大刘在这样一个宇宙中来演绎文明的生存策略。</p><h3 id="《行尸走肉》设定"><a href="#《行尸走肉》设定" class="headerlink" title="《行尸走肉》设定"></a>《行尸走肉》设定</h3><p>利用一场突如其来的病毒，打乱既有的世界秩序，将幸存的人类放入一个周围充满危险的，生存资源有限的行尸世界中，来展现末世人类的生存之道。</p><h2 id="《三体》与《行尸走肉》中的策略"><a href="#《三体》与《行尸走肉》中的策略" class="headerlink" title="《三体》与《行尸走肉》中的策略"></a>《三体》与《行尸走肉》中的策略</h2><h3 id="《三体》"><a href="#《三体》" class="headerlink" title="《三体》"></a>《三体》</h3><p>无论是三体人的智子干扰，或是歌者的二向箔抹杀，所采取的都是完全的黑暗森林式策略，没有合作，也没有博弈。毁灭你，与你何干，直截了当。这可以说是把生存竞争推到了极致。在豆瓣上，长期霸占《三体》区评论第一位的文章《信卢瑟，永世不得超生》【1】所吐槽的卢瑟 (loser) 思维，正是这种被极致化的生存竞争思维。</p><h3 id="《行尸走肉》"><a href="#《行尸走肉》" class="headerlink" title="《行尸走肉》"></a>《行尸走肉》</h3><p>加入了更多的元素。主角末世前的职业为警察：原世界秩序，规则的最好代表。包括人性与道德的考察：警察，士兵，医生，教师，牧师，平民，孩子等作为不同类型人群的代表，有着不同的人物展现。家庭式的，社区式的，陷阱式的等各种生存策略都一一考察。</p><h2 id="《三体》与《行尸走肉》的秩序"><a href="#《三体》与《行尸走肉》的秩序" class="headerlink" title="《三体》与《行尸走肉》的秩序"></a>《三体》与《行尸走肉》的秩序</h2><h3 id="《三体》-1"><a href="#《三体》-1" class="headerlink" title="《三体》"></a>《三体》</h3><p>以文革为背景开始整个叙事，所要突出的正是文革时期那种满含猜疑的紧张气氛，以及当时道德秩序的混乱：仅需一场政治运动，便足以煽动无数人将数千年文明所谓道德人性推入深渊。文革中的一大主题就是如何生存下去，而且这仅仅是人类自身内部。将这些脆弱的存在推广到整个宇宙中的不同文明之间，并加以放大，黑暗森林并非不可想象。丧失理性会颠覆道德与人性，完全的理性同样也会。大刘展现了这样一种可能的残酷，道德什么的太靠不住，靠的住的是严格游戏规则，执剑者逻辑明白规则，程心（个人认为圣母程心就是道德与人性的代言人）不明白或者说不愿明白。失去人性失去很多，失去兽性，失去一切，大刘采用了不同的方式强调了这一点【2】。</p><h3 id="《行尸走肉》-1"><a href="#《行尸走肉》-1" class="headerlink" title="《行尸走肉》"></a>《行尸走肉》</h3><p>将故事放在地球范围内，明显更为详细的对不同类型的人群进行了各式各样的考察。按剧情的发展来看，人类与行尸之间的冲突虽然一直是重要背景，但这一背景逐渐被弱化，人类与人类的冲突则逐渐被突出出来。数万年前人类逐渐开始产生社会形态，并利用语言，技术等进行自我规训，最终基本完成自我驯化，形成了一个压抑自己的意义世界【3】，个人认为这可以称作是道德和世界秩序的技术成因。但这种秩序是人类的特定阶段以及相应的特定的环境结合产生的，而末世结束了旧时秩序，同时结束的还有相应的社会和自然条件。在新的环境下，已经高度进化了的现代人，又该如何生存，能否重建一种不同的世界秩序，道德的标准又会发生什么变化？瑞克一行人在经历了众多情况之后，逐渐摆脱了原世界秩序的影响，在以警察为首的这一行人身上，还能看到生存之外的东西以及他们心理的摇摆不定，但是生存竞争已经在他们小组的意识中渗透的越来越深了，不知道采取何种策略才能更好的生存下去，但肯定不同于三体中的黑暗森林。</p><h2 id="达尔文思想与社会学"><a href="#达尔文思想与社会学" class="headerlink" title="达尔文思想与社会学"></a>达尔文思想与社会学</h2><p>达尔文的生存竞争思想在社会学中是很有地位的，并且以此发展出一种社会达尔文主义，而且达尔文思想在社会学中的应用会产生出一些逻辑清晰的，特别诱人的类似于科学中的那种分析方式（像《三体》这样就属一种）。但是达尔文自身过于强调了生存竞争的作用，忽视了生存竞争之外的现象，在社会中应用时也难以处理复杂的社会现象。另外，达尔文思想只是“演化”，而不是“进化”。</p><p>2016.01 于北京回龙观</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>【1】: 详情见：信卢瑟，永世不得超生，个人对这篇文章并不认同。我不认同的并不是其批评没有指中《三体》的要害。恰恰相反，此文对《三体》中的确采用了极致甚至很极端的生存竞争原则。个人不认同的是此文对科幻小说这一题材的误解：科幻小说一个常见手法是假定一个背景，然后以此展开，演绎出一个自洽的世界。大刘既然假定生存是文明的第一需要，那么以此写出的小说必定是这个样子。当然你可以假定生存不是文明的第一需要，来描述一个相对和谐的宇宙，但那将是另一个故事了。类似的例子有经典的以“如果冰的密度比水大”为主题的科幻小说，在这种反事实条件假定下，你不能指责科幻作家的假定存在问题，应该关注的是在这种假定下，作者所展现的世界是不是自洽，以及其展现达到了多深的层次。</p><p>【2】: 刘慈欣在新书《刘慈欣谈科幻》中透漏，他是一个科学主义者和技术崇拜者。其所架构的世界很多时候钢铁般坚硬和冷酷，缺少人性的关怀。个人认为这是一种缺点，但也是一种优点。</p><p>【3】: 此处参考吴国盛《技术哲学讲演录》，文中对技术哲学做了讲演式的概括介绍，人类的自我规训是其中一个重要内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt; 看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘</summary>
      
    
    
    
    <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>科学史上的东方与西方</title>
    <link href="http://starding.github.io/2016/01/07/science-in-east-and-west/"/>
    <id>http://starding.github.io/2016/01/07/science-in-east-and-west/</id>
    <published>2016-01-07T11:14:29.000Z</published>
    <updated>2024-02-20T01:18:54.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="一：科学史上的『科学』"><a href="#一：科学史上的『科学』" class="headerlink" title="一：科学史上的『科学』"></a>一：科学史上的『科学』</h2><p>科学史中所研究的科学范围，是超出我们日常生活中所提到的科学的，在科学史研究中，研究的是更广义意义上的科学，一般包括以下几种：</p><ul><li>古希腊的理性科学</li><li>近代科学革命产生的数理 - 实验科学</li><li>更为广泛意义上的博物学</li><li>更广泛的包括技术系统的科学</li></ul><p>题主所说的“西方科学史”的主线是：</p><ul><li>古希腊</li><li>罗马</li><li>中世纪</li><li>文艺复兴</li><li>科学革命</li><li>现在</li></ul><p>以下叙述中的“科学”也是广义化的，但西方科学发展中的主线与支线，大家一看便知，一个非常重要的线索就是文明的类型与科学的类型这对关系。</p><h3 id="二：科学史上的东方与西方"><a href="#二：科学史上的东方与西方" class="headerlink" title="二：科学史上的东方与西方"></a>二：科学史上的东方与西方</h3><p>追溯到科学发展的源头去看，科学史上有两种比较典型的科学类型：东方的「实用型科学」与古希腊的「理性型科学」，而承载这两种科学类型的文明类型，也有两种类型：水利型文明和非水利型文明。</p><h3 id="水利型文明与实用型科学："><a href="#水利型文明与实用型科学：" class="headerlink" title="水利型文明与实用型科学："></a>水利型文明与实用型科学：</h3><p>代表是四大古文明，即：</p><ul><li>两河流域的美索不达米亚文明</li><li>尼罗河流域的埃及文明</li><li>印度河恒河流域的印度文明</li><li>长江，黄河流域的中国文明</li></ul><p>这几个文明都是近水而生，人们聚集在发达的水系旁边进行农业生产。在这种文明环境中，国家的正常运行，人民的生活是管理阶层首先要考虑的事，相应的，被管理阶层所把持的科学也偏向于实用，多集中于水利（农业灌溉必不可少），天文（农业生产，平时生活，预测王朝命运等都需要天文），医学。</p><h3 id="非水利文明与希腊理性科学："><a href="#非水利文明与希腊理性科学：" class="headerlink" title="非水利文明与希腊理性科学："></a>非水利文明与希腊理性科学：</h3><p>希腊在地理位置上处于地中海沿岸，境内多山，没有大河，也没有大面积富饶的冲积平原，农业灌溉更加依靠雨水而不是与江河有关的水利。希腊人民靠本土条件难以为继，逐渐发展出了比较好的航海和商业。同时，希腊距离美索不达米亚和埃及这些文明不近也不远，便于交流而且不会被完全同化。另一方面，山脉把希腊的政治文明分割成多个小邦国，各个邦国之间形成合作竞争的关系。在此环境下，希腊人发展出了民主城邦制和奴隶制度，保证了闲暇阶层的出现，自由民主的环境也使得政治辩论成为常态，这都培养了希腊人的理性精神。希腊的闲暇阶层不同于东方的管理者，需要极力去维护一个集权大国的正常运行，而是更加注重于对政治合法性等这些内容进行思考。这些条件使得希腊成为科学史上的一朵奇葩，希腊人善于辩论，对事物有着一种寻根究底的热情，超越世俗的学术精神，比如希腊的天文学不同于东方的实用性天文学，它是一种数理行星天文学，是为了解释自然，而不是为了农业，占星等实用目的。用自然自身解释自然，不再求助于神等外物，从泰勒斯的“水是万物之源”，到柏拉图的“理念论”，再到亚里士多德的综合自然哲学，清晰的体现出理性科学出现的过程，这也是现代科学最古老的源头。</p><h2 id="三：两种科学类型的发展"><a href="#三：两种科学类型的发展" class="headerlink" title="三：两种科学类型的发展"></a>三：两种科学类型的发展</h2><h3 id="希腊理性科学的继承及发展："><a href="#希腊理性科学的继承及发展：" class="headerlink" title="希腊理性科学的继承及发展："></a>希腊理性科学的继承及发展：</h3><p>希腊发展出了非功利的，比较系统的，有内在发展逻辑的理性科学传统，比如托勒密的《天文学大成》，欧几里得的《几何原本》，更为重要的是柏拉图和亚里士多德开创的理性的范式：柏拉图的理念论和亚氏自然哲学，他们虽然不同，但都是有内在逻辑的理性系统。希腊 - 罗马文明灭亡之后，这种理性融入到了基督教的教义之中，形成了前期的教父哲学和后期的经院哲学。希腊的文化同时被移植到伊斯兰世界中去，十字军东征之后，便开始在欧洲复兴，经历了航海时代，宗教改革，文艺复兴之后，希腊的这种理性科学的主线便在哥白尼身上连接了起来。紧接着就是近代的科学革命了。要注意的是，这个时候是十六十七世纪，资本主义对科学的发展有作用，但是还远没有到工业革命时的那么大的影响，在这中间主要的动力作用还理性科学内在的发展逻辑，宗教精神在其中也有不小的推动作用（宗教在近代科学产生过程中的作用，也是非常重要的，但讨论又需要大量篇幅了，答主题目中所说的“宗教的严格拘束”不太公平）。</p><h3 id="东方水利文明实用型科学的发展："><a href="#东方水利文明实用型科学的发展：" class="headerlink" title="东方水利文明实用型科学的发展："></a>东方水利文明实用型科学的发展：</h3><p>实用型科学并没有它内在的发展逻辑，它的发展是根据外部环境的需要，一旦外部环境没有了需求时，它也就失去了发展的动力。这在中国历史上表现的非常明显，中国是非常典型的水利文明，集权的政治，官方掌控的科学都是其特点，这种由外部需求推动的科学与外部需要结合的非常紧密，长期来看就表现出科学技术发展的离散性，形不成系统。而且中国这种高度集权的国家，一旦形成了相应的治国文化后，这种文化对超越而无用的学术具有很强的限制作用（宗教还是文化，这是个问题）。中国在两千年的历史中，科学技术（取技术系统与博物学）其实一直都是非常强的，到了明代，达到了最高点。到了这个时候，外部的需求基本被满足，除非产生社会结构的变革（像资本主义与城市那样），或者是科学本身产生像希腊理性科学那样的结构，科学技术的发展就很难前进了。但是二者都是困难的，前者是封建势力不断扼杀资本主义的萌芽，后者是中国的政治文化已经固定，形成很强的束缚了。这个时候，也刚好是西方开始抓住希腊理性之线开始复兴的时候，从此中国在技术上也开始落后了。</p><h2 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h2><p>总之，以一种辉格史的角度来看的话，宏观上西方科学发展的逻辑还是比较清晰的，主线的就是希腊这根理性之线，旁支就是伊斯兰地区在中世纪时期对希腊学术的移植以及再移植，然而伊斯兰世界始终也是典型的东方文明，即使移植了希腊学术，对近代科学产生有着极其重要的影响，但最终也没能成功成为近代科学的策源地。</p><p>亚里士多德认为自由的学术有三个条件：</p><ul><li>闲暇的阶层</li><li>批判传统</li><li>对世界的惊异</li></ul><p>结合科学史可以看到，无论是古希腊，还是近代欧洲，都比较符合这些条件，而集权的国家则难以满足。注意这里没有强调“民主”，只是强调学术发展应有一个相对自由的环境，集权国家在脱去蒙昧之后，也是能创造出相似的条件的。</p><p>2016.01.07 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;一：科学史上的『科学』&quot;&gt;&lt;a href=&quot;#一：科学史上的『科学</summary>
      
    
    
    
    <category term="科哲和科学史" scheme="http://starding.github.io/categories/%E7%A7%91%E5%93%B2%E5%92%8C%E7%A7%91%E5%AD%A6%E5%8F%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>django 中使用原生 sql</title>
    <link href="http://starding.github.io/2016/01/07/raw-sql-in-django/"/>
    <id>http://starding.github.io/2016/01/07/raw-sql-in-django/</id>
    <published>2016-01-07T10:47:03.000Z</published>
    <updated>2024-02-20T01:19:19.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ORM-并非万能"><a href="#ORM-并非万能" class="headerlink" title="ORM 并非万能"></a>ORM 并非万能</h2><p>从功能集上讲，Django 的 ORM 只是 SQL 的一个子集。这意味着很多使用 SQL 能实现的功能，Django ORM 无法完成，更不用说 SQL 甚至是图灵完备的了。例如，直到 1.8 版本，Django 才逐渐实现了<code>CASE</code>、<code>WHEN</code>、<code>IF</code>这些控制流。而这些内容在一些特殊类型的表操作中非常常见，比如说报表管理。</p><p>好在，Django 提供了使用原生 SQL 的接口，这样就能通过原生 SQL 来实现一些复杂的功能。</p><h2 id="SQL-控制流之-CASE-WHEN-一个例子"><a href="#SQL-控制流之-CASE-WHEN-一个例子" class="headerlink" title="SQL 控制流之 CASE WHEN 一个例子"></a>SQL 控制流之 CASE WHEN 一个例子</h2><p>现有一张档案信息表<code>archives</code>：</p><p>字段说明：</p><ul><li><code>number</code> 档案号</li><li><code>type</code> 档案类型</li><li><code>status</code> 档案状态</li><li><code>company</code> 公司</li><li><code>branch_company</code> 分公司</li></ul><p>需求是计算出表中同一<code>type</code>，同一分公司下的档案总数，和<code>status=01</code>的档案数，以及它占档案总数的比值。</p><p>当然，使用编程语言也可以实现这个功能，但是会比较复杂。这个时候可以使用<code>CASE WHEN</code>语句来精确控制表中同一字段下，不同内容的选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">      <span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> status<span class="operator">=</span><span class="string">&#x27;01&#x27;</span> <span class="keyword">THEN</span> status <span class="keyword">END</span>) <span class="keyword">AS</span> status_01,</span><br><span class="line">      <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total,</span><br><span class="line">      CONCAT(FORMAT(<span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> status<span class="operator">=</span><span class="string">&#x27;01&#x27;</span> <span class="keyword">THEN</span> status <span class="keyword">END</span>)<span class="operator">/</span></span><br><span class="line">      <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100</span>, <span class="number">2</span>), <span class="string">&#x27;%&#x27;</span>) <span class="keyword">AS</span> percentage</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      archives</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      status, branch_company</span><br></pre></td></tr></table></figure><p>这样就可以解决上面提出的问题。因为这个表是临时构造的，结果这里就不展示了。</p><h2 id="在上述基础上实现链式查询"><a href="#在上述基础上实现链式查询" class="headerlink" title="在上述基础上实现链式查询"></a>在上述基础上实现链式查询</h2><p>在 Django 的 ORM 中，一个非常好用的功能就是使用链式查询，你可以不断连接 filter 等方法来过滤出想要的内容。</p><p>这在一些特定的场景中特别有用。比如在上面的表中，有时候可能想要某个分公司或中支公司下的数据，有时候又想要单一类型下的数据。如果针对每一种条件组合分别写相应的 SQL 查询的话，会非常复杂，而且有时候组合会特别多。而链式查询比较完美地解决了这个问题。</p><p>为了让原生 SQL 也能有个简单的链式查询，我们需要不断连接 where 中的条件子句。为此可以写一个简单的类来实现它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenQuerySQL</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, table</span>):</span><br><span class="line">        self.table = table</span><br><span class="line">        self.group_by_fields = <span class="string">&quot; &quot;</span></span><br><span class="line">        self.where_conditions = <span class="string">&quot; 1=1 &quot;</span></span><br><span class="line">        self.fields = <span class="string">&quot; &quot;</span></span><br><span class="line">        self.order_by_fields = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">where</span>(<span class="params">self, where_condition</span>):</span><br><span class="line">        <span class="keyword">if</span> where_condition:</span><br><span class="line">            self.where_conditions += <span class="string">&quot; and &quot;</span> + where_condition</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_field</span>(<span class="params">self, fields</span>):</span><br><span class="line">        self.fields += <span class="string">&quot; &quot;</span> + fields</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">group_by</span>(<span class="params">self, group_by_field</span>):</span><br><span class="line">        self.group_by_fields = group_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order_by</span>(<span class="params">self, order_by_field</span>):</span><br><span class="line">        self.order_by_fields = order_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sql</span>(<span class="params">self</span>):</span><br><span class="line">        SQL = <span class="string">&#x27;SELECT &#x27;</span> + self.fields + <span class="string">&#x27; FROM &#x27;</span> + self.table + <span class="string">&#x27; WHERE &#x27;</span> + self.where_conditions + <span class="string">&#x27; GROUP BY &#x27;</span> + self.group_by_fields + <span class="string">&#x27; ORDER BY &#x27;</span> + self.order_by_fields + <span class="string">&quot;;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> SQL</span><br></pre></td></tr></table></figure><p>这个类可以简单地模拟链式查询的功能。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archive_statistics = GenQuerySQL(<span class="string">&#x27;SOME_TABLE&#x27;</span>)</span><br><span class="line">raw_sql = archive_statistics.add_field(<span class="string">&#x27;fields&#x27;</span>).where(<span class="string">&#x27;where_condition&#x27;</span>).group_by(<span class="string">&#x27;group_by_fields&#x27;</span>).order_by(<span class="string">&#x27;order_by_fields&#x27;</span>).sql()</span><br></pre></td></tr></table></figure><p>其中.where 可以多次连接。当然也可以使用另一种方式：先把 where 语句根据条件构造完毕，最终再拼接成 sql 语句。其思想是一样的：先过滤条件，最终再查询数据库。</p><p>2016.01 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;ORM-并非万能&quot;&gt;&lt;a href=&quot;#ORM-并非万能&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker 部署 gitlab</title>
    <link href="http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/"/>
    <id>http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/</id>
    <published>2016-01-07T00:27:22.000Z</published>
    <updated>2024-02-20T01:19:54.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="拉取镜像及启动容器"><a href="#拉取镜像及启动容器" class="headerlink" title="拉取镜像及启动容器"></a>拉取镜像及启动容器</h2><p>参考：<a href="https://docs.gitlab.com/ee/install/docker.html">gitlab documentation</a></p><h3 id="首先使用-dao-加速器拉取-daocker-镜像："><a href="#首先使用-dao-加速器拉取-daocker-镜像：" class="headerlink" title="首先使用 dao 加速器拉取 daocker 镜像："></a>首先使用 dao 加速器拉取 daocker 镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><h3 id="创建-volumes"><a href="#创建-volumes" class="headerlink" title="创建 volumes"></a>创建 volumes</h3><p>简单来说 volumes，就是可以映射到容器中去的容器外部存储空间。你可以将一些比价通用的配置文件，数据，或者是代码等都使用 volumes 的形式存储在容器所在的宿主机器上。这样不仅可以永久保留数据，保证数据的安全性。同时还可以方便的修改 volumes 中的内容，然后重新映射到容器中，这对于需要经常动态修改文件的容器非常有用。<br>在本次部署 gitlab 的时候，创建三个 volumes，分别是&#x2F;mnt&#x2F;volumes&#x2F;gitlab 下的 config，logs，data 目录。<br>启动一个 gitlab 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname git.xiaohuruwei.com \</span><br><span class="line">    --publish 8443:443 --publish 8080:80 --publish 2222:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume /mnt/volumes/gitlab/config:/etc/gitlab \</span><br><span class="line">    --volume /mnt/volumes/gitlab/logs:/var/log/gitlab \</span><br><span class="line">    --volume /mnt/volumes/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>命令参数解释：</p><p>–hostname<br>指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定 git.xiaohuruwei.com</p><p>–publish<br>端口映射，冒号前面是宿主机端口，后面是容器 expose 出的端口</p><p>–volume<br>volume 映射，冒号前面是宿主机的一个文件路径，后面是容器中的文件路径</p><h2 id="配置-nginx，支持-https"><a href="#配置-nginx，支持-https" class="headerlink" title="配置 nginx，支持 https"></a>配置 nginx，支持 https</h2><p>参考：<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https">gitlab set nginx</a></p><p>nginx 配置文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> git.xiaohuruwei.com;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/gitlab.xiaohuruwei.<span class="literal">error</span>.log;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^</span> https://git.xiaohuruwei.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>https proxy</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  git.xiaohuruwei.com;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.<span class="literal">error</span>.log;</span><br><span class="line">    <span class="comment"># ssl 证书配置，这里使用的是自己生成的证书，在访问时会提示证书问题，选择相信即可。</span></span><br><span class="line">    <span class="comment"># 如果想要公认的证书，需要在网络上的一些授权中心生成</span></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/getbase.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/getbase_nopass.key;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> https://localhost:8443;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开放-gitlab-的-https-支持"><a href="#开放-gitlab-的-https-支持" class="headerlink" title="开放 gitlab 的 https 支持"></a>开放 gitlab 的 https 支持</h2><p>仅仅由 nginx 反向代理 https 是不行的，因为还需要打开 gitlab 的 https 支持。</p><p>修改配置文件，在&#x2F;mnt&#x2F;volumes&#x2F;gitlab&#x2F;config&#x2F; 目录下的 gitlab.rb 中添加：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># note the &#x27;https&#x27; below</span></span><br><span class="line">external_url <span class="string">&quot;https://gitlab.example.com&quot;</span></span><br></pre></td></tr></table></figure><p>新建 ssl 目录，同时在该目录下添加 ssl 证书文件，命名要与上述域名中保持一致</p><p>git.xiaohuruwei.com.crt<br>git.xiaohuruwei.com.key</p><p>重新启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure><h2 id="访问-gitlab-测试"><a href="#访问-gitlab-测试" class="headerlink" title="访问 gitlab 测试"></a>访问 gitlab 测试</h2><p>打开 web 界面，默认登录名为 root，密码为 5iveL!fe（已经改为厘米脚印的默认密码），新建一个 project 仓库:test<br>因为 ssl 证书是自己生成的，并不具有全网通用性，因此只能先选择相信证书。在本地设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GIT_SSL_NO_VERIFY=1</span><br></pre></td></tr></table></figure><p>然后克隆仓库：git clone <a href="https://git.xiaohuruwei.com/root/test.git">https://git.xiaohuruwei.com/root/test.git</a></p><h2 id="开启邮件服务"><a href="#开启邮件服务" class="headerlink" title="开启邮件服务"></a>开启邮件服务</h2><p>默认的邮件服务不太好使，所以这里配置自己的邮件服务。参考官方 gitlab stmp 文档。</p><p>使用 163 邮箱，按照官方文档配置后，会发现发送邮件没有起作用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_address&#x27;</span>] = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_port&#x27;</span>] = <span class="number">25</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_user_name&#x27;</span>] = <span class="string">&quot;xiaohuruwei@163.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_password&#x27;</span>] = <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_domain&#x27;</span>] = <span class="string">&quot;163.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_authentication&#x27;</span>] = <span class="string">&quot;login&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable_starttls_auto&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_tls&#x27;</span>] = <span class="literal">false</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_openssl_verify_mode&#x27;</span>] = <span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure><p>查看 log 时，由于 log 比较杂乱，没有发现问题，后来在 ruby 社区发现有人解决过同样的问题：<br><a href="https://ruby-china.org/topics/20450">GitLab 配置通过 smtp.163.com 发送邮件</a><br>以及网易的官方解释：<br><a href="https://www.mail163.cn/fault/analysis/1109.html">网易服务器 smtp 机器要求身份验证帐号和发信帐号必须一致，如果用户在发送邮件时，身份验证帐号和发件人帐号是不同的，因此拒绝发送。</a></p><p>所以又添加了两行配置后测试可以正常使用了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_from&#x27;</span>] = <span class="string">&quot;xiaohuruwei@163.com&quot;</span></span><br><span class="line">user[<span class="string">&#x27;git_user_email&#x27;</span>] = <span class="string">&quot;xiaohuruwei@163.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ssh-方式访问"><a href="#ssh-方式访问" class="headerlink" title="ssh 方式访问"></a>ssh 方式访问</h2><p>因为是使用 docker 部署的，通过 ssh 方式 (比如 git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#x2e;&#120;&#x69;&#97;&#111;&#x68;&#117;&#114;&#x75;&#x77;&#x65;&#105;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#x2e;&#120;&#x69;&#97;&#111;&#x68;&#117;&#114;&#x75;&#x77;&#x65;&#105;&#x2e;&#x63;&#x6f;&#109;</a>) 访问会有两层认证：</p><p>一层是 freelancer 服务器的认证<br>另一层是 gitlab 的认证。<br>后者需要使用 ssh-key<br>前者可能需要 ssh 本身的反向代理 (现在使用的 nginx 不支持除 http，https 以外的反向代理)，</p><p>现在发现使用端口转发的形式比较困难，但是可以改变默认的 gitlab 的 ssh 端口为非标准端口：<br>直接修改 gitlab 配置文件中的变量：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_shell_ssh_port = <span class="number">2222</span></span><br></pre></td></tr></table></figure><p>然后重新启动 docker 容器，就可以在 web 界面中看到相应的 ssh 地址发生了改变：<br>ssh:&#x2F;&#x2F;<a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#46;&#120;&#105;&#97;&#x6f;&#104;&#x75;&#x72;&#117;&#x77;&#x65;&#105;&#x2e;&#x63;&#111;&#109;">&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#46;&#120;&#105;&#97;&#x6f;&#104;&#x75;&#x72;&#117;&#x77;&#x65;&#105;&#x2e;&#x63;&#111;&#109;</a>:2222&#x2F;root&#x2F;test.git 然后就直接可以继续使用 git clone 来继续操作了</p><p>2016.01 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;拉取镜像及启动容器&quot;&gt;&lt;a href=&quot;#拉取镜像及启动容器&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 daocloud 持续集成应用</title>
    <link href="http://starding.github.io/2016/01/07/daocloud-deploy/"/>
    <id>http://starding.github.io/2016/01/07/daocloud-deploy/</id>
    <published>2016-01-06T23:24:25.000Z</published>
    <updated>2024-02-20T01:20:06.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>来自维基百科的：<a href="https://zh.wikipedia.org/wiki/%E8%B4%A7%E7%89%A9%E5%B4%87%E6%8B%9C%E7%BC%96%E7%A8%8B">货殖崇拜编程</a></p><p>为因 GFW 屏蔽访问不了维基百科的同学准备的：</p><blockquote><p>货物崇拜编程（Cargo Cult Programming）是一种计算机程序设计中的反模式，其特征为不明就里地、仪式性地使用代码或程序架构。货物崇拜编程通常是程序员既没理解他要解决的 bug、也没理解表面上的解决方案的典型表现。</p></blockquote><blockquote><p>这个名词有时也指不熟练的或没经验的程序员从某处拷贝代码到另一处，却不太清楚其代码是如何工作的，或者不清楚在新的地方是否需要这段代码。也可以指不正确或过份的应用设计模式、代码风格或编程方法，却对其原理不明就里。</p></blockquote><blockquote><p>货物崇拜编程来源于“货物崇拜”这个词。其衍生词还有“货物崇拜软件工程”。</p></blockquote><p>在阅读任何教程类的文章时，都不要有编程上的货殖崇拜，有些内容是需要你根据自己的实际情况修改一些内容的，需要你理解它，如果不理解某些内容，就需要先熟悉一下相关的知识。</p><h2 id="daocloud-介绍"><a href="#daocloud-介绍" class="headerlink" title="daocloud 介绍"></a>daocloud 介绍</h2><p>daocloud 提供基于 docker 进行持续集成的服务，使用它可以很方便的完成项目的自动化构建以及持续发布等功能。</p><p>当然，如果要使用 daocloud 持续化集成应用，首先你需要注册一个 daocloud 账号。如果你效力于某个公司的话，还要通知该公司把你的账号拉到公司用户组里，这样才能使用该公司的资源。</p><h2 id="持续集成简单的-html5-应用"><a href="#持续集成简单的-html5-应用" class="headerlink" title="持续集成简单的 html5 应用"></a>持续集成简单的 html5 应用</h2><h3 id="本小节使用场景"><a href="#本小节使用场景" class="headerlink" title="本小节使用场景"></a>本小节使用场景</h3><ul><li>拥有自己的主机</li><li>将主机添加到了 daocloud 上</li><li>只使用 daocloud 的自动构建和部署功能</li><li>镜像也要部署到自己的主机上。</li></ul><h3 id="什么是「简单的-html5-应用」"><a href="#什么是「简单的-html5-应用」" class="headerlink" title="什么是「简单的 html5 应用」"></a>什么是「简单的 html5 应用」</h3><p>只有前端页面，并且使用 nginx 提供服务。</p><h3 id="部署大致解决方案"><a href="#部署大致解决方案" class="headerlink" title="部署大致解决方案"></a>部署大致解决方案</h3><p>本文假设一个使用场景：拥有自己的主机，并且绑定到了 daocloud 上，然后想通过 daocloud 进行持续化地部署到自己的主机上。如果想要部署一个纯前端项目，需要把 nginx 集成进去，然后使用 nginx 来提供服务。</p><h3 id="构建应用前的准备"><a href="#构建应用前的准备" class="headerlink" title="构建应用前的准备"></a>构建应用前的准备</h3><h4 id="应用目录结构"><a href="#应用目录结构" class="headerlink" title="应用目录结构"></a>应用目录结构</h4><p>因为 daocloud 是基于 daocker 的，在使用 daocloud 之前，我们需要按照 docker 的规范，把自己的项目改成支持打包成镜像的应用，对于 html5 项目来说，就是添加 Dockerfile 文件和配置好所需要的 nginx 配置文件。比如我有一个应用叫 jinli，其目录结构为 (你的目录结构和这个可能也不一样)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jinli/  # 项目根目录</span><br><span class="line">├── jinli/  # 具体的应用目录</span><br><span class="line">│   ├── images/ # 图片</span><br><span class="line">│   ├── index.html  # 默认的检索 html</span><br><span class="line">│   ├── scripts/  #  js 文件夹</span><br><span class="line">│   └── styles/    # 存放 css 的文件夹</span><br><span class="line">├── Dockerfile   # Dockerfile</span><br><span class="line">├── jinli.conf   # 本应用的 nginx 配置文件</span><br><span class="line">└── log/  # log 文件</span><br></pre></td></tr></table></figure><p>在这个目录结构中，和 docker 镜像构建是就是 Dockerfile 这个文件，jinli.conf 是个将要一起打包放入 docker 镜像中的文件，其他的都是应用本身的文件。</p><h4 id="创建-Dockerfile-文件"><a href="#创建-Dockerfile-文件" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h4><p>Dockerfile，就是一个 daocker 的规则文件，就像 make 的 Makefile 一样。Dockerfile 描述了将自己的应用构建成 docker 镜像的过程。<br>在本例中，Dockerfile 的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 nginx 服务</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.9</span>.<span class="number">5</span></span><br><span class="line"><span class="comment"># copy 代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /src</span></span><br><span class="line"><span class="comment"># 添加 nginx 配置文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> jinli.conf /etc/nginx/conf.d/</span></span><br><span class="line"><span class="comment"># 去掉默认的 nginx 配置文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure><p>Dockerfile 解释：</p><ul><li>首先，想象将要构建的 docker 镜像包含一个 linux 操作系统。</li><li><code>FROM nginx:1.9.5</code> 的意思就是，将 1.9.5 版本的 nginx 服务集成到自己的镜像中（其实操作系统就是在这一步引入的，nginx 本身也是一个镜像，它是建立在一个 linux 操作系统之上的，拉取 nginx 的时候，会连把 nginx 连带其附着的 linx 系统整个一起拉下来）。</li><li><code>COPY . /src</code> 的意思是将当前目录下的代码复制到镜像中（的操作系统中）的 &#x2F;src 目录下</li><li><code>COPY jinli.conf /etc/nginx/conf.d/</code> 的意思是，将当前目录下写好的 nginx 配置文件，复制到镜像（的操作系统）中的相应目录下。</li><li>删掉原来默认的 nginx 配置（因为默认配置文件会占用掉 localhost，不知道有没有更好的解决办法）</li></ul><h4 id="配置在-docker-中使用的-nginx-配置文件。"><a href="#配置在-docker-中使用的-nginx-配置文件。" class="headerlink" title="配置在 docker 中使用的 nginx 配置文件。"></a>配置在 docker 中使用的 nginx 配置文件。</h4><p>本示例中，nginx 配置文件命名为 jinli.conf。把它打包到镜像中，来给 html5 应用提供服务，这与平时直接在服务器上部署没有什么很大的差别，需要注意的就是：</p><ul><li>server_name 为 localhost，因为这个 server_name 是在 docker 容器内部使用的。</li><li>location 中的 root 文件夹是 docker 容器中的地址，不是宿主机的地址</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">access_log</span> /src/log/jinli.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /src/log/jinli.<span class="literal">error</span>.log;</span><br><span class="line">    <span class="comment"># 这里你还可以选择根据需要配一些 gzip 等选项</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span> /src/jinli/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将应用提交到 github 上，比如具体为：xiaohuruwei&#x2F;jinli.git</p><p>以上已经包含全部必须的材料了，下面进入 daocloud 环节。</p><h3 id="使用-daocloud-进行持续构建镜像以及发布"><a href="#使用-daocloud-进行持续构建镜像以及发布" class="headerlink" title="使用 daocloud 进行持续构建镜像以及发布"></a>使用 daocloud 进行持续构建镜像以及发布</h3><p>因为前面的步骤已经构建好了一个支持 docker 的代码版本，而且不需要外联像 mysql 这样的外部服务，因此可以直接将其当做一个单应用的镜像来构建。</p><p>在这方面，daocloud 已经有了完善的文档，可以直接参考其中的创建新项目章节，以及持续集成章节。</p><p>第四节创建新项目，根据具体情况选择要绑定需要的 git 源<br>第五节持续集成和镜像构建，在简单的 html 部署中，不需要了解 daocloud.yml 的写法<br>第九节中的向自由主机集群上发布应用</p><p>在上面的过程中，核心部分如下：</p><ul><li>绑定 git 源</li><li>选择要部署的 git 仓库，并构建成镜像</li><li>部署到自有主机上</li><li>将后续自动持续部署的设置打开</li><li>在「代码构建」具体项目的「设置」中，将持续集成打开，设置好镜像和持续集成的触发规则，比如：在向 docker-support 分支提交代码时，就触发自动持续集成。</li><li>在「应用列表」中的「发布」设置中，将自动发布打开。</li></ul><h3 id="发布完成之后需要做的工作"><a href="#发布完成之后需要做的工作" class="headerlink" title="发布完成之后需要做的工作"></a>发布完成之后需要做的工作</h3><p>发布完成之后，可以在 daocloud 上看到所创建的容器的具体信息。包括映射到宿主机上的端口号等等，点击端口号后可以看到该应用的访问地址，打开可以测试是否部署成功了</p><p>为方便后面的叙述，这里假设映射出的端口号为 8888。因为是发布到自己的主机上，所以还需要自己配置域名以及 nginx 反向代理来对外提供访问服务。假设有一个域名已经绑定在了自己的主机上，这里假设为 xiaohuruwei.com.</p><p>登陆自己的主机，并配置 nginx 文件，如果是使用 apt-get 一类的包管理工具安装的，那么应该是在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录下添加 jinli.conf:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/jinli.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/jinli.<span class="literal">error</span>.log;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line">    <span class="comment"># 可以根据需要设置其他配置项</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后访问 xiaohuruwei.com 就可以看到内容了</p><p>另外，需要在使用 daocloud 的时候，将自动构建和持续发布都打开，这样下次使用时，只需要往 github 推代码时，触发了你设定的更新规则，就会持续构建镜像并发布了。</p><h2 id="持续集成依赖外部服务的应用"><a href="#持续集成依赖外部服务的应用" class="headerlink" title="持续集成依赖外部服务的应用"></a>持续集成依赖外部服务的应用</h2><p>以 django 应用为例</p><h3 id="本文适用的场景"><a href="#本文适用的场景" class="headerlink" title="本文适用的场景"></a>本文适用的场景</h3><ul><li>拥有自己的主机</li><li>将主机添加到了 daocloud 上</li><li>只使用 daocloud 的自动构建和部署功能<br>所依赖的外部服务已经（以 daocke 容器）存在于自己的主机上，镜像也要部署在自己的主机上。在部署的同时连接主机上已经存在的外部服务（如 mysql，redis 等）。</li></ul><h3 id="依赖外部服务的应用"><a href="#依赖外部服务的应用" class="headerlink" title="依赖外部服务的应用"></a>依赖外部服务的应用</h3><p>在 docker 领域中，如果一个 docker 镜像自身需要其他镜像来提供服务，就说这个镜像是带外部服务的。</p><p>以一个简单的 django 应用为例，如果这个 django 应用自身无法完成任务，而需要 mysql 或者其他数据库作为数据的持久化服务，那么这个 django 应用就是依赖外部服务的。</p><h3 id="构建前的准备"><a href="#构建前的准备" class="headerlink" title="构建前的准备"></a>构建前的准备</h3><p>准备同 html5 接近，因为需要连接外部服务，而且因为 uwsig 服务默认不支持静态文件的处理，所以多了一些对原代码的改造。</p><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>首先是 django 应用的目录，比如有一个应用叫 taikang，目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">taikang# 项目根目录</span><br><span class="line">├── Dockerfile# Dockerfile 文件</span><br><span class="line">├── logs</span><br><span class="line">├── manage.py</span><br><span class="line">├── Makefile# makefile 文件</span><br><span class="line">├── requirements.txt# 应用依赖的 python 库</span><br><span class="line">├── templates</span><br><span class="line">└── taikang# 应用目录</span><br><span class="line">├── __init__.py</span><br><span class="line">├── models.py</span><br><span class="line">├── settings.py   # django 的配置文件</span><br><span class="line">├── urls.py</span><br><span class="line">├── views.py</span><br><span class="line">└── wsgi.py</span><br></pre></td></tr></table></figure><p>Dockerfile 文件编写<br>Dockerfile 文件的含义和 html5 部署中是完全相同的，这里为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python2.7.10 版本作为基础服务</span></span><br><span class="line"><span class="keyword">from</span> python:<span class="number">2.7</span><span class="number">.10</span></span><br><span class="line">将当前项目中的内容全 copy 到镜像中的 /src 目录下</span><br><span class="line">COPY . /src</span><br><span class="line"><span class="comment"># 安装 django 应用依赖的库，这里设置为豆瓣的 pypi 源</span></span><br><span class="line">RUN cd /src; pip install -r  requirements.txt -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line"><span class="comment"># 镜像暴露出 8000 端口</span></span><br><span class="line">EXPOSE <span class="number">8000</span></span><br><span class="line"><span class="comment"># 设置工作目录为代码所在目录</span></span><br><span class="line">WORKDIR  /src</span><br><span class="line"><span class="comment"># 设置应用启动命令</span></span><br><span class="line">CMD [<span class="string">&quot;make&quot;</span>, <span class="string">&quot;start-uwsgi&quot;</span>]</span><br></pre></td></tr></table></figure><h4 id="Makefile-文件编写"><a href="#Makefile-文件编写" class="headerlink" title="Makefile 文件编写"></a>Makefile 文件编写</h4><p>可以注意到，上述最后的启动命令中使用了 make 命令，这也是前面目录结构中 Makefile 文件的作用所在。有关 makefile 的知识，这里不再详述。<br>总之可以让你更方便的管理应用，这里直接贴出 makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uwsig 启动的 host 和端口 </span></span><br><span class="line">host:=0.0.0.0</span><br><span class="line">port:=8000</span><br><span class="line"><span class="comment"># debug 的时候直接使用 django 自带的服务启动</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">    ./manage.py runserver <span class="variable">$(host)</span>:<span class="variable">$(port)</span></span><br><span class="line"><span class="comment"># 启动 uwsgi 服务</span></span><br><span class="line"><span class="section">start-uwsgi:</span></span><br><span class="line">    uwsgi --socket <span class="variable">$(host)</span>:<span class="variable">$(port)</span> \</span><br><span class="line">        --chdir <span class="variable">$(<span class="built_in">shell</span> pwd)</span> \</span><br><span class="line">        --wsgi-file taikang/wsgi.py \</span><br><span class="line">        --master \</span><br><span class="line">        --process 4 \</span><br><span class="line">        --pidfile <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/uwsgi.pid</span><br><span class="line"><span class="comment"># 停止 uwsgi 服务</span></span><br><span class="line"><span class="section">stop-uwsgi:</span></span><br><span class="line">    uwsgi --stop uwsgi.pid</span><br><span class="line"><span class="comment"># 重载 uwsgi 服务</span></span><br><span class="line"><span class="section">reload-uwsgi:</span></span><br><span class="line">    uwsgi --reload uwsgi.pid</span><br><span class="line"><span class="comment"># 收集静态文件</span></span><br><span class="line"><span class="section">collectstatic:</span></span><br><span class="line">    ./manage.py collectstatic --noinput</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: debug \</span></span><br><span class="line">    collectstatic \</span><br><span class="line">    reload-uwsgi \</span><br><span class="line">    start-uwsgi \</span><br><span class="line">    stop-uwsgi</span><br></pre></td></tr></table></figure><h4 id="静态文件支持"><a href="#静态文件支持" class="headerlink" title="静态文件支持"></a>静态文件支持</h4><p>在 uwsgi 提供服务时，静态文件需要单独进行处理，目前推荐使用 django 的 whitenoise 库。可以方便的提供静态文件服务，仅仅需要几行配置。</p><h4 id="通过环境变量来连接服务"><a href="#通过环境变量来连接服务" class="headerlink" title="通过环境变量来连接服务"></a>通过环境变量来连接服务</h4><p>在使用 docker 部署项目，当需要连接外部的服务时，一般通过 link + 环境变量的参数进行。而为了支持环境变量的形式，我们的 django 应用也要做一些相应的改变。具体就是修改 settings.py 中的配置。</p><p>修改 settings.py 文件，以 mysql 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原来的 mysql 配置文件</span></span><br><span class="line"><span class="comment">#DATABASES = &#123;</span></span><br><span class="line"><span class="comment">#    &#x27;default&#x27;: &#123;</span></span><br><span class="line"><span class="comment">#        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;NAME&#x27;: &#x27;starding_taikang&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;USER&#x27;: &#x27;root&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;PASSWORD&#x27;: &#x27;your_password_here&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;HOST&#x27;: &#x27;localhost&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;PORT&#x27;: &#x27;3306&#x27;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"><span class="comment"># 通过获取环境变量的形式来获取服务</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 导入 os 库</span></span><br><span class="line">mysql_name = os.environ.get(<span class="string">&#x27;MYSQL_INSTANCE_NAME&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;taikang&quot;</span>  <span class="comment"># 获取数据库名称</span></span><br><span class="line">mysql_user = os.environ.get(<span class="string">&#x27;MYSQL_USERNAME&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;root&quot;</span>  <span class="comment"># 获取 mysql 用户名</span></span><br><span class="line">mysql_password = os.environ.get(<span class="string">&#x27;MYSQL_PASSWORD&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;your_password&quot;</span>  <span class="comment"># 获取密码</span></span><br><span class="line">mysql_host = os.environ.get(<span class="string">&#x27;MYSQL_ADDR&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;127.0.0.1&quot;</span>  <span class="comment"># 获取服务地址</span></span><br><span class="line">mysql_port = <span class="string">&quot;3306&quot;</span></span><br><span class="line"><span class="comment"># 直接使用上面的变量代替字符串</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">       <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;NAME&#x27;</span>: mysql_name,</span><br><span class="line">       <span class="string">&#x27;USER&#x27;</span>: mysql_user,</span><br><span class="line">       <span class="string">&#x27;PASSWORD&#x27;</span>: mysql_password,</span><br><span class="line">       <span class="string">&#x27;HOST&#x27;</span>: mysql_host,</span><br><span class="line">       <span class="string">&#x27;PORT&#x27;</span>: mysql_port</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-daocloud-部署构建好的-taikang-项目"><a href="#使用-daocloud-部署构建好的-taikang-项目" class="headerlink" title="使用 daocloud 部署构建好的 taikang 项目"></a>使用 daocloud 部署构建好的 taikang 项目</h3><p>步骤基本同 html5 部署，假设你完成镜像构建之后，产生的镜像地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daocloud.io/xiaohuruwei/taking:latest</span><br></pre></td></tr></table></figure><p>下一步在使用镜像部署的时候，需要连接外部服务，具体是手动编辑 yaml 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">takang_test:</span><br><span class="line">  image: daocloud.io/xiaohuruwei/taking:latest</span><br><span class="line">  restart: always</span><br><span class="line">  external_links:</span><br><span class="line">  - mysql1:mysql  <span class="comment"># 前面的 mysql1 是你主机上已经存在的 mysql 的容器实例，冒号后面是别名</span></span><br><span class="line">  ports:</span><br><span class="line">  - <span class="string">&#x27;8000&#x27;</span></span><br><span class="line">  environment:    <span class="comment"># 环境变量    </span></span><br><span class="line">  - MYSQL_ADDR=mysql</span><br></pre></td></tr></table></figure><p>但是我发现这种方法似乎有一些 bug，如果上面的方法不成功，那么你就先直接部署，部署成功之后，再去修改 yaml 文件成为上面描述的样子。在修改 yaml 文件的时候，daocloud 会提示重新部署，选择确定即可。</p><p>至此，django 项目也部署完成了。然后同 html5 项目部署一样，把各种自动构建，自动发布的功能打开就行了。</p><p>注意：由于 django 项目是使用 uwsgi 部署的，直接访问 daocloud 给出的地址是错误的，这个时候必须配置 nginx 反向代理。</p><p>附上 uwsgi 部署的 django nginx 代理配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/taikang.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/taikang.<span class="literal">error</span>.log;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/javascript text/css application/xml;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">        <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:32801</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2016.01 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker——从隐喻说起</title>
    <link href="http://starding.github.io/2016/01/07/docker-a-metaphor/"/>
    <id>http://starding.github.io/2016/01/07/docker-a-metaphor/</id>
    <published>2016-01-06T17:28:10.000Z</published>
    <updated>2024-02-20T01:19:44.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Docker-的学术化定义"><a href="#Docker-的学术化定义" class="headerlink" title="Docker 的学术化定义"></a>Docker 的学术化定义</h2><p>首先来看维基百科的定义：</p><blockquote><p>Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.</p><p>Docker 是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在 Linux 操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker 利用 Linux 核心中的资源分离机制，例如 cgroups，以及 Linux 核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一 Linux 实体下运作，避免启动一个虚拟机器造成的额外负担。</p></blockquote><p>通过这个比较学术化的定义，可以模糊的知道 docker 是可以实现自动化部署之类功能的工具，但是并不能清楚的理解它到底牛逼在什么地方，又好在哪里。为了搞明白这些，只看定义是远远不够的，一种手段是可以在长期使用 docker 的过程中，逐渐体会到 docker 的优势。但是对于一个从未接触过 docker，甚至对部署都不是很了解的新人，应该怎么快速理解这一点呢？一个比较好的办法，就是借助于隐喻。</p><h2 id="Docker-的隐喻"><a href="#Docker-的隐喻" class="headerlink" title="Docker 的隐喻"></a>Docker 的隐喻</h2><p>关于「隐喻」的概念，有一篇文章单独介绍：「隐喻」</p><p>同样，要快速理解 docker，抓出核心思想，隐喻是非常重要的</p><h3 id="字面意思：Docker——码头工人。"><a href="#字面意思：Docker——码头工人。" class="headerlink" title="字面意思：Docker——码头工人。"></a>字面意思：Docker——码头工人。</h3><p>Docker 的名称本身就带有隐喻的性质：在全球物流系统中，一个非常重要的发明就是集装箱。</p><p>集装箱重要在哪里？为了理解这件事情，可以先考察一下集装箱出现之前的物流情况：货物生产出来之后，装箱，然后一箱一箱的搬到卡车上，然后再一箱一箱卸下来，送上火车，运送到码头附近的火车站，再一箱一箱卸下来，装上卡车，拉到货轮上，一箱一箱的装上去….</p><p>可以发现，大量的时间，人力，物力全部浪费在了中间的装卸上，在物流里面，货物真正在路上的时间是一定的，在交通技术得到改善之前，也很难去缩短。于是货物的装卸这部分时间，就成了物流中的瓶颈，而这个局面在集装箱出现之后，得到了很大的改善。</p><p>集装箱重要在它提供了一种通用的封装货物的标准规格（说白了指的就是它的尺寸，外形是符合一定标准的），这样就产生了一个巨大的优点：在物流运输中，只需要在运输前一次封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上，卸船之后直接再放上火车，卡车，运送到目的地。而且，集装箱本身的标准，使得它非常容易机械化操作，这也引发了以集装箱为中心的整个全球物流的标准化进程，从而节省了大量的时间资源和人力资源，促进了全球资源的流动与重新配置。</p><h3 id="Docker（码头工人）正是借用了集装箱的隐喻"><a href="#Docker（码头工人）正是借用了集装箱的隐喻" class="headerlink" title="Docker（码头工人）正是借用了集装箱的隐喻"></a>Docker（码头工人）正是借用了集装箱的隐喻</h3><p>Docker 就像往集装箱里装货物的码头工人那样，它把应用打包成具有某种标准规格的集装箱，用计算机领域的语言来说，这种按照一定规格封装的集装箱叫「镜像」。其实就是将你原来的代码添加点额外的内容，格式啥的，整出来的一个静态的应用。而且就像光盘镜像只能由特定的解析光盘镜像格式的软件来解析一样，这个镜像也只能由 docker 来解析。</p><p>集装箱减少了货物的运输工作量，那 Docker 镜像又有什么相似的优势呢？首先可以看看 Docker 出现之前的应用部署是啥样的。</p><p>在 Docker 出现之前，比如说我要部署一个 django 应用，要做哪些事情：<br>首先我得有个 Python 环境，比如我用的是 Python3，而你机器上是 python2，那 ok，先装个 python3 吧，一看装起来还挺麻烦，要先装各种依赖，还要解决一些可能的冲突，没办法硬着头皮上吧。</p><p>装完 python 之后，因为有 pip 这些神奇的工具，很快就装完 django，需要的 python 库了。咦，发现还要装 mysql，还用了 redis。没办法，继续上吧，下载，安装，配置。费了九牛二虎之力终于搞完了。一天就这么过去了。</p><p>啥？你告诉我原来的服务器不用了，要换一台服务器？我靠，那重新来一遍吧，有了昨天的经验，只用了大半天就搞定了。</p><p>啥？你说咱们的应用做的太好，要进行推广，需要指导它们部署？我选择狗带，删代码走人。</p><p>上面的描述可能有些夸张，但也绝不是罕有发生。在 docker 出现之前，这些正是运维人员很多时候都在做的事情，在不断的重复工作上，浪费了巨大的人力物力。</p><h2 id="docker-出现之后"><a href="#docker-出现之后" class="headerlink" title="docker 出现之后"></a>docker 出现之后</h2><h3 id="标准的交付件"><a href="#标准的交付件" class="headerlink" title="标准的交付件"></a>标准的交付件</h3><p>说 docker 就像集装箱那样，关键作用就是「标准化」，它的具体产物是什么呢，其实就是「镜像」。这个词说实话太玄乎，当然原文 image 本身也挺玄乎的，玄乎的原因是它根据一些特殊的场景引申了本来的含义。它本身是「画像，映像」的意思，画像又有「现实物体的抽象描绘」等一层意思，而且画像本身可以很容易的复制，后来又有了「原画像复制品」一类的意思，再后来直接就拿来表光盘镜像（很容易复制的存储影像的东西，只不过画像是画在纸上，但这种影像以数字形式存在于光盘上）。当然「镜像」在汉语中就有「复制品」的含义，只不过加入了汉字独有的意境，显得玄乎，朦胧了。</p><p>当然 image 后来又被引申了，在 docker 中，它指的就是，把你的应用本身，按照一定的格式封装（其实就是一些按规则执行的命令行）成一种具有某种标准规格的东西（就像集装箱把你的货物封装起来类似）。就像光盘镜像那样把原影像格式给封装成能直接放在刻成光盘的格式一样。这种格式只能由 docker 本身解析，就像你的光盘镜像也只能使用特定的工具解析类似。</p><p>在 docker 中，镜像是无法直接运行的，我猜想这并不是技术上的原因，而是工程设计上的原因。因为一般来说，一个软件的某个具体版本只会打包成一个镜像。如果镜像可以配置，运行的话，在使用过程中很可能会对镜像造成破坏。</p><p>那怎么样避免这个问题呢，就是再给他加一层，也就是相当于多了个分身术，只要本尊没问题，分身怎么扑街都不会真正的跪掉。多加的这一层分身，就叫容器（container），这个名字也挺形象，它就像个瓶子这样的容器一样，你的应用在里面运行，而且多了一层安全机制。你想使用服务或把你的应用跑起来的话，只需要使用镜像新创建一个容器就可以了（也是一条命令搞定），而镜像还放在那里不动，没办法，金贵嘛。</p><p>笼统地说，镜像分为两种：</p><p>一种简单的称之为基础独立镜像吧。它一般是一个独立的服务，最独立的服务镜像，莫过于各种精简的操作系统了。它们被封装在镜像中，作为最基础的服务，基本上所有镜像都离不开它。但是对于我们这些普通应用开发者来说，一般不会直接使用这种镜像。<br>如果要使用这种镜像，我们的 Dockerfile 一般类似于下面这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础的操作系统</span></span><br><span class="line"><span class="keyword">From</span> ubuntu:latest</span><br><span class="line"><span class="comment"># 构建其他需要的其他服务，以及我们自己的代码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install mysql</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .  /src/</span></span><br></pre></td></tr></table></figure><p>另一种，姑且称之为组合镜像。它建立在一个独立镜像的基础上，在上面组合了其他服务，比如 python 服务，或是 mysql 之类的服务。作为比较顶层的应用开发者，我们一般会直接使用这种组合好后的服务镜像。<br>Dockerfile 则类似于这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础 python 服务</span></span><br><span class="line"><span class="keyword">From</span> python:<span class="number">2.7</span>.<span class="number">10</span> </span><br><span class="line"><span class="comment"># 我们自己的代码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install mysql</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .  /src/</span></span><br></pre></td></tr></table></figure><p>其实像上面的 python 服务，其本身也是建立在一个基础的操作系统之上的。如果我们查看 dockerhub 上的 python 的 Dockerfile，就可以明确这一点：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> buildpack-deps:jessie    <span class="comment"># jessie 就是一个精简的 debian 操作系统</span></span><br><span class="line"><span class="comment"># remove several traces of debian python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get purge -y python.*</span></span><br></pre></td></tr></table></figure><p>而我们自己构建的镜像，也可以称之为一种组合镜像。我们一般使用 Dockerfile 将自己的应用代码，加上上面的某些具体的服务镜像（比如 python）再组合起来，就可以构建我们自己的应用了。</p><h3 id="Docker-究竟做了什么简化？"><a href="#Docker-究竟做了什么简化？" class="headerlink" title="Docker 究竟做了什么简化？"></a>Docker 究竟做了什么简化？</h3><p>docker 正是在部署过程中，将上面那些重复的部分，由 docker 自动化完成。只需要在第一次部署时，构建完可用的 docker 镜像。然后在以后使用的过程中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。所需要的仅仅是安装了 docker 的服务器，一个 Dockerfile 文件，以及比较流畅的网络而已。真可谓，『一次构建，到处部署』。</p><p>需要 python3 环境？直接 from python:3.x 搞定。<br>需要迁移服务器？直接把应用连带 Dockerfile，volumes 数据拷贝到新服务器上，几条命令又搞定<br>需要作为服务给别人使用？Dockerfile 即是最清晰的部署文档，维护一个官方镜像即可，谁需要就直接拉下来几条命令部署上就行了。<br>到这个地方，你可能已经发现了，docker 镜像成为了一种像集装箱那样的标准货件。它不像传统的软件交付方式那样，只把代码以及说明文档之类的给你就完了，而是直接给你一个标准 docker 货件，它可能 Dockerfile，或者直接就是镜像，这个标准件不仅包括了代码本身，还包括了代码运行的 OS 等各种整体环境。</p><p>于是，谁想用我的服务，直接拉取镜像，实例化一个容器就可以了，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p><h3 id="当然优点不止于此"><a href="#当然优点不止于此" class="headerlink" title="当然优点不止于此"></a>当然优点不止于此</h3><p>就像集装箱带来的物流领域的「标准化」，不只是单纯影响集装箱这个范围本身，而是整个领域的运输器械，物流管理等整个领域的标准化和效率的提高。</p><p>也就是说基于一件核心事物「标准化」，可以做更多的事情，比如集装箱的机械自动搬运等。docker 也是类似的，一旦这种软件标准件建立起来之后，就可以基于这种标准件和相应的管理方式带来更多的改变。比如</p><h3 id="统一的管理服务"><a href="#统一的管理服务" class="headerlink" title="统一的管理服务"></a>统一的管理服务</h3><p>使用 docker 部署的应用，都会在 docker 的管理范围之内。这也是 docker 的另一个非常大的优点，它提供了一种隔离的空间，把服务器上的零散的部署应用集中起来进行管理。</p><p>举个例子，比如我一个服务器上部署了 n 多服务，有 mysql，redis，rabbitmq，其他还有一堆应用。有一天我服务器突然断电重启了，准备茶几吧。那些没有设置自动重启的应用，那些重启出问题的应用，那些你甚至都不知道隐藏在某个角落里的重要应用没启动成功….</p><p>然而使用 docker，一眼就可以看出那些应用正常启动了，那些应用又出问题了。接下来只用有条不紊的处理就 ok 了。</p><h3 id="持续交付上的应用"><a href="#持续交付上的应用" class="headerlink" title="持续交付上的应用"></a>持续交付上的应用</h3><p>持续交付有一些超出范围，自己去寻找答案吧</p><h2 id="关于-docker-的一个误解"><a href="#关于-docker-的一个误解" class="headerlink" title="关于 docker 的一个误解"></a>关于 docker 的一个误解</h2><p>有人可能会问，我只有一台服务器，也不太可能会迁移。我的 python 服务，mysql 服务，只需要部署一次，就可以在以后重复使用了。那这样 docker 对于我来说还有优势吗？毕竟 docker 也是有学习成本的。</p><p>如果你真的确信你的应用都是一次性的，而且只提供给自己使用，那么 docker 在这种场景下的优势不是特别明显：即便是 docker，最初的构建也是需要有人做的，也是有工作量的。这和你一次性部署的工作量差不多。但是即便如此也是又有点的，它提供了一个干净，隔离的环境。</p><p>另外，很多人说 docker 改变了运维世界，这句话是从群体角度来说的，像 mysql，python 这样的使用群体众多的应用，以及会经常迁移，变动，重新部署的应用，docker 化之后，整个群体所节省的时间，是非常巨大的。</p><p>也就是说，docker 并不能部署的工作「减少为 0」，比较好的情况下是「基本减少为 1」，因为无论如何都需要把应用及所在环境构建一遍，就像集装箱虽然减少了运输途中的搬运过程，但是把货物搬进集装箱这一次操作是难以避免的，但这可以成为「一次构建，到处交付」的基础。你第一次构建自己的镜像时，就像往集装箱里装东西是类似的，需要和直接在机器上部署差不多的工作量。这个时候，docker 的效率提升是很小的。</p><p>但是，你真的确信，你所做的工作只是一次性的吗？</p><p>2016.01 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;Docker-的学术化定义&quot;&gt;&lt;a href=&quot;#Docker-的</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 中的闭包和装饰器</title>
    <link href="http://starding.github.io/2016/01/06/closure-decorator-in-python/"/>
    <id>http://starding.github.io/2016/01/06/closure-decorator-in-python/</id>
    <published>2016-01-06T14:11:43.000Z</published>
    <updated>2024-02-20T01:20:16.325Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一版创建于：2016-01-06</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>首先看维基百科中的定义：</p><blockquote><p>In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope</p></blockquote><h2 id="然后考察定义："><a href="#然后考察定义：" class="headerlink" title="然后考察定义："></a>然后考察定义：</h2><p>上面这段话中有几个关键点：</p><ul><li>闭包是一项技术（technique）</li><li>一个闭包是一个函数和它所在的环境构成的记录</li><li>闭包，也就是上面说的记录，创建时，形成了函数中用到的自由变量（在封闭的词法作用域中定义，但在函数本地使用的变量）与其值的绑定关系。</li><li>闭包不同于普通的函数，它允许函数使用已经捕获（绑定）的变量，即使变量的定义在其作用域之外。<br>直接考察定义，再加上对「闭包」一词的直觉，只能产生一种模糊的概念：这货大致是一个封闭的结构，它包括一个函数以及在函数外定义的变量。但是更深入的理解就还得看实际中的代码了。</li></ul><p>一个 python 闭包的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建闭包的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>(<span class="params">start_at=<span class="number">0</span></span>):</span><br><span class="line">count = [start_at]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">incr</span>():</span><br><span class="line">count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> incr</span><br><span class="line"><span class="comment"># 将闭包赋值给另一个变量</span></span><br><span class="line">counter1 = counter()</span><br><span class="line"><span class="comment"># 再次赋值给一个变量</span></span><br><span class="line">counter2 = counter(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中，counter 是一个创建闭包的函数，然后下面两句分别赋值给了两个不同的变量。这实际上产生了两个闭包函数，counter1 和 counter2，他们都包括一个函数本身，以及在函数外关联的一个作用域。</p><p>上面的两个闭包非常像实例化的两个对象，它们附加的那个函数之外的作用域互相独立。彼此之间互不影响。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>首先解释字面意思<br>装饰器这个名词，字面意思就是「装饰其他特定东西用的工具」。这个词里暗含着一层意思，就是被装饰的东西才是核心，而装饰用的工具，只不过是起到点缀作用，增加点额外的东西罢了。</p><p>以一个隐喻来做比：在圣诞节的时候，我们会拿一些小挂件去装饰圣诞树，那么这个时候的小挂件就是一个一个的小装饰器，被装饰的核心是圣诞树。这也暗含着，核心是圣诞树，这些小挂件只不过是给圣诞树增加一些其他有趣的特性罢了。</p><p>回到 python 中也是类似的，在 python 中，并不是像存在函数，字典，列表这些 python 元素一样，真的有一种对象类型叫装饰器。而是说，python 中可以构造这样一种可调用对象（一般是函数或类来构造），它可以用于装饰别的对象，我们就把具有这样装饰功能的对象叫做装饰器。其实质不过是起到装饰作用的一些可调用对象。</p><p>那么这样就有两个问题：</p><p>装饰什么呢？<br>又是如何实现装饰功能的呢？<br>还是通过代码来看，一个 python 装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment"># 被装饰的主体函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="comment"># 做一些我们想要做的功能</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 最后打印一下</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;in foo()&#x27;</span></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeit</span>(<span class="params">func</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Decorator that reports the execution time.</span></span><br><span class="line"><span class="string">   &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">   @wraps(<span class="params">func</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">start  = time.clock()</span><br><span class="line">result = func(*args, **kwargs)</span><br><span class="line">end = time.clock()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;used: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(end-start)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>首先要明白我们的程序主体是什么，我们想要用 foo 函数来完成一些特定的功能，最终再打印一下，所以我们的主体函数是 foo。</p><p>同时，我们还想知道完成这件事所用的时间，那这正好可以通过装饰器来完成。于是我们构造了一个函数 timeit 作为装饰器，来装饰 foo 函数。</p><p>需要再次强调的一点是，装饰器 timeit 是用来装饰 foo 函数的，它只是给 foo 函数增加可以输出执行时间的特性，并不改变 foo 函数原来想要完成的功能。对 foo 函数原来所要做的事情，没有任何影响。</p><p>不过如果你留心一下，就会发现上面这个装饰器的实现中，用到了闭包这一技术（只是不那么明显，因为并没有带上一个额外的作用域，加上一个也是没问题的）。更准确的说，闭包和装饰器都是基于 python 中的可调用对象可以传递这一事实。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>那么装饰器是怎么来的呢？其实这一概念来源于设计模式中的装饰器模式：在不改变核心调用对象的情况下，给它添加一些有趣的也可能很有用的特性。这正是“装饰”的意义所在。</p><p>这不仅既不用改动原来的核心对象，又达到了我们想要的目的，实在是高明。</p><p>2016.01 于北京回龙观</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;第一版创建于：2016-01-06&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="作为工程师" scheme="http://starding.github.io/categories/%E4%BD%9C%E4%B8%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>缘起</title>
    <link href="http://starding.github.io/2016/01/05/hello-world/"/>
    <id>http://starding.github.io/2016/01/05/hello-world/</id>
    <published>2016-01-04T16:10:46.000Z</published>
    <updated>2024-02-19T12:39:30.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="仔细一想，我写博客也有一段时间了"><a href="#仔细一想，我写博客也有一段时间了" class="headerlink" title="仔细一想，我写博客也有一段时间了"></a>仔细一想，我写博客也有一段时间了</h2><p>回想这些年，我从大一的时候，就开始试着写博客了。当时涉及的技术比较少，大部分文章都是一些随笔，其内容也多是对一些社会事件的思考。</p><p>刚开始还不知道有独立博客这个概念，而且文章也都是发在 qq 空间的，原因是因为 qq 空间是我当时所知道的唯一能在网络上发表并保存日志的地方，也就将其档博客使用了。同时 qq 空间也有一些优点，因为它是基于 qq 这个社交平台的，自己所写的文章，总是可以被好友以及其他人看到，也会不时的得到一些反馈，这也是我当时的写作动力之一。</p><p>但是后来随着写的东西越来越偏向自己的专业，而且以前那些处处透露着中二思想的随笔类文章也很少写了，qq 空间的优点越来越不明显。而且因为其巨差的写作体验（不流畅，仅支持富文本），写点简单的纯文字文章还行，元素稍微多点的文章就不行了。</p><h2 id="我曾在很多地方写过博客"><a href="#我曾在很多地方写过博客" class="headerlink" title="我曾在很多地方写过博客"></a>我曾在很多地方写过博客</h2><p>于是我转向寻找其他可以写博客的地方。豆瓣，网易等等，但是都觉得不是写作体验太差，就是广告太多，严重影响心情，而且这个时候我正好了解了独立博客这样东西。于是开始申请域名，购买服务器，建立自己的 wordpress，寻找比较好的模板，一番折腾之后，终于搭起了自己的独立博客。</p><p>然而拥有了一年多独立博客之后，发现在写作本身上面甚至没有花在维护博客上面的时间长，各种费心巴力的问题不断，最终累觉不爱。</p><p>这个时候我意识到，写作才是本来的目的，也不想再费力气维护一个独立的博客。于是就开始了第二次寻找合适写作平台之旅。试了试网易的 lofter 等一波平台，发现只有简书还算差强人意，但是简书的可定制性又不太好。</p><p>这个时候我也突然发现，自己已经用过太多的平台，所写的内容也零零散散，非常不利于自己的积累和知识梳理。于是决定再寻找。</p><p>最终找到了 github 孪生兄弟：gitpages。</p><h2 id="最终还是聚合在一起了"><a href="#最终还是聚合在一起了" class="headerlink" title="最终还是聚合在一起了"></a>最终还是聚合在一起了</h2><p>github 本身就是程序员最常去的地方，gitpages 评价又高，仅用了半天就搭起了一个半独立博客，一看效果，这正是我想要的。</p><p>于是开始了聚合之路…</p><p>后来无意中看到网上有人总结的「写博客的三个阶段」，表示深有同感，摘抄如下：</p><p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。</p><p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p><p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p><p>.<br>.<br>.<br>.<br>.</p><h2 id="来自-2024-年-2-月的补充"><a href="#来自-2024-年-2-月的补充" class="headerlink" title="来自 2024 年 2 月的补充"></a>来自 2024 年 2 月的补充</h2><p>哈哈，可能正如传说中的那张愚昧之巅 - 绝望之谷的图一样，人生就是一个接一个的周期。</p><p>在写下上面的内容之后，我只在独立博客上写了一年的文字。在续费域名的时候觉得维护独立域名比较麻烦，于是我又放弃了独立博客，辗转使用了知乎、公众号、小报童这些平台作为自己公开输出文字的地方，本来以为把文字托管到这些地方可以更加专注在写作的本质上，但实际的效果可以说是正好相反。</p><p>想在这些平台上公开发布内容？需要先登录网站，加上一番导航操作找到文章发布中心，才能开始写下第一行文字（尤其是知乎和公众号的编辑器，简直是无力吐槽），还有一种客场作战的感受。综合体验下来其实远不如独立博客写文字方便，独立博客尽管有一些维护工作，但总体来说是比较低频的。</p><p>转眼已经 8 年。</p><p>正如三十岁之后定居在了杭州，结束了十多年的漂泊感一样。这两年也越来越希望有一个自己的独立主场，把自己的文字都汇总在同一个地方，于是开始重启独立博客。</p><p>在经历了第三方平台 -&gt; 独立博客 -&gt; 回到第三方平台 -&gt; 重新认识到独立博客的好，再回到独立博客。这样的反复循环之后，我想接下来会长周期的待在独立博客上了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;仔细一想，我写博客也有一段时间了&quot;&gt;&lt;a href=&quot;#仔细一想，</summary>
      
    
    
    
    <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
