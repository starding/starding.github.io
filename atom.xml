<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小狐濡尾]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://starding.github.io/"/>
  <updated>2016-01-06T15:58:47.000Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name><![CDATA[starding]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[python中的闭包和装饰器]]></title>
    <link href="http://starding.github.io/2016/01/06/python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://starding.github.io/2016/01/06/python中的闭包和装饰器/</id>
    <published>2016-01-06T13:51:03.000Z</published>
    <updated>2016-01-06T15:58:47.000Z</updated>
    <content type="html"><![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A"><a href="#u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A" class="headerlink" title="首先看维基百科中的定义："></a>首先看维基百科中的定义：</h3><blockquote>
<p>In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope</p>
</blockquote>
<h3 id="u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A"><a href="#u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A" class="headerlink" title="然后考察定义："></a>然后考察定义：</h3><p>上面这段话中有几个关键点：</p>
<ul>
<li>闭包是一项技术（technique）</li>
<li>一个闭包是一个函数和它所在的环境构成的记录</li>
<li>闭包，也就是上面说的记录，创建时，形成了函数中用到的自由变量（在封闭的词法作用域中定义，但在函数本地使用的变量）与其值的绑定关系。</li>
<li>闭包不同于普通的函数，它允许函数使用已经捕获（绑定）的变量，即使变量的定义在其作用域之外。</li>
</ul>
<p>直接考察定义，再加上对「闭包」一词的直觉，只能产生一种模糊的概念：这货大致是一个封闭的结构，它包括一个函数以及在函数外定义的变量。但是更深入的理解就还得看实际中的代码了。</p>
<p>一个python闭包的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建闭包的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at=<span class="number">0</span>)</span>:</span></span><br><span class="line">	count = [start_at]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">()</span>:</span></span><br><span class="line">		count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> incr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将闭包赋值给另一个变量</span></span><br><span class="line">counter1 = counter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次赋值给一个变量</span></span><br><span class="line">counter2 = counter(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，counter是一个创建闭包的函数，然后下面两句分别赋值给了两个不同的变量。这实际上产生了两个闭包函数，counter1和counter2，他们都包括一个函数本身，以及在函数外关联的一个作用域。</p>
<p>上面的两个闭包非常像实例化的两个对象，它们附加的那个函数之外的作用域互相独立。彼此之间互不影响。</p>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D"><a href="#u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D" class="headerlink" title="首先解释字面意思"></a>首先解释字面意思</h3><p>装饰器这个名词，字面意思就是「装饰其他特定东西用的工具」。这个词里暗含着一层意思，就是被装饰的东西才是核心，而装饰用的工具，只不过是起到点缀作用，增加点额外的东西罢了。</p>
<p>以一个隐喻来做比：在圣诞节的时候，我们会拿一些小挂件去装饰圣诞树，那么这个时候的小挂件就是一个一个的小装饰器，被装饰的核心是圣诞树。这也暗含着，核心是圣诞树，这些小挂件只不过是给圣诞树增加一些其他有趣的特性罢了。</p>
<p>回到python中也是类似的，在python中，并不是像存在函数，字典，列表这些python元素一样，真的有一种对象类型叫装饰器。而是说，python中可以构造这样一种可调用对象（一般是函数或类来构造），它可以用于装饰别的对象，我们就把具有这样装饰功能的对象叫做装饰器。其实质不过是起到装饰作用的一些可调用对象。</p>
<p>那么这样就有两个问题：</p>
<ul>
<li>装饰什么呢？</li>
<li>又是如何实现装饰功能的呢？</li>
</ul>
<p>还是通过代码来看，一个python装饰器的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 做一些我们想要做的功能</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># 最后打印一下</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'in foo()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="string">'''</span><br><span class="line">	Decorator that reports the execution time.</span><br><span class="line">   '''</span></span><br><span class="line"><span class="decorator">   @wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		start  = time.clock()</span><br><span class="line">		result = func(*args, **kwargs)</span><br><span class="line">		end = time.clock()</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'used: &#123;0&#125;'</span>.format(end-start)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>首先要明白我们的程序主体是什么，我们想要用foo函数来完成一些特定的功能，最终再打印一下，所以我们的主体函数是foo。</p>
<p>同时，我们还想知道完成这件事所用的时间，那这正好可以通过装饰器来完成。于是我们构造了一个函数timeit作为装饰器，来装饰foo函数。</p>
<p>需要再次强调的一点是，装饰器timeit是用来装饰foo函数的，它只是给foo函数增加可以输出执行时间的特性，并不改变foo函数原来想要完成的功能。对foo函数原来所要做的事情，没有任何影响。</p>
<p>不过如果你留心一下，就会发现上面这个装饰器的实现中，用到了闭包这一技术（只是不那么明显，因为并没有带上一个额外的作用域，加上一个也是没问题的）。更准确的说，闭包和装饰器都是基于python中的可调用对象可以传递这一事实。</p>
<h3 id="u88C5_u9970_u5668_u6A21_u5F0F"><a href="#u88C5_u9970_u5668_u6A21_u5F0F" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>那么装饰器是怎么来的呢？其实这一概念来源于设计模式中的装饰器模式：在不改变核心调用对象的情况下，给它添加一些有趣的也可能很有用的特性。这正是“装饰”的意义所在。</p>
<p>这不仅既不用改动原来的核心对象，又达到了我们想要的目的，实在是高明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[缘起]]></title>
    <link href="http://starding.github.io/2016/01/05/hello-world/"/>
    <id>http://starding.github.io/2016/01/05/hello-world/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-01-06T16:10:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u535A_u5BA2_u8FC1_u5230gitpages_u4E86"><a href="#u535A_u5BA2_u8FC1_u5230gitpages_u4E86" class="headerlink" title="博客迁到gitpages了"></a>博客迁到gitpages了</h3><h3 id="u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2"><a href="#u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2" class="headerlink" title="我曾在很多地方写过博客"></a>我曾在很多地方写过博客</h3><h3 id="u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86"><a href="#u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86" class="headerlink" title="最终还是聚合在一起了"></a>最终还是聚合在一起了</h3>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u535A_u5BA2_u8FC1_u5230gitpages_u4E86"><a href="#u535A_u5BA2_u8FC1_u5230gitpages_u4E86" class="headerlink" title="博客迁到gitpages了"></a]]>
    </summary>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
