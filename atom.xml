<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小狐濡尾]]></title>
  <subtitle><![CDATA[未济]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://starding.github.io/"/>
  <updated>2016-01-07T07:00:54.000Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name><![CDATA[starding]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[docker——从隐喻说起]]></title>
    <link href="http://starding.github.io/2016/01/07/docker%E2%80%94%E2%80%94%E4%BB%8E%E9%9A%90%E5%96%BB%E8%AF%B4%E8%B5%B7/"/>
    <id>http://starding.github.io/2016/01/07/docker——从隐喻说起/</id>
    <published>2016-01-07T05:44:42.000Z</published>
    <updated>2016-01-07T07:00:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</p>
<blockquote>
<p>Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.</p>
<p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。</p>
</blockquote>
<p>通过定义，可以模糊的知道docker是可以实现自动化部署之类功能的工具，但是并不能清楚的理解它到底牛逼在什么地方，又好在哪里。为了理解这一点，需要额外的工作要做，一种情况是你可以在长期使用docker的过程中，主键体会到docker的优势。但是对于一个从未接触过docker，甚至对部署都不是很了解的信任，应该怎么快速理解这一点呢？一个比较好的办法，就是借助于隐喻。</p>
<h2 id="u91CD_u8981_u7684_u9690_u55BB"><a href="#u91CD_u8981_u7684_u9690_u55BB" class="headerlink" title="重要的隐喻"></a>重要的隐喻</h2><p>在《代码大全》中，作者在欢迎章节之后，就开始介绍软件开发中的隐喻，并且强调了隐喻的重要性：</p>
<blockquote>
<p>计算机科学领域中有着搜友学科中最为丰富多彩的语言。你走进一间安全严密，温度精确控制在20℃的房间，并在里面发现了病毒（virus），特洛伊木马（Trojan horse），蠕虫（worm），臭虫（bug），逻辑炸弹（bomb），崩溃（crash），论坛口水战（flame），双绞线转换头（twisted sex changer），还有致命错误（fatal error）……在其他领域中，你能遇到这些吗？</p>
<p>这些形象的隐喻描述了软件领域总各种特定的现象和事物，像这样生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻，我们能更深刻的理解软件开发的过程。</p>
</blockquote>
<p>同样，要快速理解docker，抓出核心思想，隐喻是非常重要的</p>
<h3 id="u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002"><a href="#u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002" class="headerlink" title="字面意思：docker——码头工人。"></a>字面意思：docker——码头工人。</h3><p>docker的名称本身就带有隐喻的性质：在海洋物流中，一个非常重要的发明就是集装箱。</p>
<p>集装箱重要在哪里？为了理解这件事情，可以先考察一下集装箱出现之前的物流情况：货物生产出来之后，装箱，然后一箱一箱的搬到卡车上，然后再一箱一箱卸下来，送上火车，运送到码头附近的火车站，再一箱一箱卸下来，装上卡车，拉到货轮上，一箱一箱的装上去….</p>
<p>可以发现，大量的时间，人力 ，物力全部浪费在了中间的装卸上，在物流里面，货物真正在路上的时间是一定的，在交通技术得到改善之前，也很难去缩短。于是货物的装卸这部分时间，就成了物流中的瓶颈，而这个局面在集装箱出现之后，得到了很大的改善。</p>
<p>集装箱重要在它提供了一种通用的封装货物的标准规格（说白了指的就是它的尺寸，外形是符合一定标准的），这样就产生了一个优点，在物流运输中，只需要在运输前一次封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上，卸船之后直接再放上火车，卡车，运送到目的地。而且，集装箱本身的标准，使得它非常容易机械化操作，这样就节省了大量的人力物力。</p>
<h3 id="docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB"><a href="#docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB" class="headerlink" title="docker（码头工人）正是借用了集装箱的隐喻"></a>docker（码头工人）正是借用了集装箱的隐喻</h3><p>docker就像往集装箱里装货物的码头工人那样，它把应用打包成具有某种标准规格的集装箱，用计算机领域的语言来说，这种按照一定规格封装的集装箱叫「镜像」。其实就是将你原来的代码添加点内容，格式啥的，整出来的一个静态的应用。而且就像光盘镜像只能由特定的解析光盘镜像格式的软件来解析一样，这个镜像也只能由docker来解析。</p>
<p>集装箱减少了货物的运输工作量，那docker镜像又有什么相似的优势呢？首先可以看看docker出现之前的应用部署是啥样的。</p>
<h4 id="u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A"><a href="#u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A" class="headerlink" title="在docker出现之前，比如说我要部署一个django应用，要做哪些事情:"></a>在docker出现之前，比如说我要部署一个django应用，要做哪些事情:</h4><ul>
<li><p>首先我得有个python环境，比如我用的是python3，而你机器上是python2，那ok，先装个python3吧，一看装起来还挺麻烦，要先装各种依赖，还要解决一些可能的冲突，没办法硬着头皮上吧。</p>
</li>
<li><p>装完python之后，因为有pip这些神奇的工具，很快就装完django，需要的python库了。咦，发现还要装mysql，还用了redis。没办法，继续上吧，下载，安装，配置。费了九牛二虎之力终于搞完了。一天就这么过去了。</p>
</li>
<li><p>啥？你告诉我原来的服务器不用了，要换一台服务器？我靠，那重新来一遍吧，有了昨天的经验，只用了大半天就搞定了。</p>
</li>
<li><p>啥？你说咱们的应用做的太好，要进行推广，需要指导它们部署？我选择狗带，删代码走人。</p>
</li>
</ul>
<p>上面的描述可能有些夸张，但也绝不是罕有发生。在docker出现之前，这些正是运维人员很多时候都在做的事情，在不断的重复工作上，浪费了巨大的人力物力。</p>
<h4 id="docker_u51FA_u73B0_u4E4B_u540E"><a href="#docker_u51FA_u73B0_u4E4B_u540E" class="headerlink" title="docker出现之后"></a>docker出现之后</h4><p>docker正是在部署过程中，将上面那些重复的部分，封装在Docker镜像里，由docker自动化完成。只需要在第一次部署时，构建完毕一个可用的docker镜像。然后在以后使用的过程中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。</p>
<p>所需要的仅仅是安装了docker的服务器，一个Dockerfile文件，以及比较流畅的网络而已。</p>
<p>需要python3环境？直接 from python:3.x 搞定。</p>
<p>需要迁移服务器？ 直接把应用连带Dockerfile，volumes数据拷贝到新服务器上，几条命令又搞定</p>
<p>需要作为服务给别人使用？Dockerfile即是最清晰的部署文档，维护一个官方镜像即可。</p>
<p>到这个地方，你可能已经发现了，docker镜像成为了一种像集装箱那样的标准货件，谁想用我的服务，直接拉取镜像就完事了。容器跑起来之后，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p>
<h3 id="u4E00_u4E2A_u8BEF_u89E3"><a href="#u4E00_u4E2A_u8BEF_u89E3" class="headerlink" title="一个误解"></a>一个误解</h3><p>有人可能会问，我只有一台服务器，也不太可能会迁移。我的python服务，mysql服务，只需要部署一次，就可以在以后重复使用了。那这样docker对于我来说还有优势吗？毕竟docker也是有学习成本的。</p>
<p>如果你真的确信你的应用都是一次性的，而且只提供给自己使用，那么docker在这种场景下的优势不是特别明显：即便是docker，最初的构建也是需要有人做的，也是有工作量的。这和你一次性部署的工作量差不多。但是即便如此也是又有点的，它提供了一个干净，隔离的环境。</p>
<p>另外，很多人说docker改变了运维世界，这句话是从群体角度来说的，像mysql，python这样的使用群体众多的应用，以及会经常迁移，变动，重新部署的应用，docker化之后，整个群体所节省的时间，是非常巨大的。说是改变了运维的面貌毫不夸张。</p>
<p>但是对于纯粹的单次部署，具体到每一个人上面，其效率并非有质的提升，因为即使是集装箱，要往里面装东西，也是有不可避免的工作量的。而你第一次构建自己的镜像时，就像往集装箱里装东西是类似的，需要和直接在机器上部署差不多的工作量。这个时候，docker的效率提升是很小的。</p>
<p>但是，你真的确信，你所做的工作只是一次性的吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中的闭包和装饰器]]></title>
    <link href="http://starding.github.io/2016/01/06/python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://starding.github.io/2016/01/06/python中的闭包和装饰器/</id>
    <published>2016-01-06T13:51:03.000Z</published>
    <updated>2016-01-06T15:58:47.000Z</updated>
    <content type="html"><![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A"><a href="#u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A" class="headerlink" title="首先看维基百科中的定义："></a>首先看维基百科中的定义：</h3><blockquote>
<p>In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope</p>
</blockquote>
<h3 id="u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A"><a href="#u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A" class="headerlink" title="然后考察定义："></a>然后考察定义：</h3><p>上面这段话中有几个关键点：</p>
<ul>
<li>闭包是一项技术（technique）</li>
<li>一个闭包是一个函数和它所在的环境构成的记录</li>
<li>闭包，也就是上面说的记录，创建时，形成了函数中用到的自由变量（在封闭的词法作用域中定义，但在函数本地使用的变量）与其值的绑定关系。</li>
<li>闭包不同于普通的函数，它允许函数使用已经捕获（绑定）的变量，即使变量的定义在其作用域之外。</li>
</ul>
<p>直接考察定义，再加上对「闭包」一词的直觉，只能产生一种模糊的概念：这货大致是一个封闭的结构，它包括一个函数以及在函数外定义的变量。但是更深入的理解就还得看实际中的代码了。</p>
<p>一个python闭包的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建闭包的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at=<span class="number">0</span>)</span>:</span></span><br><span class="line">	count = [start_at]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">()</span>:</span></span><br><span class="line">		count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> incr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将闭包赋值给另一个变量</span></span><br><span class="line">counter1 = counter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次赋值给一个变量</span></span><br><span class="line">counter2 = counter(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，counter是一个创建闭包的函数，然后下面两句分别赋值给了两个不同的变量。这实际上产生了两个闭包函数，counter1和counter2，他们都包括一个函数本身，以及在函数外关联的一个作用域。</p>
<p>上面的两个闭包非常像实例化的两个对象，它们附加的那个函数之外的作用域互相独立。彼此之间互不影响。</p>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D"><a href="#u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D" class="headerlink" title="首先解释字面意思"></a>首先解释字面意思</h3><p>装饰器这个名词，字面意思就是「装饰其他特定东西用的工具」。这个词里暗含着一层意思，就是被装饰的东西才是核心，而装饰用的工具，只不过是起到点缀作用，增加点额外的东西罢了。</p>
<p>以一个隐喻来做比：在圣诞节的时候，我们会拿一些小挂件去装饰圣诞树，那么这个时候的小挂件就是一个一个的小装饰器，被装饰的核心是圣诞树。这也暗含着，核心是圣诞树，这些小挂件只不过是给圣诞树增加一些其他有趣的特性罢了。</p>
<p>回到python中也是类似的，在python中，并不是像存在函数，字典，列表这些python元素一样，真的有一种对象类型叫装饰器。而是说，python中可以构造这样一种可调用对象（一般是函数或类来构造），它可以用于装饰别的对象，我们就把具有这样装饰功能的对象叫做装饰器。其实质不过是起到装饰作用的一些可调用对象。</p>
<p>那么这样就有两个问题：</p>
<ul>
<li>装饰什么呢？</li>
<li>又是如何实现装饰功能的呢？</li>
</ul>
<p>还是通过代码来看，一个python装饰器的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 做一些我们想要做的功能</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># 最后打印一下</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'in foo()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="string">'''</span><br><span class="line">	Decorator that reports the execution time.</span><br><span class="line">   '''</span></span><br><span class="line"><span class="decorator">   @wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		start  = time.clock()</span><br><span class="line">		result = func(*args, **kwargs)</span><br><span class="line">		end = time.clock()</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'used: &#123;0&#125;'</span>.format(end-start)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>首先要明白我们的程序主体是什么，我们想要用foo函数来完成一些特定的功能，最终再打印一下，所以我们的主体函数是foo。</p>
<p>同时，我们还想知道完成这件事所用的时间，那这正好可以通过装饰器来完成。于是我们构造了一个函数timeit作为装饰器，来装饰foo函数。</p>
<p>需要再次强调的一点是，装饰器timeit是用来装饰foo函数的，它只是给foo函数增加可以输出执行时间的特性，并不改变foo函数原来想要完成的功能。对foo函数原来所要做的事情，没有任何影响。</p>
<p>不过如果你留心一下，就会发现上面这个装饰器的实现中，用到了闭包这一技术（只是不那么明显，因为并没有带上一个额外的作用域，加上一个也是没问题的）。更准确的说，闭包和装饰器都是基于python中的可调用对象可以传递这一事实。</p>
<h3 id="u88C5_u9970_u5668_u6A21_u5F0F"><a href="#u88C5_u9970_u5668_u6A21_u5F0F" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>那么装饰器是怎么来的呢？其实这一概念来源于设计模式中的装饰器模式：在不改变核心调用对象的情况下，给它添加一些有趣的也可能很有用的特性。这正是“装饰”的意义所在。</p>
<p>这不仅既不用改动原来的核心对象，又达到了我们想要的目的，实在是高明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[缘起]]></title>
    <link href="http://starding.github.io/2016/01/05/hello-world/"/>
    <id>http://starding.github.io/2016/01/05/hello-world/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-01-07T07:21:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86" class="headerlink" title="仔细一想，我写博客也有一段时间了"></a>仔细一想，我写博客也有一段时间了</h3><p>回想这些年，我从大一的时候，就开始试着写博客了。当时涉及的技术比较少，大部分文章都是一些随笔，其内容也多是对一些社会事件的思考。</p>
<p>刚开始还不知道有独立博客这个概念，而且文章也都是发在qq空间的，原因是因为qq空间是我当时所知道的唯一能在网络上发表并保存日志的地方，也就将其档博客使用了。同时qq空间也有一些优点，因为它是基于qq这个社交平台的，自己所写的文章，总是可以被好友以及其他人看到，也会不时的得到一些反馈，这也是我当时的写作动力之一。</p>
<p>但是后来随着写的东西越来越偏向自己的专业，而且以前那些处处透露着中二思想的随笔类文章也很少写了，qq空间的优点越来越不明显。而且因为其巨差的写作体验（不流畅，仅支持富文本），写点简单的纯文字文章还行，元素稍微多点的文章就不行了。</p>
<h3 id="u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2"><a href="#u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2" class="headerlink" title="我曾在很多地方写过博客"></a>我曾在很多地方写过博客</h3><p>于是我转向寻找其他可以写博客的地方。豆瓣，网易等等，但是都觉得不是写作体验太差，就是<br>广告太多，严重影响心情，而且这个时候我正好了解了独立博客这样东西。于是开始申请域名，购买服务器，建立自己的wordpress，寻找比较好的模板，一番折腾之后，终于搭起了自己的独立博客。</p>
<p>然而拥有了一年多独立博客之后，发现在写作本身上面甚至没有花在维护博客上面的时间长，各种费心巴力的问题不断，最终累觉不爱。</p>
<p>这个时候我意识到，写作才是本来的目的，也不想再费力气维护一个独立的博客。于是就开始了第二次寻找合适写作平台之旅。试了试网易的lofter等一波平台，发现只有简书还算差强人意，但是简书的可定制性又不太好。</p>
<p>这个时候我也突然发现，自己已经用过太多的平台，所写的内容也零零散散，非常不利于自己的积累和知识梳理。于是决定再寻找。</p>
<p>最终找到了github孪生兄弟：gitpages。</p>
<h3 id="u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86"><a href="#u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86" class="headerlink" title="最终还是聚合在一起了"></a>最终还是聚合在一起了</h3><p>github本身就是程序员最常去的地方，gitpages评价又高，仅用了半天就搭起了一个半独立博客，一看效果，这正是我想要的。</p>
<p>于是开始了聚合之路…</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_u]]>
    </summary>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
