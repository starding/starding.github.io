<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小狐濡尾]]></title>
  <subtitle><![CDATA[未济]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://starding.github.io/"/>
  <updated>2016-01-07T07:31:01.000Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name><![CDATA[starding]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[django中使用原生sql]]></title>
    <link href="http://starding.github.io/2016/01/07/django%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql/"/>
    <id>http://starding.github.io/2016/01/07/django中使用原生sql/</id>
    <published>2016-01-07T07:29:46.000Z</published>
    <updated>2016-01-07T07:31:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，django的orm只是sql的一个子集。也就是说很多使用sql能实现的功能，django orm是无法完成的，更不用说sql甚至是图灵完备的了。比如，直到1.8中，django才逐渐实现了case，when，if这些控制流。而这些内容在一些特殊类型的表操作中非常常见，比如说报表管理。</p>
<p>好在django提供了使用原生sql的接口，这样就能通过原生sql来实现一些复杂的功能。</p>
<h2 id="sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50"><a href="#sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="sql控制流之CASE WHEN一个例子"></a>sql控制流之CASE WHEN一个例子</h2><p>现有一张档案信息表archives：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/48482-ddc55e26121f44aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2015-11-05 下午4.41.32.png"></p>
<p>字段说明：</p>
<ul>
<li>number 档案号</li>
<li>type 档案类型</li>
<li>status 档案状态</li>
<li>company 公司</li>
<li>branch_company 分公司</li>
</ul>
<p><strong>需求是计算出表中同一type，同一分公司下的档案总数，和status=01的档案数，以及它占档案总数的比值。</strong></p>
<p>当然，使用编程语言也可以实现这个功能，但是会比较复杂。这个时候可以使用case when语句来精确控制表中同一字段下，不同内容的选择。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> </span><br><span class="line">      <span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>) status_01,</span><br><span class="line">      <span class="keyword">COUNT</span>(*) total,</span><br><span class="line">      <span class="keyword">CONCAT</span>(<span class="keyword">FORMAT</span>(<span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>)/</span><br><span class="line">      <span class="keyword">COUNT</span>(*)*<span class="number">100</span>, <span class="number">2</span>), <span class="string">'%'</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      archives</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      <span class="keyword">status</span>, subbranch_company</span></span><br></pre></td></tr></table></figure>
<p>这样就可以解决上面提出的问题，因为这个表是临时杜撰的，结果这里就不贴了。</p>
<h2 id="u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2"><a href="#u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2" class="headerlink" title="在上述基础上实现链式查询"></a>在上述基础上实现链式查询</h2><p>在django的orm中，一个非常好用的功能就是使用链式查询，你可以不断连接filter等方法来过滤出想要的内容。</p>
<p>这在一些特定的场景中特别有用。比如在上面的表中，我有时候想要某个分公司或中支公司下的数据，有时候又想要单一类型下的数据。如果针对每一种条件组合分别写相应地sql查询的话，会非常复杂，而且有时候组合会特别多。而链式查询比较完美的解决了这个问题。<br>而为了让原生sql也能有个简单的链式查询，我们需要不断连接where中的条件子句。为此可以写一个简单的类来实现它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenQuerySQL</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, table)</span>:</span></span><br><span class="line">        self.table = table</span><br><span class="line">        self.group_by_fields = <span class="string">" "</span></span><br><span class="line">        self.where_conditions = <span class="string">" 1=1 "</span></span><br><span class="line">        self.fields = <span class="string">" "</span></span><br><span class="line">        self.order_by_fields = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">where</span><span class="params">(self, where_condition)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> where_condition:</span><br><span class="line">            self.where_conditions += <span class="string">" and "</span> + where_condition</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_field</span><span class="params">(self, fields)</span>:</span></span><br><span class="line">        self.fields += <span class="string">" "</span> + fields</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_by</span><span class="params">(self, group_by_field)</span>:</span></span><br><span class="line">        self.group_by_fields = group_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order_by</span><span class="params">(self, order_by_field)</span>:</span></span><br><span class="line">        self.order_by_fields = order_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sql</span><span class="params">(self)</span>:</span></span><br><span class="line">       SQL = <span class="string">'SELECT '</span> + self.fields + <span class="string">' FROM '</span> + self.table + <span class="string">' WHERE '</span> + self.where_conditions + <span class="string">' GROUP BY '</span> + self.group_by_fields + <span class="string">' ORDER BY '</span> + self.order_by_fields +  <span class="string">";"</span></span><br><span class="line">       <span class="keyword">return</span> SQL</span><br></pre></td></tr></table></figure>
<p>这个类可以简单的模拟链式查询的功能，可以这样使用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archive_statistics = GenQuerySQL(SOME_TABLE)</span><br><span class="line">raw_sql = archive_statistics.add_field(fields).where(where_condition).group_by(group_by_fields).order_by(order_by_fields).sql()</span><br></pre></td></tr></table></figure>
<p>其中.where可以多次连接。当然也可以使用另一种方式：先把where语句根据条件构造完毕，最终再拼接成sql语句。其思想是一样的：先过滤条件，最终再查询数据库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，dja]]>
    </summary>
    
      <category term="django" scheme="http://starding.github.io/tags/django/"/>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 部署gitlab]]></title>
    <link href="http://starding.github.io/2016/01/07/docker-%E9%83%A8%E7%BD%B2gitlab/"/>
    <id>http://starding.github.io/2016/01/07/docker-部署gitlab/</id>
    <published>2016-01-07T07:27:22.000Z</published>
    <updated>2016-01-07T07:28:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="headerlink" title="拉取镜像及启动容器"></a>拉取镜像及启动容器</h1><p>参考：<a href="http://doc.gitlab.com/omnibus/docker/" target="_blank" rel="external">gitlab documentation</a></p>
<h2 id="u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A"><a href="#u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A" class="headerlink" title="首先使用dao加速器拉取daocker镜像："></a>首先使用dao加速器拉取daocker镜像：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<h1 id="u521B_u5EFAvolumes"><a href="#u521B_u5EFAvolumes" class="headerlink" title="创建volumes"></a>创建volumes</h1><p>简单来说volumes，就是可以映射到容器中去的容器外部存储空间。你可以将一些比价通用的配置文件，数据，或者是代码等都使用volumes的形式存储在容器所在的宿主机器上。这样不仅可以永久保留数据，保证数据的安全性。同时还可以方便的修改volumes中的内容，然后重新映射到容器中，这对于需要经常动态修改文件的容器非常有用。<br>在本次部署gitlab的时候，创建三个volumes，分别是/mnt/volumes/gitlab下的 config，logs，data目录。<br>启动一个gitlab容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \&#10;    --hostname git.xiaohuruwei.com \&#10;    --publish 8443:443 --publish 8080:80 --publish 2222:22 \&#10;    --name gitlab \&#10;    --restart always \&#10;    --volume /mnt/volumes/gitlab/config:/etc/gitlab \&#10;    --volume /mnt/volumes/gitlab/logs:/var/log/gitlab \&#10;    --volume /mnt/volumes/gitlab/data:/var/opt/gitlab \&#10;    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<p>命令参数解释：</p>
<p>–hostname<br>指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定git.xiaohuruwei.com</p>
<p>–publish<br>端口映射，冒号前面是宿主机端口，后面是容器expose出的端口</p>
<p>–volume<br>volume 映射，冒号前面是宿主机的一个文件路径，后面是容器中的文件路径</p>
<h1 id="u914D_u7F6Enginx_uFF0C_u652F_u6301https"><a href="#u914D_u7F6Enginx_uFF0C_u652F_u6301https" class="headerlink" title="配置nginx，支持https"></a>配置nginx，支持https</h1><p>参考：<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https" target="_blank" rel="external">gitlab set nginx</a><br>nginx 配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">rewrite</span><span class="regexp"> ^</span> <span class="url">https://git.xiaohuruwei.com</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="https_proxy"><a href="#https_proxy" class="headerlink" title="https proxy"></a>https proxy</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="title">server_name</span>  git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="comment"># ssl 证书配置，这里使用的是自己生成的证书，在访问时会提示证书问题，选择相信即可。</span></span><br><span class="line">    <span class="comment"># 如果想要公认的证书，需要在网络上的一些授权中心生成</span></span><br><span class="line">    <span class="title">ssl</span> <span class="built_in">on</span>;</span><br><span class="line">    <span class="title">ssl_certificate</span> /etc/nginx/ssl/getbase.crt;</span><br><span class="line">    <span class="title">ssl_certificate_key</span> /etc/nginx/ssl/getbase_nopass.key;</span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">https://localhost:8443</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u5F00_u653Egitlab_u7684https_u652F_u6301"><a href="#u5F00_u653Egitlab_u7684https_u652F_u6301" class="headerlink" title="开放gitlab的https支持"></a>开放gitlab的https支持</h1><p>仅仅由nginx反向代理https是不行的，因为还需要打开gitlab的https支持。</p>
<ul>
<li>修改配置文件，在/mnt/volumes/gitlab/config/ 目录下的gitlab.rb中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># note the &#39;https&#39; below&#10;external_url &#34;https://gitlab.example.com&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新建ssl目录，同时在该目录下添加ssl证书文件，命名要与上述域名中保持一致</p>
<p>git.xiaohuruwei.com.crt<br>git.xiaohuruwei.com.key</p>
</li>
<li><p>重新启动容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="u8BBF_u95EEgitlab_u6D4B_u8BD5"><a href="#u8BBF_u95EEgitlab_u6D4B_u8BD5" class="headerlink" title="访问gitlab测试"></a>访问gitlab测试</h1><ul>
<li>打开web界面，默认登录名为root，密码为5iveL!fe（已经改为厘米脚印的默认密码），新建一个project仓库:test</li>
<li><p>因为ssl证书是自己生成的，并不具有全网通用性，因此只能先选择相信证书。在本地设置环境变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GIT_SSL_NO_VERIFY=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后克隆仓库： git clone <a href="https://git.xiaohuruwei.com/root/test.git" target="_blank" rel="external">https://git.xiaohuruwei.com/root/test.git</a></p>
</li>
</ul>
<h1 id="u5F00_u542F_u90AE_u4EF6_u670D_u52A1"><a href="#u5F00_u542F_u90AE_u4EF6_u670D_u52A1" class="headerlink" title="开启邮件服务"></a>开启邮件服务</h1><p>默认的邮件服务不太好使，所以这里配置自己的邮件服务。参考官方<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md#examples" target="_blank" rel="external">gitlab stmp文档</a>。</p>
<p>使用163邮箱, 按照官方文档配置后，会发现发送邮件没有起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;smtp_enable&#39;] = true&#10;gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.163.com&#34;&#10;gitlab_rails[&#39;smtp_port&#39;] = 25&#10;gitlab_rails[&#39;smtp_user_name&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;gitlab_rails[&#39;smtp_password&#39;] = &#34;xxxx&#34;&#10;gitlab_rails[&#39;smtp_domain&#39;] = &#34;163.com&#34;&#10;gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;&#10;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true&#10;gitlab_rails[&#39;smtp_tls&#39;] = false&#10;gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;none&#39;</span><br></pre></td></tr></table></figure></p>
<p>查看log时，由于log比较杂乱，没有发现问题，后来在ruby社区发现有人解决过同样的问题：<br><a href="https://ruby-china.org/topics/20450" target="_blank" rel="external">GitLab 配置通过 smtp.163.com 发送邮件</a><br>以及网易的官方解释：<br><a href="http://www.mail163.cn/fault/analysis/1109.html" target="_blank" rel="external">网易服务器smtp机器要求身份验证帐号和发信帐号必须一致，如果用户在发送邮件时，身份验证帐号和发件人帐号是不同的，因此拒绝发送。</a><br>所以又添加了两行配置后测试可以正常使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;user[&#39;git_user_email&#39;] = &#34;xiaohuruwei@163.com&#34;</span><br></pre></td></tr></table></figure></p>
<h1 id="ssh_u65B9_u5F0F_u8BBF_u95EE"><a href="#ssh_u65B9_u5F0F_u8BBF_u95EE" class="headerlink" title="ssh方式访问"></a>ssh方式访问</h1><p>因为是使用docker部署的，通过ssh方式(比如git clone <a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>)访问会有两层认证:</p>
<ul>
<li>一层是freelancer服务器的认证</li>
<li>另一层是gitlab的认证。</li>
</ul>
<p>后者需要使用ssh-key<br>前者可能需要ssh本身的反向代理(现在使用的nginx不支持除http，https以外的反向代理)，</p>
<p>现在发现使用端口转发的形式比较困难，但是可以改变默认的gitlab的ssh端口为非标准端口：<br>直接修改gitlab配置文件中的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_shell_ssh_port = 2222</span><br></pre></td></tr></table></figure></p>
<p> 然后重新启动docker容器，就可以在web界面中看到相应的ssh地址发生了改变:<br>ssh://<a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>:2222/root/test.git  然后就直接可以继续使用git clone来继续操作了</p>
<h1 id="u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A"><a href="#u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A" class="headerlink" title="关于ssl证书参考："></a>关于ssl证书参考：</h1><p><a href="http://www.guokr.com/post/116169/" target="_blank" rel="external">https那些事，ssl证书</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="heade]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[daoloud 持续集成html5应用]]></title>
    <link href="http://starding.github.io/2016/01/07/daoloud-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90html5%E5%BA%94%E7%94%A8/"/>
    <id>http://starding.github.io/2016/01/07/daoloud-持续集成html5应用/</id>
    <published>2016-01-07T07:24:25.000Z</published>
    <updated>2016-01-07T07:25:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="daocloud_u4ECB_u7ECD"><a href="#daocloud_u4ECB_u7ECD" class="headerlink" title="daocloud介绍"></a>daocloud介绍</h1><p>  <a href="https://daocloud.io" target="_blank" rel="external">daocloud</a>提供基于docker进行持续集成的服务，使用它可以很方便的完成项目的自动化构建以及持续发布等功能。</p>
<h1 id="u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D"><a href="#u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D" class="headerlink" title="什么是「简单的html5应用」"></a>什么是「简单的html5应用」</h1><p>只有前端页面，并且使用nginx提供服务。</p>
<h1 id="u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848"><a href="#u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848" class="headerlink" title="部署大致解决方案"></a>部署大致解决方案</h1><p>本文假设一个使用场景：拥有自己的主机，并且绑定到了daocloud上，然后想通过daocloud进行持续化地部署到自己的主机上。如果想要部署一个纯前端项目，需要把nginx集成进去，然后使用nginx来提供服务。</p>
<h1 id="u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907"><a href="#u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907" class="headerlink" title="构建应用前的准备"></a>构建应用前的准备</h1><p>在构建应用之前，你需要改装自己的程序，添加Dockerfile文件，配置好所需要的nginx配置文件。比如我有一个应用叫myapp，其目录结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myapp/  #&#24212;&#29992;&#26681;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; myapp/  # &#20855;&#20307;&#30340;&#24212;&#29992;&#30446;&#24405;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; images/ # &#22270;&#29255;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.html  # &#40664;&#35748;&#30340;&#26816;&#32034;html&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; scripts/  #  js&#25991;&#20214;&#22841;&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; styles/    # &#23384;&#25918;css&#30340;&#25991;&#20214;&#22841;&#10;&#9500;&#9472;&#9472; Dockerfile   # Dockerfile&#10;&#9500;&#9472;&#9472; myapp.conf   # &#26412;&#24212;&#29992;&#30340;nginx&#37197;&#32622;&#25991;&#20214;&#10;&#9492;&#9472;&#9472; log/  # log&#25991;&#20214;</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile的内容：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择nginx服务</span></span><br><span class="line"><span class="built_in">FROM</span> nginx:<span class="number">1.9</span>.<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy代码</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">. /src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 添加nginx配置文件</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">myapp.conf /etc/nginx/conf.d/</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 去掉默认的nginx配置文件</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">rm /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure>
<p>myapp.conf 内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> localhost;</span><br><span class="line">    <span class="title">access_log</span> /src/log/myapp.access.log;</span><br><span class="line">    <span class="title">error_log</span> /src/log/myapp.<span class="built_in">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里你还可以选择根据需要配一些gzip等选项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">    <span class="title">root</span> /src/myapp/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将应用提交到github上，比如具体为：xiaohuruwei/myapp.git</p>
<p>以上已经包含全部必须的材料了，下面进入daocloud环节。</p>
<h1 id="u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03"><a href="#u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03" class="headerlink" title="使用daocloud进行持续构建镜像以及发布"></a>使用daocloud进行持续构建镜像以及发布</h1><p>因为前面的步骤已经构建好了一个支持docker的代码版本，而且不需要外联像mysql这样的外部服务，因此可以直接将其当做一个但应用的镜像来构建。</p>
<p>在这方面，daocloud已经有了完善的<a href="http://docs.daocloud.io/" target="_blank" rel="external">文档</a>，可以直接参考其中的创建新项目章节，以及持续集成章节。</p>
<h1 id="u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C"><a href="#u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C" class="headerlink" title="发布完成之后需要做的工作"></a>发布完成之后需要做的工作</h1><p>发布完成之后，可以在daocloud上看到所创建的容器的具体信息。包括映射到宿主机上的端口号等等，为方便后面的叙述，这里假设映射出的端口号为8888。因为是发布到自己的主机上，所以还需要自己配置域名以及nginx反向代理来对外提供访问服务。假设有一个域名已经绑定在了自己的主机上，这里假设为xiaohuruwei.com.</p>
<p>登陆自己的主机，并配置nginx文件，如果是使用apt-get一类的包管理工具安装的，那么应该是在/etc/nginx/conf.d/目录下添加 myapp.conf:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/myapp.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/myapp.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以根据需要设置其他配置项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">http://127.0.0.1:8888</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问xiaohuruwei.com就可以看到内容了</p>
<p>另外，需要在使用daocloud的时候，将自动构建和持续发布都打开，这样下次使用时，只需要往github推代码时，触发了你设定的更新规则，就会持续构建镜像并发布了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="daocloud_u4ECB_u7ECD"><a href="#daocloud_u4ECB_u7ECD" class="headerlink" title="daocloud介绍"></a>daocloud介绍</h1><p>  <a href="https:/]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker——从隐喻说起]]></title>
    <link href="http://starding.github.io/2016/01/07/docker%E2%80%94%E2%80%94%E4%BB%8E%E9%9A%90%E5%96%BB%E8%AF%B4%E8%B5%B7/"/>
    <id>http://starding.github.io/2016/01/07/docker——从隐喻说起/</id>
    <published>2016-01-07T05:44:42.000Z</published>
    <updated>2016-01-07T07:00:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</p>
<blockquote>
<p>Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.</p>
<p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。</p>
</blockquote>
<p>通过定义，可以模糊的知道docker是可以实现自动化部署之类功能的工具，但是并不能清楚的理解它到底牛逼在什么地方，又好在哪里。为了理解这一点，需要额外的工作要做，一种情况是你可以在长期使用docker的过程中，主键体会到docker的优势。但是对于一个从未接触过docker，甚至对部署都不是很了解的信任，应该怎么快速理解这一点呢？一个比较好的办法，就是借助于隐喻。</p>
<h2 id="u91CD_u8981_u7684_u9690_u55BB"><a href="#u91CD_u8981_u7684_u9690_u55BB" class="headerlink" title="重要的隐喻"></a>重要的隐喻</h2><p>在《代码大全》中，作者在欢迎章节之后，就开始介绍软件开发中的隐喻，并且强调了隐喻的重要性：</p>
<blockquote>
<p>计算机科学领域中有着搜友学科中最为丰富多彩的语言。你走进一间安全严密，温度精确控制在20℃的房间，并在里面发现了病毒（virus），特洛伊木马（Trojan horse），蠕虫（worm），臭虫（bug），逻辑炸弹（bomb），崩溃（crash），论坛口水战（flame），双绞线转换头（twisted sex changer），还有致命错误（fatal error）……在其他领域中，你能遇到这些吗？</p>
<p>这些形象的隐喻描述了软件领域总各种特定的现象和事物，像这样生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻，我们能更深刻的理解软件开发的过程。</p>
</blockquote>
<p>同样，要快速理解docker，抓出核心思想，隐喻是非常重要的</p>
<h3 id="u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002"><a href="#u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002" class="headerlink" title="字面意思：docker——码头工人。"></a>字面意思：docker——码头工人。</h3><p>docker的名称本身就带有隐喻的性质：在海洋物流中，一个非常重要的发明就是集装箱。</p>
<p>集装箱重要在哪里？为了理解这件事情，可以先考察一下集装箱出现之前的物流情况：货物生产出来之后，装箱，然后一箱一箱的搬到卡车上，然后再一箱一箱卸下来，送上火车，运送到码头附近的火车站，再一箱一箱卸下来，装上卡车，拉到货轮上，一箱一箱的装上去….</p>
<p>可以发现，大量的时间，人力 ，物力全部浪费在了中间的装卸上，在物流里面，货物真正在路上的时间是一定的，在交通技术得到改善之前，也很难去缩短。于是货物的装卸这部分时间，就成了物流中的瓶颈，而这个局面在集装箱出现之后，得到了很大的改善。</p>
<p>集装箱重要在它提供了一种通用的封装货物的标准规格（说白了指的就是它的尺寸，外形是符合一定标准的），这样就产生了一个优点，在物流运输中，只需要在运输前一次封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上，卸船之后直接再放上火车，卡车，运送到目的地。而且，集装箱本身的标准，使得它非常容易机械化操作，这样就节省了大量的人力物力。</p>
<h3 id="docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB"><a href="#docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB" class="headerlink" title="docker（码头工人）正是借用了集装箱的隐喻"></a>docker（码头工人）正是借用了集装箱的隐喻</h3><p>docker就像往集装箱里装货物的码头工人那样，它把应用打包成具有某种标准规格的集装箱，用计算机领域的语言来说，这种按照一定规格封装的集装箱叫「镜像」。其实就是将你原来的代码添加点内容，格式啥的，整出来的一个静态的应用。而且就像光盘镜像只能由特定的解析光盘镜像格式的软件来解析一样，这个镜像也只能由docker来解析。</p>
<p>集装箱减少了货物的运输工作量，那docker镜像又有什么相似的优势呢？首先可以看看docker出现之前的应用部署是啥样的。</p>
<h4 id="u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A"><a href="#u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A" class="headerlink" title="在docker出现之前，比如说我要部署一个django应用，要做哪些事情:"></a>在docker出现之前，比如说我要部署一个django应用，要做哪些事情:</h4><ul>
<li><p>首先我得有个python环境，比如我用的是python3，而你机器上是python2，那ok，先装个python3吧，一看装起来还挺麻烦，要先装各种依赖，还要解决一些可能的冲突，没办法硬着头皮上吧。</p>
</li>
<li><p>装完python之后，因为有pip这些神奇的工具，很快就装完django，需要的python库了。咦，发现还要装mysql，还用了redis。没办法，继续上吧，下载，安装，配置。费了九牛二虎之力终于搞完了。一天就这么过去了。</p>
</li>
<li><p>啥？你告诉我原来的服务器不用了，要换一台服务器？我靠，那重新来一遍吧，有了昨天的经验，只用了大半天就搞定了。</p>
</li>
<li><p>啥？你说咱们的应用做的太好，要进行推广，需要指导它们部署？我选择狗带，删代码走人。</p>
</li>
</ul>
<p>上面的描述可能有些夸张，但也绝不是罕有发生。在docker出现之前，这些正是运维人员很多时候都在做的事情，在不断的重复工作上，浪费了巨大的人力物力。</p>
<h4 id="docker_u51FA_u73B0_u4E4B_u540E"><a href="#docker_u51FA_u73B0_u4E4B_u540E" class="headerlink" title="docker出现之后"></a>docker出现之后</h4><p>docker正是在部署过程中，将上面那些重复的部分，封装在Docker镜像里，由docker自动化完成。只需要在第一次部署时，构建完毕一个可用的docker镜像。然后在以后使用的过程中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。</p>
<p>所需要的仅仅是安装了docker的服务器，一个Dockerfile文件，以及比较流畅的网络而已。</p>
<p>需要python3环境？直接 from python:3.x 搞定。</p>
<p>需要迁移服务器？ 直接把应用连带Dockerfile，volumes数据拷贝到新服务器上，几条命令又搞定</p>
<p>需要作为服务给别人使用？Dockerfile即是最清晰的部署文档，维护一个官方镜像即可。</p>
<p>到这个地方，你可能已经发现了，docker镜像成为了一种像集装箱那样的标准货件，谁想用我的服务，直接拉取镜像就完事了。容器跑起来之后，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p>
<h3 id="u4E00_u4E2A_u8BEF_u89E3"><a href="#u4E00_u4E2A_u8BEF_u89E3" class="headerlink" title="一个误解"></a>一个误解</h3><p>有人可能会问，我只有一台服务器，也不太可能会迁移。我的python服务，mysql服务，只需要部署一次，就可以在以后重复使用了。那这样docker对于我来说还有优势吗？毕竟docker也是有学习成本的。</p>
<p>如果你真的确信你的应用都是一次性的，而且只提供给自己使用，那么docker在这种场景下的优势不是特别明显：即便是docker，最初的构建也是需要有人做的，也是有工作量的。这和你一次性部署的工作量差不多。但是即便如此也是又有点的，它提供了一个干净，隔离的环境。</p>
<p>另外，很多人说docker改变了运维世界，这句话是从群体角度来说的，像mysql，python这样的使用群体众多的应用，以及会经常迁移，变动，重新部署的应用，docker化之后，整个群体所节省的时间，是非常巨大的。说是改变了运维的面貌毫不夸张。</p>
<p>但是对于纯粹的单次部署，具体到每一个人上面，其效率并非有质的提升，因为即使是集装箱，要往里面装东西，也是有不可避免的工作量的。而你第一次构建自己的镜像时，就像往集装箱里装东西是类似的，需要和直接在机器上部署差不多的工作量。这个时候，docker的效率提升是很小的。</p>
<p>但是，你真的确信，你所做的工作只是一次性的吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中的闭包和装饰器]]></title>
    <link href="http://starding.github.io/2016/01/06/python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://starding.github.io/2016/01/06/python中的闭包和装饰器/</id>
    <published>2016-01-06T13:51:03.000Z</published>
    <updated>2016-01-06T15:58:47.000Z</updated>
    <content type="html"><![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A"><a href="#u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A" class="headerlink" title="首先看维基百科中的定义："></a>首先看维基百科中的定义：</h3><blockquote>
<p>In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope</p>
</blockquote>
<h3 id="u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A"><a href="#u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A" class="headerlink" title="然后考察定义："></a>然后考察定义：</h3><p>上面这段话中有几个关键点：</p>
<ul>
<li>闭包是一项技术（technique）</li>
<li>一个闭包是一个函数和它所在的环境构成的记录</li>
<li>闭包，也就是上面说的记录，创建时，形成了函数中用到的自由变量（在封闭的词法作用域中定义，但在函数本地使用的变量）与其值的绑定关系。</li>
<li>闭包不同于普通的函数，它允许函数使用已经捕获（绑定）的变量，即使变量的定义在其作用域之外。</li>
</ul>
<p>直接考察定义，再加上对「闭包」一词的直觉，只能产生一种模糊的概念：这货大致是一个封闭的结构，它包括一个函数以及在函数外定义的变量。但是更深入的理解就还得看实际中的代码了。</p>
<p>一个python闭包的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建闭包的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at=<span class="number">0</span>)</span>:</span></span><br><span class="line">	count = [start_at]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">()</span>:</span></span><br><span class="line">		count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> incr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将闭包赋值给另一个变量</span></span><br><span class="line">counter1 = counter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次赋值给一个变量</span></span><br><span class="line">counter2 = counter(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，counter是一个创建闭包的函数，然后下面两句分别赋值给了两个不同的变量。这实际上产生了两个闭包函数，counter1和counter2，他们都包括一个函数本身，以及在函数外关联的一个作用域。</p>
<p>上面的两个闭包非常像实例化的两个对象，它们附加的那个函数之外的作用域互相独立。彼此之间互不影响。</p>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D"><a href="#u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D" class="headerlink" title="首先解释字面意思"></a>首先解释字面意思</h3><p>装饰器这个名词，字面意思就是「装饰其他特定东西用的工具」。这个词里暗含着一层意思，就是被装饰的东西才是核心，而装饰用的工具，只不过是起到点缀作用，增加点额外的东西罢了。</p>
<p>以一个隐喻来做比：在圣诞节的时候，我们会拿一些小挂件去装饰圣诞树，那么这个时候的小挂件就是一个一个的小装饰器，被装饰的核心是圣诞树。这也暗含着，核心是圣诞树，这些小挂件只不过是给圣诞树增加一些其他有趣的特性罢了。</p>
<p>回到python中也是类似的，在python中，并不是像存在函数，字典，列表这些python元素一样，真的有一种对象类型叫装饰器。而是说，python中可以构造这样一种可调用对象（一般是函数或类来构造），它可以用于装饰别的对象，我们就把具有这样装饰功能的对象叫做装饰器。其实质不过是起到装饰作用的一些可调用对象。</p>
<p>那么这样就有两个问题：</p>
<ul>
<li>装饰什么呢？</li>
<li>又是如何实现装饰功能的呢？</li>
</ul>
<p>还是通过代码来看，一个python装饰器的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 做一些我们想要做的功能</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># 最后打印一下</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'in foo()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="string">'''</span><br><span class="line">	Decorator that reports the execution time.</span><br><span class="line">   '''</span></span><br><span class="line"><span class="decorator">   @wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		start  = time.clock()</span><br><span class="line">		result = func(*args, **kwargs)</span><br><span class="line">		end = time.clock()</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'used: &#123;0&#125;'</span>.format(end-start)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>首先要明白我们的程序主体是什么，我们想要用foo函数来完成一些特定的功能，最终再打印一下，所以我们的主体函数是foo。</p>
<p>同时，我们还想知道完成这件事所用的时间，那这正好可以通过装饰器来完成。于是我们构造了一个函数timeit作为装饰器，来装饰foo函数。</p>
<p>需要再次强调的一点是，装饰器timeit是用来装饰foo函数的，它只是给foo函数增加可以输出执行时间的特性，并不改变foo函数原来想要完成的功能。对foo函数原来所要做的事情，没有任何影响。</p>
<p>不过如果你留心一下，就会发现上面这个装饰器的实现中，用到了闭包这一技术（只是不那么明显，因为并没有带上一个额外的作用域，加上一个也是没问题的）。更准确的说，闭包和装饰器都是基于python中的可调用对象可以传递这一事实。</p>
<h3 id="u88C5_u9970_u5668_u6A21_u5F0F"><a href="#u88C5_u9970_u5668_u6A21_u5F0F" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>那么装饰器是怎么来的呢？其实这一概念来源于设计模式中的装饰器模式：在不改变核心调用对象的情况下，给它添加一些有趣的也可能很有用的特性。这正是“装饰”的意义所在。</p>
<p>这不仅既不用改动原来的核心对象，又达到了我们想要的目的，实在是高明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[缘起]]></title>
    <link href="http://starding.github.io/2016/01/05/hello-world/"/>
    <id>http://starding.github.io/2016/01/05/hello-world/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-01-07T07:21:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86" class="headerlink" title="仔细一想，我写博客也有一段时间了"></a>仔细一想，我写博客也有一段时间了</h3><p>回想这些年，我从大一的时候，就开始试着写博客了。当时涉及的技术比较少，大部分文章都是一些随笔，其内容也多是对一些社会事件的思考。</p>
<p>刚开始还不知道有独立博客这个概念，而且文章也都是发在qq空间的，原因是因为qq空间是我当时所知道的唯一能在网络上发表并保存日志的地方，也就将其档博客使用了。同时qq空间也有一些优点，因为它是基于qq这个社交平台的，自己所写的文章，总是可以被好友以及其他人看到，也会不时的得到一些反馈，这也是我当时的写作动力之一。</p>
<p>但是后来随着写的东西越来越偏向自己的专业，而且以前那些处处透露着中二思想的随笔类文章也很少写了，qq空间的优点越来越不明显。而且因为其巨差的写作体验（不流畅，仅支持富文本），写点简单的纯文字文章还行，元素稍微多点的文章就不行了。</p>
<h3 id="u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2"><a href="#u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2" class="headerlink" title="我曾在很多地方写过博客"></a>我曾在很多地方写过博客</h3><p>于是我转向寻找其他可以写博客的地方。豆瓣，网易等等，但是都觉得不是写作体验太差，就是<br>广告太多，严重影响心情，而且这个时候我正好了解了独立博客这样东西。于是开始申请域名，购买服务器，建立自己的wordpress，寻找比较好的模板，一番折腾之后，终于搭起了自己的独立博客。</p>
<p>然而拥有了一年多独立博客之后，发现在写作本身上面甚至没有花在维护博客上面的时间长，各种费心巴力的问题不断，最终累觉不爱。</p>
<p>这个时候我意识到，写作才是本来的目的，也不想再费力气维护一个独立的博客。于是就开始了第二次寻找合适写作平台之旅。试了试网易的lofter等一波平台，发现只有简书还算差强人意，但是简书的可定制性又不太好。</p>
<p>这个时候我也突然发现，自己已经用过太多的平台，所写的内容也零零散散，非常不利于自己的积累和知识梳理。于是决定再寻找。</p>
<p>最终找到了github孪生兄弟：gitpages。</p>
<h3 id="u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86"><a href="#u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86" class="headerlink" title="最终还是聚合在一起了"></a>最终还是聚合在一起了</h3><p>github本身就是程序员最常去的地方，gitpages评价又高，仅用了半天就搭起了一个半独立博客，一看效果，这正是我想要的。</p>
<p>于是开始了聚合之路…</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_u]]>
    </summary>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
