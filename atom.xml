<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小狐濡尾]]></title>
  <subtitle><![CDATA[未济]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://starding.github.io/"/>
  <updated>2016-01-18T09:00:30.000Z</updated>
  <id>http://starding.github.io/</id>
  
  <author>
    <name><![CDATA[starding]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[docker-gitlab数据迁移]]></title>
    <link href="http://starding.github.io/2016/01/18/gitlab-migrate/"/>
    <id>http://starding.github.io/2016/01/18/gitlab-migrate/</id>
    <published>2016-01-18T08:04:04.000Z</published>
    <updated>2016-01-18T09:00:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker_u7684filesystem_u5751"><a href="#docker_u7684filesystem_u5751" class="headerlink" title="docker的filesystem坑"></a>docker的filesystem坑</h1><p>前两天服务器出现了些问题，于是就重启了。没想到重启之后gitlab就跪了，启动时总是遇到一类比较底层的filesystem unkown错误，其报错细节不止一种。想来是底层的文件系统出了问题。</p>
<p>第一反应是先把gitlab的volumes备份了一下，然后直接删掉现有的gitlab容器，重开容器，没想到这个错误一直存在（删的时候没有选择-v），最后甚至把镜像都删掉了，重新拉镜像，仍然是出现filesystem类错误（只有gitlab如此，其他容器，镜像不受影响）。</p>
<p>网上查了很多解决办法，github上的docker仓库下，也有提到这一系列问题：<a href="https://github.com/docker/docker/issues/4036" target="_blank" rel="external">docker fails to mount the block device for the container on devicemapper</a>，感觉掉到一个深不见底的神坑里了。</p>
<p>这个底层错误，stackoverflow或github上给出的解决办法是：关掉docker，删除/var/lib/docker中的所有内容，然后重启gilab。我觉得可能是另一个神坑，没敢往里跳。于是选择慢慢研究这个问题，先在另外一台服务器上重新部署一下gitlab。</p>
<p>这个时候只需要把数据迁移过去就行了。</p>
<h1 id="gitlab_u6570_u636E_u8FC1_u79FB"><a href="#gitlab_u6570_u636E_u8FC1_u79FB" class="headerlink" title="gitlab数据迁移"></a>gitlab数据迁移</h1><p>原以为迁移会很简单，没想到也有不少坑等着跳。直接把volumes文件拷贝到新服务器上，按照原来的方法挂载，启动，首先发现是redis啥啥没有权限。于是google了一番，把权限都改了，然后发现出了一个<a href="https://gitlab.com/gitlab-org/gitlab-ce/commit/ff98c631c1004247656677568989e5ed68fc88f3" target="_blank" rel="external">unfoudmethod错误</a>。发现是数据库没有migrate的原因。</p>
<p>另外还有一个隐藏的坑就是，gitlab的版本问题。这种服务应用，尽量不要使用latest作为版本号，不然出了事情，还得去找自己使用的究竟是什么版本，如果找不到…准备拼人品吧。</p>
<p>感觉这么一个一个坑的跳，太二了，直到我发现了这篇教程，原来已经有人把坑都填好了：<a href="https://cmanios.wordpress.com/2015/12/04/migrate-a-gitlab-docker-container-from-version-8-0-4-to-8-2-0/" target="_blank" rel="external">Migrate a Gitlab Docker container from version 8.0.4 to 8.2.0
</a></p>
<p>附录：下面是原文（有时间了考虑翻译一下）<br>-</p>
<p>A few days ago, I had to migrate a Gitlab instance installed in Docker from version 8.04 to 8.2.0. I followed the exact steps described in GitLab Docker images documentation. But it was not so easy! Of cource, it required some more! Thus, after 4 hours of errors, searching and trials I found the way! Thank god!</p>
<p>In this article we will make the assumption that Gitlab volumes are stored in /home/bob/docker-data/gitlab directory. Here are the exact steps I followed to make a successful migration:</p>
<h2 id="1-Stop_docker_container"><a href="#1-Stop_docker_container" class="headerlink" title="1.Stop docker container"></a>1.Stop docker container</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop gitlab</span><br></pre></td></tr></table></figure>
<h2 id="2-Backup_docker_volumes__28all_gitlab_files_29"><a href="#2-Backup_docker_volumes__28all_gitlab_files_29" class="headerlink" title="2.Backup docker volumes (all gitlab files)"></a>2.Backup docker volumes (all gitlab files)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backupDate=$(date +<span class="string">"%Y%m%d%H%M%S"</span>) \</span><br><span class="line">  &amp;&amp; <span class="built_in">cd</span> /home/bob/docker-data/ \</span><br><span class="line">  &amp;&amp; sudo tar zvcf gitlab-data-<span class="variable">$&#123;backupDate&#125;</span>.tar.gz gitlab/</span><br></pre></td></tr></table></figure>
<h2 id="3-Optionally_backup_docker_image"><a href="#3-Optionally_backup_docker_image" class="headerlink" title="3.Optionally backup docker image"></a>3.Optionally backup docker image</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o /home/bob/gitlab-ce-image.tar gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="4-Remove_docker_container"><a href="#4-Remove_docker_container" class="headerlink" title="4.Remove docker container"></a>4.Remove docker container</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm gitlab</span><br></pre></td></tr></table></figure>
<h2 id="5-Download_the_latest_Gitlab_docker_image"><a href="#5-Download_the_latest_Gitlab_docker_image" class="headerlink" title="5.Download the latest Gitlab docker image"></a>5.Download the latest Gitlab docker image</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="6-After_the_image_is_downloaded_create_and_run_the_container"><a href="#6-After_the_image_is_downloaded_create_and_run_the_container" class="headerlink" title="6.After the image is downloaded create and run the container"></a>6.After the image is downloaded create and run the container</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_ins">run</span> -d \</span><br><span class="line">  --hostname 192.168.1.1 \</span><br><span class="line">  --publish 8443:443 --publish 8082:80 --publish 2224:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --<span class="built_ins">volume</span> /etc/localtime:/etc/localtime \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/config:/etc/gitlab \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --<span class="built_ins">volume</span> /home/bob/docker-data/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h2 id="7-The_container_starts_and_we_observer_the_logs_via_3A"><a href="#7-The_container_starts_and_we_observer_the_logs_via_3A" class="headerlink" title="7.The container starts and we observer the logs via:"></a>7.The container starts and we observer the logs via:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f --tail 10 gitlab</span><br></pre></td></tr></table></figure>
<h2 id="8-The_docker_container_started_and_we_observed_in_the_logs_3A"><a href="#8-The_docker_container_started_and_we_observed_in_the_logs_3A" class="headerlink" title="8.The docker container started and we observed in the logs:"></a>8.The docker container started and we observed in the logs:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2015-11-26T15:12:26+02:00] INFO: Retrying execution of execute[create gitlab database user], 19 attempt(s) left&#10;[2015-11-26T15:12:28+02:00] INFO: Retrying execution of execute[create gitlab database user], 18 attempt(s) left&#10;... (some lines omitted) ...&#10;[2015-11-26T15:13:09+02:00] INFO: Retrying execution of execute[create gitlab database user], 0 attempt(s) left&#10; &#10; &#10;Error executing action `run` on resource &#39;execute[create gitlab database user]&#39;&#10; &#10; &#10;Mixlib::ShellOut::ShellCommandFailed&#10; &#10;Expected process to exit with [0], but received &#39;2&#39;&#10;---- Begin output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; ----&#10;STDOUT: &#10;STDERR: psql: could not connect to server: No such file or directory&#10;Is the server running locally and accepting&#10;connections on Unix domain socket &#34;/var/opt/gitlab/postgresql/.s.PGSQL.5432&#34;?&#10;---- End output of /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; ----&#10;Ran /opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c &#34;CREATE USER gitlab&#34; returned 2&#10; &#10;Resource Declaration:&#10; &#10;# In /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb&#10; &#10;153:   execute &#34;create #&#123;sql_user&#125; database user&#34; do&#10;154:     command &#34;#&#123;bin_dir&#125;/psql --port #&#123;pg_port&#125; -h #&#123;postgresql_socket_dir&#125; -d template1 -c \&#34;CREATE USER #&#123;sql_user&#125;\&#34;&#34;&#10;155:     user postgresql_user&#10;156:     # Added retries to give the service time to start on slower systems&#10;157:     retries 20&#10;158:     not_if &#123; !pg_helper.is_running? || pg_helper.user_exists?(sql_user) &#125;&#10;159:   end&#10;160: &#10; &#10;Compiled Resource:&#10; &#10;# Declared in /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/postgresql.rb:153:in `block in from_file&#39;&#10; &#10;execute(&#34;create gitlab database user&#34;) do&#10;action [:run]&#10;retries 20&#10;retry_delay 2&#10;default_guard_interpreter :execute&#10;command &#34;/opt/gitlab/embedded/bin/psql --port 5432 -h /var/opt/gitlab/postgresql -d template1 -c \&#34;CREATE USER gitlab\&#34;&#34;&#10;backup 5&#10;returns 0&#10;user &#34;gitlab-psql&#34;&#10;declared_type :execute&#10;cookbook_name &#34;gitlab&#34;&#10;recipe_name &#34;postgresql&#34;&#10;not_if &#123; #code block &#125;&#10;end</span><br></pre></td></tr></table></figure>
<p>These are two known permission issues described in <a href="http://doc.gitlab.com/omnibus/docker/" target="_blank" rel="external">official documentation</a> and in issue <a href="https://github.com/gitlabhq/gitlabhq/issues/9611" target="_blank" rel="external">#9611</a>. In order to overcome them, we execute:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab update-permissions</span><br><span class="line">docker exec gitlab chown -R gitlab-redis /var/opt/gitlab/redis</span><br></pre></td></tr></table></figure>
<p>and finally we restart the docker container:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
<h2 id="9-Then_we_have_to_check_if_the_database_migration_was_successfull_and_avoid_issue__233255-_Thus_2C_we_log_into_bash_shell_3A"><a href="#9-Then_we_have_to_check_if_the_database_migration_was_successfull_and_avoid_issue__233255-_Thus_2C_we_log_into_bash_shell_3A" class="headerlink" title="9.Then we have to check if the database migration was successfull and avoid issue #3255. Thus, we log into bash shell:"></a>9.Then we have to check if the database migration was successfull and avoid issue #3255. Thus, we log into bash shell:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -t -i gitlab /bin/bash</span><br></pre></td></tr></table></figure>
<p>and we check the db migration status:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure>
<p>If everything is stated as up, we are OK. However, if we notice down migrations like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up     20150920161119  Add line code to sent notification&#10;down    20150924125150  Add project id to ci commit&#10;down    20150924125436  Migrate project id for ci commits</span><br></pre></td></tr></table></figure>
<p>we have to rerun the database migration ourserlves:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate</span><br></pre></td></tr></table></figure>
<p>When it finishes we have to check that everything went ok:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake db:migrate:status</span><br></pre></td></tr></table></figure>
<h2 id="10-While_being_inside_the_container_bash_shell_2C_we_reconfigure_the_installation_3A"><a href="#10-While_being_inside_the_container_bash_shell_2C_we_reconfigure_the_installation_3A" class="headerlink" title="10.While being inside the container bash shell, we reconfigure the installation:"></a>10.While being inside the container bash shell, we reconfigure the installation:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>and then check that everything went ok:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:check</span><br></pre></td></tr></table></figure>
<h2 id="11-If_everything_is_OK_2C_then_the_command_3A"><a href="#11-If_everything_is_OK_2C_then_the_command_3A" class="headerlink" title="11.If everything is OK, then the command:"></a>11.If everything is OK, then the command:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake gitlab:env:info RAILS_ENV=production</span><br></pre></td></tr></table></figure>
<p>must return something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System information&#10;System:   Ubuntu 14.04&#10;Current User: git&#10;Using RVM:  no&#10;Ruby Version: 2.1.7p400&#10;Gem Version:  2.2.5&#10;Bundler Version:1.10.6&#10;Rake Version: 10.4.2&#10;Sidekiq Version:3.3.0&#10; &#10;GitLab information&#10;Version:  8.2.0&#10;Revision: d6bcf44&#10;Directory:  /opt/gitlab/embedded/service/gitlab-rails&#10;DB Adapter: postgresql&#10;URL:    http://192.168.1.1:8082&#10;HTTP Clone URL: http://192.168.1.1:8082/some-group/some-project.git&#10;SSH Clone URL:  git@192.168.1.1:some-group/some-project.git&#10;Using LDAP: yes&#10;Using Omniauth: no&#10; &#10;GitLab Shell&#10;Version:  2.6.7&#10;Repositories: /var/opt/gitlab/git-data/repositories&#10;Hooks:    /opt/gitlab/embedded/service/gitlab-shell/hooks/&#10;Git:    /opt/gitlab/embedded/bin/git</span><br></pre></td></tr></table></figure>
<h2 id="12-Finally_we_have_to_clear_Redis_cache"><a href="#12-Finally_we_have_to_clear_Redis_cache" class="headerlink" title="12.Finally we have to clear Redis cache"></a>12.Finally we have to clear Redis cache</h2><p>or we will face the issue <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/3619" target="_blank" rel="external">#3619</a> or issue <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/3609" target="_blank" rel="external">#3609</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-rake cache:clear</span><br></pre></td></tr></table></figure>
<h2 id="13-After_that_you_will_be_able_to_login_properly_to_http_3A//localhost_3A8082"><a href="#13-After_that_you_will_be_able_to_login_properly_to_http_3A//localhost_3A8082" class="headerlink" title="13.After that you will be able to login properly to http://localhost:8082"></a>13.After that you will be able to login properly to <a href="http://localhost:8082" target="_blank" rel="external">http://localhost:8082</a></h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="docker_u7684filesystem_u5751"><a href="#docker_u7684filesystem_u5751" class="headerlink" title="docker的filesystem坑"></a>docker的files]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="gitlab" scheme="http://starding.github.io/tags/gitlab/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机领域中的概念辨析]]></title>
    <link href="http://starding.github.io/2016/01/15/learn-in-computer-sciense/"/>
    <id>http://starding.github.io/2016/01/15/learn-in-computer-sciense/</id>
    <published>2016-01-15T15:32:53.000Z</published>
    <updated>2016-01-15T17:19:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6982_u5FF5_u8FA8_u6790_3F"><a href="#u6982_u5FF5_u8FA8_u6790_3F" class="headerlink" title="概念辨析?"></a>概念辨析?</h2><p>概念, 摘自维基百科，为了保持概念的完整性，这里摘录了比较长的内容：</p>
<blockquote>
<p>概念也称观念，是抽象的、普遍的想法、观念或充当指明实体、事件或关系的范畴或类的实体。在它们的外延中忽略事物的差异，如同它们是同一的去处理它们，所以概念是抽象的。它们等同的适用于在它们外延中的所有事物，所以它们是普遍的。概念也是命题的基本元素，如同词是句子的基本语义元素一样。</p>
<p>概念是意义的载体，而不是意义的主动者。一个单一的概念可以用任何数目的语言来表达；术语则是概念的表达形式。狗的概念可以表达为德语的 Hund，法语的 chien 和西班牙语的 perro。概念在一定意义上独立于语言的事实使得翻译成为可能 - 在各种语言中词有同一的意义，因为它们表达了相同的概念。</p>
<p>概念是人类对一个复杂的过程或事物的理解。从哲学的观念来说概念是思维的基本单位。在日常用语中人们往往将概念与一个词或一个名词（术语）同等对待。传统上认为中国文化不强调定义概念，因此没有发展出逻辑和相关的哲学、科学。</p>
</blockquote>
<p>所谓概念辨析，就是去追溯词语的意思，来历，以及其可能的语境。这在哲学中是非常常见的，甚至在讨论每一个问题之前，都首先要把问题中的每一个概念辨析清楚，彻底搞清楚问题中的每一个词汇是什么意义，然后讨论才能继续往下进行。</p>
<h2 id="u4FEE_u8F9E_u5B66_u4EE5_u53CA_u7FFB_u8BD1_u4E2D_u7684_u5931_u771F"><a href="#u4FEE_u8F9E_u5B66_u4EE5_u53CA_u7FFB_u8BD1_u4E2D_u7684_u5931_u771F" class="headerlink" title="修辞学以及翻译中的失真"></a>修辞学以及翻译中的失真</h2><p>需要概念辨析的原因是多种多样的，可能是一个概念因为时间的关系，经历了意义的变化；也有可能是因为一个词是完全的外来词汇，在翻译中流失了原来的意义。而在计算机科学本身就是引入的科学，其专业术语基本都是翻译过来的。所以这里词汇辨析也就更倾向于消除翻译中的失真问题。</p>
<p>在计算机科学中，至少我目前所接触到的诸多书籍，甚至是在之前所受的专业的计算机教育中，都没有词语辨析这一块。而且由于汉语本身重修辞，轻辨析的特点，在原来英文词汇中存在的比较直白的意象，到了汉语翻译时，就可能为了优美，意向等加入一些隐含的修辞手法，开始变得玄妙起来。这个时候去追寻原来的词汇就非常重要了。</p>
<p>相应的翻译有：</p>
<ul>
<li>handle 翻译为「句柄」</li>
<li>socket 翻译为「套接字」</li>
<li>meta-programming  翻译为 「元编程」</li>
</ul>
<p>等等，这些翻译在英文中的含义都比较直白，但是到了汉语中，为了兼顾概念的简洁，雅致，借用了很多本土化的意象，但是这些意象本身就是比较朦胧的意思。导致原来明确地意思，变得朦胧，难以理解。这些翻译都是历史和当时技术背景下的产物。其实如果放到今天，可能根本不会像原来那样去翻译，甚至关键的词直接就保留了。</p>
<p>遇到这些词汇的时候我们就需要考察它翻译的时期，以及翻译成中文之前的源词汇是什么。找到这些源词汇后，在源词汇中的上下文中去理解。但是即便是在源词汇中，也是很有辨析的必要的。因为源词汇也不是凭空而来的，计算机是一门非常新的科学，其词汇也有很多是新构造的词。这些词有的是直接造出来的，有的则也是用了一定的修辞，在原来的意义上引申到进计算机领域中来。</p>
<p>一个词汇的引申并不是毫无理由的，其背后的动机往往是某些概念具有内在的联系，而这也常常构成一种修辞手法：「隐喻」</p>
<h2 id="u6982_u5FF5_u80CC_u540E_u7684_u9690_u55BB"><a href="#u6982_u5FF5_u80CC_u540E_u7684_u9690_u55BB" class="headerlink" title="概念背后的隐喻"></a>概念背后的隐喻</h2><p>概念辨析另一层好处就是，它能让我们看到概念背后的隐喻。进而我们更好，也更深刻地理解一个概念的核心思想。</p>
<p>举例来说，个人比较喜欢的几个隐喻是：</p>
<ul>
<li>docker 码头工人的隐喻</li>
<li>handle 把手的隐喻</li>
<li>callback  回电的隐喻</li>
<li>hook        钩子的隐喻</li>
</ul>
<p>隐喻的共同点就是，其本身直白的原意以一种比较隐含的方式与其在计算机科学中的概念关联，它们之间有一种很相似的结构，含义等。想要快速理解一个词汇的含义，将其隐喻与现有语境结合起来是非常重要的。</p>
<h2 id="u6982_u5FF5_u8FA8_u6790_u80CC_u540E_u7684_u54F2_u5B66_u601D_u60F3"><a href="#u6982_u5FF5_u8FA8_u6790_u80CC_u540E_u7684_u54F2_u5B66_u601D_u60F3" class="headerlink" title="概念辨析背后的哲学思想"></a>概念辨析背后的哲学思想</h2><p>「直推因」和「目的因」的辨析</p>
<p>待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6982_u5FF5_u8FA8_u6790_3F"><a href="#u6982_u5FF5_u8FA8_u6790_3F" class="headerlink" title="概念辨析?"></a>概念辨析?</h2><p>概念, 摘自维基百科，为了保持概]]>
    </summary>
    
      <category term="computer" scheme="http://starding.github.io/tags/computer/"/>
    
      <category term="computer philosophy" scheme="http://starding.github.io/categories/computer-philosophy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中的装饰器和迭代器]]></title>
    <link href="http://starding.github.io/2016/01/15/python-iterator-generator/"/>
    <id>http://starding.github.io/2016/01/15/python-iterator-generator/</id>
    <published>2016-01-15T14:59:16.000Z</published>
    <updated>2016-01-15T15:23:37.000Z</updated>
    <content type="html"><![CDATA[<p>简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不是很靠谱，很明显甚至连官方文档都没有看，就只根据经验就直接写文章来总结了，很容易误导人。</p>
<h1 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u5668" class="headerlink" title="迭代器"></a>迭代器</h1>]]></content>
    <summary type="html">
    <![CDATA[<p>简单整理一下吧，毕竟输出才是检验自己水平更好的方法。而且感觉网上很多文章都不是很靠谱，很明显甚至连官方文档都没有看，就只根据经验就直接写文章来总结了，很容易误导人。</p>
<h1 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim学习]]></title>
    <link href="http://starding.github.io/2016/01/14/learn-vim/"/>
    <id>http://starding.github.io/2016/01/14/learn-vim/</id>
    <published>2016-01-14T15:21:24.000Z</published>
    <updated>2016-01-15T03:58:15.000Z</updated>
    <content type="html"><![CDATA[<p>记录用到的一些vim使用方法，积累够一定数量再整理</p>
<h2 id="u4F7F_u7528_u573A_u666F1"><a href="#u4F7F_u7528_u573A_u666F1" class="headerlink" title="使用场景1"></a>使用场景1</h2><p>有一次，我需要在一个包含很多行短文字的后面补上的空格，将每一行补成相同的宽度。然后接下来在markdown中制作表格.</p>
<p>刚开始使用各种列编辑，块编辑尝试都没有用。难道必须写一个程序来专门处理这件事情？</p>
<p>后来发现正则表达式基本能满足这一要求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/$/ n_spaces /g</span><br></pre></td></tr></table></figure>
<p>在vim中，$符有丰富的含义，这里值指的是行尾前一个字符</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录用到的一些vim使用方法，积累够一定数量再整理</p>
<h2 id="u4F7F_u7528_u573A_u666F1"><a href="#u4F7F_u7528_u573A_u666F1" class="headerlink" title="使用场景1"></a>]]>
    </summary>
    
      <category term="vim" scheme="http://starding.github.io/tags/vim/"/>
    
      <category term="vim" scheme="http://starding.github.io/categories/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从快播案看技术中性论的地位]]></title>
    <link href="http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/"/>
    <id>http://starding.github.io/2016/01/11/kuaibo-technological-neutrality/</id>
    <published>2016-01-11T05:07:32.000Z</published>
    <updated>2016-01-12T07:44:17.000Z</updated>
    <content type="html"><![CDATA[<p>本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。</p>
<blockquote>
<p>technological neutrality</p>
<p>中文意思为「技术中性论」， 核心主张是技术是纯粹的，价值中立的，其本身不存在是非善恶这些性质；技术的归宿是人类的使用，而最终产生的结果，也应该由人类自身来承担。</p>
</blockquote>
<h1 id="u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA"><a href="#u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA" class="headerlink" title="快播案中的技术中性论"></a>快播案中的技术中性论</h1><p>最近的快播案中的辩论，有关技术价值部分，可以说是「技术中性论」在科学哲学中所受讨论的缩影：技术中性论在科学哲学中，持续了非常长的一段时间，而且直到今天还非常有市场。在普通民众群体中，技术中性论甚至更是唯一的关于技术的价值观。</p>
<p>「技术中性论」价值观中，有一些非常常见的论据：</p>
<ul>
<li>日常生活中的例子：用刀杀了人，有罪的是人，而不是刀，也不是生产刀的厂家。</li>
<li>科学中的例子：原子弹是无罪的，有罪的是滥用它们的人。</li>
<li>互联网的例子：木马是无罪的，有罪的是用它们来进行非法活动的人。</li>
</ul>
<p>这些主张都是在论证技术的价值中立特点。后面会说这些论据的漏洞在哪里。</p>
<h2 id="u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA"><a href="#u79D1_u5B66_u54F2_u5B66_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA" class="headerlink" title="科学哲学中的技术中性论"></a>科学哲学中的技术中性论</h2><p>其实「技术中性论」的观点，在科学哲学中很早就出现了，而且因为技术本身的「自我隐蔽性」，技术所附带的价值天然倾向于中立性。在近代工业革命之后，技术的弊病逐渐显露出来，而对技术价值的反思，也在科学哲学中有了新的进展。</p>
<h3 id="u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u7684_u524D_u63D0_uFF1A_u5F53_u6211_u4EEC_u5728_u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u65F6_uFF0C_u6211_u4EEC_u5728_u8BA8_u8BBA_u4EC0_u4E48_uFF1F"><a href="#u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u7684_u524D_u63D0_uFF1A_u5F53_u6211_u4EEC_u5728_u8BA8_u8BBA_u6280_u672F_u4EF7_u503C_u65F6_uFF0C_u6211_u4EEC_u5728_u8BA8_u8BBA_u4EC0_u4E48_uFF1F" class="headerlink" title="讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？"></a>讨论技术价值的前提：当我们在讨论技术价值时，我们在讨论什么？</h3><p>『技术没有价值偏向。一切技术的使用，所产生的后果，归根结底都应该由人类承担，不管它是好的或是坏的』。从根本上讲，这句话是对的，因为如果不是人类，根本就不会有技术，那也就不会有技术带来的副作用。在这种意义下，说『所有的罪，最终都归于人类』也无可厚非。</p>
<p>但是在现实中，并不能这样去讨论问题。即便是技术哲学中，在上面的意义下讨论问题也是无意义的，这种意义下的讨论不会给人类理解技术带来任何实质的帮助。</p>
<p>讨论技术价值的前提是：</p>
<p><strong>『技术是人类创建出来的，也是由人类使用的。技术并不是「死的」，它对人类是有影响的』</strong></p>
<p>在这种前提下，我们在讨论技术价值时，我们讨论的是：技术本身是否真的是纯粹的，技术会不会在某些方面对人类产生副作用。更准确地说，技术是人类创造出来的，那么这种创造物，对人类的自我建构会不会产生影响？</p>
<h3 id="u6280_u672F_u7684_u610F_u5411_u7ED3_u6784"><a href="#u6280_u672F_u7684_u610F_u5411_u7ED3_u6784" class="headerlink" title="技术的意向结构"></a>技术的意向结构</h3><p>试想这样一种情景：</p>
<p>有两个民族，一个民族在族人很小的时候，就送他们刀与马。而另一个民族，则送他们诗与书。那么在这两个民族成长之后会发生什么呢？可以想象，第一个民族，刀会成为他们首选的说话方式。而第二个民族，诗书则会成为他们选择的说话方式。</p>
<p>再举一个更贴近生活的例子，又一次老板问我，mac用着爽吗？是不是用mac，用着这些比较好的工具，就是想写东西，想写代码？用mac，你就是想写代码，用windows，你就是想玩儿游戏。</p>
<p>上面的例子是想要说明，技术本身是有它的意向结构的，这种意向结构带有一种附加的价值，不自觉地对人类产生副作用。这种副作用的产生，不是人类可以选择的，在群体中更是如此。人类身处自身范式之中，没有这种能力，去清晰的分辨一种意向结构长期带来的影响。</p>
<p>需要注意的是，这里只是说技术有自己的意向结构，反过来对人类产生不自觉地副作用。并没有对这种意向结构，做出价值上的判断，即没有判断它是好还是坏。实际上，这是一个相当艰巨，甚至多数时候是不能完成的任务。</p>
<p>另一方面，说技术对人类的自我建构有副作用，也不像传统哲学中的「决定论」那样，会出现人类没有自由意志，做出的任何决定，犯下的任何过错，都不用，也不能承担后果的局面。</p>
<p>在技术哲学中，技术的非中性论论题主张『技术与人类是互相构建的』</p>
<h3 id="u56DE_u5230_u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA_u70B9"><a href="#u56DE_u5230_u5FEB_u64AD_u6848_u4E2D_u7684_u6280_u672F_u4E2D_u6027_u8BBA_u70B9" class="headerlink" title="回到快播案中的技术中性论点"></a>回到快播案中的技术中性论点</h3><p>技术的意向结构，决定了它必然会对人类产生副作用，也揭示出前面所列举论据的一个非常大的漏洞：它假设了一个前提，就是人类可以完全清醒的判断，一样技术的使用会有什么潜在的副作用。换句话说，人类可以清楚的知道，并且控制技术所带来的反作用，包括那些非常明显的和潜伏的效果。</p>
<p>但这是不现实的，很多技术的副作用是难以察觉的，你很难清楚的知道，长期使用微信这项技术，对你会产生，或者已经产生了怎样的影响。更何况人类身处一个技术交织成的大网之中了。</p>
<p>另一方面是，技术对于群体产生的副作用比起对个人产生的副作用，要更为复杂了，因为一个群体中的行为并不是简单个人行为的叠加，一种技术对群体带来的影响更为深远。以编程语言为例，纯粹的c程序员和python程序员必然是有差别的，而这些差别体现到群体上，基本就反映出了C和python设计哲学中的差别，也就是其本身意向结构的差别。</p>
<p>也就是说，技术在群体中产生的作用，最终会更接近技术本身意向结构：如果快播可以方便的传播淫秽资料，那么在目前文明阶段的自然情况下，它必然会传播淫秽资料，而不是学习资料。如果明白了这一点，也就能清楚的直到关键点在哪——控制，监管，批判，反思。</p>
<p>这也是技术批判理论主张的：</p>
<p><strong>『即使技术是由自身的意向结构的，但这对于我们的指导是更谨慎，更批判的去处理它，而不是直接对其做出价值判断来肯定或否定它』</strong></p>
<h2 id="u79D1_u5B66_u54F2_u5B66_u4E0E_u793E_u4F1A_u6280_u672F_u51B3_u7B56"><a href="#u79D1_u5B66_u54F2_u5B66_u4E0E_u793E_u4F1A_u6280_u672F_u51B3_u7B56" class="headerlink" title="科学哲学与社会技术决策"></a>科学哲学与社会技术决策</h2><p>待续</p>
<h1 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h1><p>关于技术的哲学，之前从未有过深思。仅从《娱乐至死》一书中体会到技术与人类的关系不是一分为二那么简单。后来也思考过技术中性论的问题，总觉得什么地方有问题，但是又说不上来，直到读了吴国盛老师的《技术哲学演讲录》，得到了一个迄今为止，我最为满意的一个答案：</p>
<blockquote>
<p><strong>『技术与人类是互相构建的』</strong></p>
</blockquote>
<h2 id="u300A_u6280_u672F_u54F2_u5B66_u6F14_u8BB2_u5F55_u300B_u5185_u5BB9_u8981_u70B9_u6458_u5F55_uFF1A"><a href="#u300A_u6280_u672F_u54F2_u5B66_u6F14_u8BB2_u5F55_u300B_u5185_u5BB9_u8981_u70B9_u6458_u5F55_uFF1A" class="headerlink" title="《技术哲学演讲录》内容要点摘录："></a>《技术哲学演讲录》内容要点摘录：</h2><h3 id="u6280_u672F_u7684_u4EBA_u6587_u672C_u8D28"><a href="#u6280_u672F_u7684_u4EBA_u6587_u672C_u8D28" class="headerlink" title="技术的人文本质"></a>技术的人文本质</h3><ul>
<li><p>什么是技术？</p>
<ul>
<li>技术是人的存在方式，技术与人并非是一分为二的</li>
</ul>
</li>
<li><p>人的本质是什么？</p>
<ul>
<li>人是一种没有本质的动物，人的本质是自我建构的</li>
</ul>
</li>
<li><p>技术的特性</p>
<ul>
<li><p>技术是自我隐蔽的，而西方学术史是只重视内在理路的历史</p>
</li>
<li><p>技术中性论的问题：技术是有意象结构的，包含着特定的价值取向</p>
</li>
<li><p>技术是构造人和世界的环节：身体技术，人类都是早产儿，身体塑造，知觉塑造。ppt的使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="u6280_u672F_u4E0E_u653F_u6CBB"><a href="#u6280_u672F_u4E0E_u653F_u6CBB" class="headerlink" title="技术与政治"></a>技术与政治</h3><ul>
<li><p>技术有政治吗</p>
<ul>
<li>技术与政治是相关的。政治干预技术，技术影响政治：火药消灭骑士阶层，是封建制度的掘墓者。水利社会与集权制度。</li>
</ul>
</li>
<li><p>技术的政治批判</p>
<ul>
<li>手推磨产生了封建制度，蒸汽磨产生了资本主义制度。</li>
</ul>
</li>
<li><p>泰勒制与福特制</p>
<ul>
<li>技术导致人性的退让：新闻上看到死人慢慢无视</li>
</ul>
</li>
<li><p>三种技术观</p>
<ul>
<li><p>技术乐观主义：技术中性论者，技术带来的问题只能用技术解决</p>
</li>
<li><p>技术悲观主义：技术自主论，有内在的发展逻辑，认为现代社会进入了一个单向度社会，差异感消失，技术的触角深入到每一个领域。但它是以整体观点看待技术，把技术看做铁板一块，没搞清楚技术各种可能性，只有深入细节，才能走出悲观主义。</p>
</li>
<li><p>技术批判理论：深入技术的细节，考察各方面。：技术转化论。流水线，计算机，通信，交通，宣传技术。一切新技术都要问谁受益，谁吃亏。</p>
</li>
</ul>
</li>
</ul>
<h3 id="u6280_u672F_u4E0E_u54F2_u5B66"><a href="#u6280_u672F_u4E0E_u54F2_u5B66" class="headerlink" title="技术与哲学"></a>技术与哲学</h3><ul>
<li><p>技术哲学的历史性缺席</p>
<ul>
<li><p>美，正义，善，艺术，科学，都是哲学关注点，技术却不是。</p>
</li>
<li><p>技术本身：自身隐蔽性，和长期的技术中性论</p>
</li>
<li><p>哲学：哲学注重说理，讲内在逻辑。：本质主义</p>
</li>
</ul>
</li>
<li><p>技术哲学的兴起</p>
<ul>
<li><p>技术本身的变化：近来技术的问题出现了，不再透明</p>
</li>
<li><p>哲学：本质主义的瓦解与现象主义的出现。经验论传承唯名论。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文只讨论快播案中的的「技术中性论」问题，以及它在科学哲学中的地位与现状。</p>
<blockquote>
<p>technological neutrality</p>
<p>中文意思为「技术中性论」， 核心主张是技术是纯粹的，价值中立的，其本身不存在是非善恶这些性质；]]>
    </summary>
    
      <category term="科学哲学" scheme="http://starding.github.io/tags/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"/>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="科学史与科学哲学" scheme="http://starding.github.io/categories/%E7%A7%91%E5%AD%A6%E5%8F%B2%E4%B8%8E%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那些年我在python中扑过的街]]></title>
    <link href="http://starding.github.io/2016/01/10/traps-in-python/"/>
    <id>http://starding.github.io/2016/01/10/traps-in-python/</id>
    <published>2016-01-10T11:22:10.000Z</published>
    <updated>2016-01-18T11:58:26.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前事不忘，后事之师。        ——《战国策·赵策一》</p>
</blockquote>
<h2 id="python_u4E2D_u7684_u5305_u5BFC_u5165"><a href="#python_u4E2D_u7684_u5305_u5BFC_u5165" class="headerlink" title="python中的包导入"></a>python中的包导入</h2><p>这个比较简单，一个例子带过吧，但刚开始确实扑街了…</p>
<p>文件结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">packages</span><br><span class="line">├── __init__.py</span><br><span class="line">└── my_module.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是包导入</span></span><br><span class="line"><span class="keyword">import</span> packages</span><br><span class="line"><span class="comment"># 后续是从__init__.py中定义的属性中获取的</span></span><br><span class="line">packages.some_module.some_method</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是把包当做搜索路径上的一环</span></span><br><span class="line"><span class="keyword">from</span> packages <span class="keyword">import</span> some_module</span><br><span class="line">some_module.some_method</span><br></pre></td></tr></table></figure>
<h2 id="try-except-finally_u4E2D_u8BED_u53E5_u6267_u884C_u987A_u5E8F"><a href="#try-except-finally_u4E2D_u8BED_u53E5_u6267_u884C_u987A_u5E8F" class="headerlink" title="try-except-finally中语句执行顺序"></a>try-except-finally中语句执行顺序</h2><p>在python的异常处理中，无论try语句中是否有异常抛出，finally语句总会被执行。由于这个特性，finally语句经常被用来做一些清理工作，例如关闭文件，数据库等等。</p>
<p>如果当try-except-finally中出现异常，并且未被妥善处理时，python会先把发生的异常暂存，当finally中的动作执行完毕之后，把保存的异常返回给上级。try-except-finally中的语句执行顺序，决定了它会有一些潜在的陷阱。</p>
<p>看以下例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finallyTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'start------'</span></span><br><span class="line">	<span class="keyword">while</span>  <span class="keyword">True</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">"running------"</span></span><br><span class="line">			<span class="keyword">raise</span> IndexError(<span class="string">"r"</span>)	<span class="comment">#抛出异IndexError异常</span></span><br><span class="line">		<span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'NameError happended &#123;0&#125;'</span>.format(str(e))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">finally</span>:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'finally executed'</span></span><br><span class="line">			<span class="keyword">break</span> <span class="comment">#finally语句中有break语句</span></span><br><span class="line">			</span><br><span class="line"><span class="comment"># 执行测试函数</span></span><br><span class="line">FinallyTest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为：</span></span><br><span class="line">start------</span><br><span class="line">running------</span><br><span class="line"><span class="keyword">finally</span> executed</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在try语句中，raise出了一个IndexError异常，而且except语句也没有捕获这个错误。按照平常的理解，这个错误会向上级（也就是调用这个函数的程序）传递，在本例中会传递到解释器，并引发一个IndexError错误。但是整个函数执行完之后并没有异常出现。</p>
<p>原因就在于在当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被「临时保存起来」。当finally执行完毕的时候，临时保存的异常将会「再次被抛出」，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会被丢失，从而导致「异常屏蔽」。</p>
<p>另外一个稍微复杂一些例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.Logger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">returnTest</span><span class="params">(a)</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">if</span> a == <span class="keyword">False</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">"data can not be False"</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> a  </span><br><span class="line">	<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">		logger.exception(<span class="string">"exception!, &#123;detail&#125;"</span>).fomat(detail)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"return exception in except statement"</span> </span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"return in finally statement"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> returnTest(<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> returnTest(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>按照平常理解，第一个print语句会触发错误，然后进入except语句打印异常，而同时finally部分中的语句必然会执行，所以这里会返回一个’return in finally statement’值。第二个则会返回True。实际上则不然，返回值竟然都是’return in finally statement’。</p>
<p>原因是和上面的例子中是一样的，无论是try复合语句中，还是except复合语句中的return/break语句，这种会产生程序跳转的语句会先被保存起来。然后再去执行finally中的语句，而一旦finally中出现了跳转语句，就会直接跳转了，这样早成的结果就是上面保存状态的消失。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前事不忘，后事之师。        ——《战国策·赵策一》</p>
</blockquote>
<h2 id="python_u4E2D_u7684_u5305_u5BFC_u5165"><a href="#python_u4E2D_u7684_u]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open Questions]]></title>
    <link href="http://starding.github.io/2016/01/10/open-questions/"/>
    <id>http://starding.github.io/2016/01/10/open-questions/</id>
    <published>2016-01-10T07:23:04.000Z</published>
    <updated>2016-01-10T13:18:29.000Z</updated>
    <content type="html"><![CDATA[<p>本文专门用于汇总一些平时遇到的问题。<br>这些问题有的有一些我的初步思考，但可能存在很大的缺陷，甚至根本上就是错误的。而有的是刚遇到，或者是刚刚想到的问题，因为身处于自己的范式之中，我目前甚至都判断不清楚这些问题是不是幼稚的，这些问题本身是不是就有问题。</p>
<p>或许是受过一点科学哲学教育的原因，总是想着在学习的过程中，试着了解一件事物的目的因。虽然在自然科学研究中，追寻直推因是知识增长的最佳方式，目的因的追求往往产生问题，而且不现实。但是，在计算机科学中，有非常多的事物是人类直接定义的，可以说计算机世界大部分都是人类自己创造的，在这样的情况下，追求目的因才是最好，也是最深刻的知识增长方式。</p>
<p>总之，我把问题以及目前的思路记录下来了。<br>对于我来说，能提出问题的时候，才是真正开始理解的时候</p>
<h2 id="u5DE5_u7A0B_u7C7B_u95EE_u9898"><a href="#u5DE5_u7A0B_u7C7B_u95EE_u9898" class="headerlink" title="工程类问题"></a>工程类问题</h2><ul>
<li>RESTful 与 ROA（面向资源的架构）之间的关系是什么？<ul>
<li>RESTful我是大致了解的，而且也简单实践过。</li>
<li>面向资源的架构，按照字面意思来理解，就是以资源为中心的架构，比如在后台，按照资源分类，实现各个资源的切分，然后按照比较独立的资源进行组合出想要的内容。</li>
<li>以一个隐喻来说，就像是在建造一幢大楼时，所有的原材料（资源）都以比较细分的方式给出来了，而且，理论上利用这些原材料，能构建出大部分结构的大楼。</li>
</ul>
</li>
</ul>
<h2 id="Meta__u95EE_u9898"><a href="#Meta__u95EE_u9898" class="headerlink" title="Meta 问题"></a>Meta 问题</h2><ul>
<li>计算机科学与自然科学学习中的不同。<ul>
<li>主要是有关方法论的。在自然科学中，比如物理学中，我们可能试着找出一件事物的目的因，比如为什么光速是有限的之类的，或是像生物学中的，为什么对于人类来说，乙醇没毒，而甲醇等相似结构的毒性却很大。在自然科学的研究中，我们会直接去寻找它表现为什么样，这叫做直推因，而且这种研究方式在自然科学中，很容易获得知识的增加。</li>
<li>在计算机科学中，大部分世界都是人类创造的，人类直接定义，制造了这个世界，所以很多时候，我们是可以追问目的因的，虽然追问到最后，仍有一部分问题会回到自然科学中，或是形式科学中。但是追寻目的因可以让我们更快速的深入一个问题的本质。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文专门用于汇总一些平时遇到的问题。<br>这些问题有的有一些我的初步思考，但可能存在很大的缺陷，甚至根本上就是错误的。而有的是刚遇到，或者是刚刚想到的问题，因为身处于自己的范式之中，我目前甚至都判断不清楚这些问题是不是幼稚的，这些问题本身是不是就有问题。</p>
<p>或]]>
    </summary>
    
      <category term="open-questions" scheme="http://starding.github.io/tags/open-questions/"/>
    
      <category term="open-questions" scheme="http://starding.github.io/categories/open-questions/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的前端笔记之理解html篇]]></title>
    <link href="http://starding.github.io/2016/01/09/my-front-end-introduction/"/>
    <id>http://starding.github.io/2016/01/09/my-front-end-introduction/</id>
    <published>2016-01-09T06:34:19.000Z</published>
    <updated>2016-01-14T09:36:30.000Z</updated>
    <content type="html"><![CDATA[<p>之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像html的某个元素啦，或是某个css的具体意思了，再或者是写一点javascript啦之类的内容。但总是感觉对前端缺乏一种比较顶层的认识。</p>
<p>虽然偶尔也会听说一些关于网页三剑客的比喻。类似html是网页的骨骼，负责网页的骨架部分；css是网页的皮肤，负责网页的外观部分；javascript则是网页的肌肉，给网页上的交互提供动力。不过这种说法似乎又太过于宽泛了，难以让人形成具体的认识。</p>
<p>所以本文试着整理一种介于上述比喻，以及底层细节之间的一些内容。通过分别叙述html，css，javascript的核心角色，试着能不能找到那种高屋建瓴的感觉。</p>
<p>首先辨析一下前端两个概念：「排版」和「布局」</p>
<p>参考知乎的两个回答：<br><a href="/有没有人觉得web排版系统，设计得非常非常烂？ - 回答作者：徐飞 http://zhihu.com/question/38795148/answer/78177006?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu（想看更多？下载知乎 App：http://weibo.com/p/100404711598）">排版和布局是两个不同的东西</a><br>和<br><a href="/在 CSS 中，用 float 和 position 的区别是什么？ - 回答作者：贺师俊 http://zhihu.com/question/19588854/answer/13243044?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu（想看更多？下载知乎 App：http://weibo.com/p/100404711598）">布局和排版是有差异的</a></p>
<p>「布局」指的是宏观GUI的划分，比如你有多个大块的东西，想要按照指定方式排布。</p>
<p>「排版」指的是，比如你有一些段落，段落中有不同的字体，不同字号，按照不同基线对齐、折行、断词，并且合理处理溢出的部分。</p>
<h2 id="u4ECE_u7F51_u9875_u8BF4_u8D77"><a href="#u4ECE_u7F51_u9875_u8BF4_u8D77" class="headerlink" title="从网页说起"></a>从网页说起</h2><h3 id="u7F51_u9875_u662F_u73B0_u5B9E_u751F_u6D3B_u4E2D_u5404_u79CD_u4FE1_u606F_u8F7D_u4F53_u7684_u7F51_u7EDC_u805A_u5408_u7248"><a href="#u7F51_u9875_u662F_u73B0_u5B9E_u751F_u6D3B_u4E2D_u5404_u79CD_u4FE1_u606F_u8F7D_u4F53_u7684_u7F51_u7EDC_u805A_u5408_u7248" class="headerlink" title="网页是现实生活中各种信息载体的网络聚合版"></a>网页是现实生活中各种信息载体的网络聚合版</h3><p>网页，是前端最直接的展示部分。它的目的在于「展示信息」，其他的一切活动都是为展示信息服务的。 网页和其他的展示信息的载体，并没有什么本质的差别。想象一下我们日常生活中常见的信息载体：一个word文档，一份PDF，一份调查问卷，一份财务报表等等。而网页就是这些信息载体的网络聚合版本。</p>
<h3 id="u4EBA_u7C7B_u5728_u5173_u6CE8_u7F51_u9875_u65F6_uFF0C_u4EBA_u7C7B_u5728_u5173_u6CE8_u4EC0_u4E48"><a href="#u4EBA_u7C7B_u5728_u5173_u6CE8_u7F51_u9875_u65F6_uFF0C_u4EBA_u7C7B_u5728_u5173_u6CE8_u4EC0_u4E48" class="headerlink" title="人类在关注网页时，人类在关注什么"></a>人类在关注网页时，人类在关注什么</h3><p>就像我们对待生活中的那些信息载体以及其所附带的信息那样，我们也会以类似的态度对待网页：首先关注的是文档本身展示出的内容，如果这些内容展示的格式非常漂亮，那可能会让我们阅读时更愉快，也更愿意去阅读更多的内容，另外，如果这些信息载体要是再多一些互动就更容易吸引人了。</p>
<p>也就是说，人类在关注网页时，仍然是: 内容-&gt;样式，交互 的顺序，当然在网页越来越丰富多彩的今天，样式和交互也越来越被看重，甚至已经和内容一样重要的程度了。</p>
<p>而内容，对应着html；样式和交互，则由css和javascript共同决定</p>
<h2 id="html_u2014_u2014_u5E26_u8BED_u4E49_u7684_u6587_u6863_u6D41"><a href="#html_u2014_u2014_u5E26_u8BED_u4E49_u7684_u6587_u6863_u6D41" class="headerlink" title="html——带语义的文档流"></a>html——带语义的文档流</h2><h3 id="u7F51_u9875_u7684_u300C_u4E24_u79CD_u8BED_u4E49_u300D"><a href="#u7F51_u9875_u7684_u300C_u4E24_u79CD_u8BED_u4E49_u300D" class="headerlink" title="网页的「两种语义」"></a>网页的「两种语义」</h3><p>当然网页作为信息载体和日常生活中的实体还是有区别的。虽然网页上的信息最终受众是人类，但它要通过浏览器，搜索引擎，或是一些其他能够处理网页的程序来实现这一功能。这也就形成了网页的两种语义：</p>
<ul>
<li>第一种语义是最终展示出来的语义，由人类来理解，也就是平时理解的语义。</li>
<li>第二种语义是由浏览器，搜索引擎等机器程序可理解，属于「机器可读的语义」</li>
</ul>
<p>最终呈现出的语义，是由人类的知识结构来决定的，人类会将页面上不同的内容，理解成为「标题」，「内容」， 「脚注」， 「导航」等具有特定语义的元素。也正是因为这个原因，有些html元素，生来就带有一定的样式，比如h1~h6这些标题，字号会比较大，同时也会加粗。这是符合人类的常识的，也与最终要展示的语义贴合，因此这样的设定会非常方便。</p>
<p>而第二种语义，也就是机器可读的语义，从上面的意义上说，是为第一种语义服务的。浏览器，搜索引擎等程序会识别html代码中的语义元素，然后加上样式等最终展示出来。语义化越强的html，越方便于机器去理解。在软件领域，语义化往往是建立在合理的「结构化」之上的，所谓「结构化」指的就是不同语义部分的内容，采用不同的结构加以区分，而html中的结构化，其实就是使用各类html标签完成的。</p>
<p>让第一种语义更友好的展示，是网页的整体目标。这需要设计师，信息架构师，程序员的通力合作。</p>
<p>让第二种语义更好的服务于第一种语义，是程序员的本质工作。</p>
<h3 id="u4E3A_u4EC0_u4E48_u7B2C_u4E8C_u79CD_u8BED_u4E49_u662F_u91CD_u8981_u7684"><a href="#u4E3A_u4EC0_u4E48_u7B2C_u4E8C_u79CD_u8BED_u4E49_u662F_u91CD_u8981_u7684" class="headerlink" title="为什么第二种语义是重要的"></a>为什么第二种语义是重要的</h3><p>有一个非常合适的例子可以说明第二种语义的重要性。不知道你在使用智能手机的时候有没有遇到过这样的情况：</p>
<p>有时候需要在某个网站上输入东西时，会弹出输入法。但是不同的输入框，弹出的输入法的界面又有所不同，当你输入邮箱时，会弹出带@符号的键盘，当你需要输入密码时，弹出的是全键盘等等。而且更奇怪的时，这个功能有时候灵，有时候不灵。这个功能好用的时候，你会感觉输入内容时非常顺畅，不灵时，你就要手动切换输入法的不同的界面，找到你需要的符号。感觉就非常不爽。</p>
<p>这背后就是第二种语义在起作用：在html中，输入框有很多不同的类型，有的是email，有的是password，有的是text。如果一个网站很好的对这些语义做了区分，并且应用在了他们的html中。那么上述的输入法弹窗表现的就会很智能。因为机器可以根据html中不同的语义来选择弹出什么样的界面。如果是emai，就弹出带@符号的界面，如果是密码，就弹出全键盘等等。但是如果语义化做的不好的网站，就做不到这一点，只会统一弹出通用界面，需要人类去判断，切换。</p>
<p>这个例子是要说明，在浏览器等软件越来越智能化的今天，html的语义化也变得越来越重要。</p>
<p>上面也提到，浏览器一般会给一些特定的html元素以特定的样式，但是这只是因为这样做比较符合人类尝试，能够提供便利性。千万不要因为想要某个样式去使用元素，而是应该给要标记的内容选择最合适语义的元素。至于样式，则应该交由css去处理。『html只关注语义，不关注布局，也不关注样式或交互』，这样的总结，也是出于这个原因。</p>
<h3 id="u4EE5html_u7684_u8BED_u4E49_u6765_u7406_u89E3_u7F51_u9875"><a href="#u4EE5html_u7684_u8BED_u4E49_u6765_u7406_u89E3_u7F51_u9875" class="headerlink" title="以html的语义来理解网页"></a>以html的语义来理解网页</h3><p>上面说完语义的重要性，接着来看如何通过理解这些第二类语义元素来理解网页。这部分内容涉及的元素比较多，这里只是粗略说明一下。</p>
<p>首先网页有不少展示用的语义化元素用来展示信息。</p>
<p>像最基本的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">main</span>&gt;</span><span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--尾部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--章节--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">section</span>&gt;</span><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--独立片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">artical</span>&gt;</span><span class="tag">&lt;/<span class="title">artical</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以及更具体的:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">time</span>&gt;</span><span class="tag">&lt;/<span class="title">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">address</span>&gt;</span><span class="tag">&lt;/<span class="title">address</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这些都是普通的语义化的来展示信息的元素。但是像现实生活那样，信息展示还有其他的方式，有助于人类更好的阅读和理解。比如：</p>
<ul>
<li><p>列表</p>
<p>  它分条分类的列出比较核心的信息，可以让人更快的理解清楚一件事物的各方面重点。html中</p>
</li>
<li><p>嵌入式的元素</p>
<p>  如图片，所谓一图胜千言。<br>  再如音乐，视频等等</p>
</li>
</ul>
<p>另外，现实生活中，我们常会遇到通过分发纸质的表单，用来收集信息。还有报表，用来清楚的展示分门分类的比较格式化的信息。这在html中也有相应的语义元素，分别是：</p>
<ul>
<li>表单（form）</li>
<li>表格（table）</li>
</ul>
<p>他们的作用也和现实生活中的大同小异，而且html中的表单有多种多样的类型，单选框，复选框，输入框（输入框本身也有更细的语义化的类型）。这和现实中的多种多样的调查表单都是相似的。</p>
<p>另外，html中还多了一些独特的语义元素。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接,可能是最重要的独特元素，它把各个页面通过网络组合了起来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他一些元素，这些元素或描述了网页关系，或是描述网页信息等等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本的html元素，就是上述这些种类，可以看到，这些元素组合起来，即有收集信息的部分，又有展示信息的部分，而且为了更好的展示信息，html又提供了许多语义化的元素。</p>
<p>这些元素组合在一起，一起形成了网页的全部语义信息，几乎可以实现和模仿现实中的所有信息载体，某些方面犹有胜之。</p>
<h3 id="u6587_u6863_u6D41"><a href="#u6587_u6863_u6D41" class="headerlink" title="文档流"></a>文档流</h3><p>除了前面所说的一些元素会根据常识带有一些样式外（如果说这算排版样式的话），html还有一种简单的默认的布局方式（姑且这叫布局样式）：也就是从上到下，从左至右依次排列元素。用更形象的说法是，这叫html文档流。</p>
<p>这种默认的文档流，给html提供了符合常识的，也是最基础的布局，不至于说所有元素都乱糟糟的堆在一起。但还是强调那句话，虽然浏览器给html提供了一些默认的样式和布局，但这都是基于人类直觉和常识的：<strong>『html只关注语义，不关注布局，也不关注样式或交互』</strong></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>以上基本上就是html核心的全部了，用几个词来总结一下就是：语义，基于常识的元素默认样式，以及文档流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前也多多少少接触过一点前端，但每次都会触及一些细枝末节，像html的某个元素啦，或是某个css的具体意思了，再或者是写一点javascript啦之类的内容。但总是感觉对前端缺乏一种比较顶层的认识。</p>
<p>虽然偶尔也会听说一些关于网页三剑客的比喻。类似html是网页]]>
    </summary>
    
      <category term="前端" scheme="http://starding.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://starding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《三体》，《行尸走肉》与社会达尔文主义]]></title>
    <link href="http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/"/>
    <id>http://starding.github.io/2016/01/07/three-body-walking-dead-Darwin/</id>
    <published>2016-01-07T07:55:11.000Z</published>
    <updated>2016-01-12T03:20:34.000Z</updated>
    <content type="html"><![CDATA[<p>看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘的七七八八。刚开始看《行尸走肉》时，还以为是个单纯的丧尸剧，但随着剧情的不断深入，就发现它描述了更多的东西。在某些重要的方面，两者有些相像。不过是一个把达尔文主义推广到整个宇宙，建立了较为极端的达尔文性质的宇宙社会学，另一个则是让自人类开始出现以来，数百万年形成的世界秩序洗牌，重新审视人类这一物种，同样渗透着浓厚的达尔文思想。</p>
<h1 id="1_uFF1A_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u57FA_u672C_u8BBE_u5B9A"><a href="#1_uFF1A_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u57FA_u672C_u8BBE_u5B9A" class="headerlink" title="1：《三体》与《行尸走肉》的基本设定"></a>1：《三体》与《行尸走肉》的基本设定</h1><p>进化论的基础：特定环境中，资源是有限的，仅能支持一定数量的生命体，而生命的数量是不断增长的，为了争夺有限的生存资源必须进行生存斗争，获胜的将存活下来，而失败的遭到淘汰。</p>
<p>《三体》设定：大刘将上述思想扩展到整个宇宙，在宇宙层面设定了一种类似的社会学，即宇宙整体资源也是有限的，宇宙中生存着各种各样的文明，而且越是高层次的文明，所需求的资源越多，同时，各文明的最高标准是”生存是文明的第一需要“。大刘在这样一个宇宙中来演绎文明的生存策略。</p>
<p>《行尸走肉》设定：利用一场突如其来的病毒，打乱既有的世界秩序，将幸存的人类放入一个周围充满危险的，生存资源有限的行尸世界中，来展现末世人类的生存之道。</p>
<h1 id="2-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u4E2D_u7684_u7B56_u7565"><a href="#2-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u4E2D_u7684_u7B56_u7565" class="headerlink" title="2.《三体》与《行尸走肉》中的策略"></a>2.《三体》与《行尸走肉》中的策略</h1><p>《三体》：无论是三体人的智子干扰，或是歌者的二向箔抹杀，所采取的都是完全的黑暗森林式策略，没有合作，也没有博弈。毁灭你，与你何干，直截了当。这可以说是把生存竞争推到了极致。在豆瓣上，长期霸占《三体》区评论第一位的文章《信卢瑟，永世不得超生》<a href="/详情见:[信卢瑟，永世不得超生](http://book.douban.com/review/6146948/?start=800#comments),个人对这篇文章并不认同。我不认同的并不是其批评没有指中《三体》的要害。恰恰相反，此文对《三体》中的核心假定之一的批评相当到位：《三体》中的确采用了极致甚至很极端的生存竞争原则。个人不认同的是此文对科幻小说这一题材的误解：科幻小说一个常见手法是假定一个背景，然后以此展开，演绎出一个自洽的世界。大刘既然假定生存是文明的第一需要，那么以此写出的小说必定是这个样子。当然你可以假定生存不是文明的第一需要，来描述一个相对和谐的宇宙，但那将是另一个故事了。类似的例子有经典的以“如果冰的密度比水大”为主题的科幻小说，在这种反事实条件假定下，你不能指责科幻作家的假定存在问题，应该关注的是在这种假定下，作者所展现的世界是不是自洽，以及其展现达到了多深的层次。">^1</a> 所吐槽的卢瑟(loser)思维，正是这种被极致化的生存竞争思维。</p>
<p>《行尸走肉》：加入了更多的元素。主角末世前的职业为警察：原世界秩序，规则的最好代表。包括人性与道德的考察：警察，士兵，医生，教师，牧师，平民，孩子等作为不同类型人群的代表，有着不同的人物展现。家庭式的，社区式的，陷阱式的等各种生存策略都一一考察。</p>
<h1 id="3-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u79E9_u5E8F"><a href="#3-_u300A_u4E09_u4F53_u300B_u4E0E_u300A_u884C_u5C38_u8D70_u8089_u300B_u7684_u79E9_u5E8F" class="headerlink" title="3.《三体》与《行尸走肉》的秩序"></a>3.《三体》与《行尸走肉》的秩序</h1><p>如今，除了一些原教旨主义者，很少有人会认为像《圣经》这样的文献是在直接描述自然真理了，最多是对自然做出一些隐喻。但认为其描述了道德与人性真理的说法仍然很有影响，尽管这一说法被达尔文进化论挑战。而中国虽然是礼仪之邦，不同时期有对道德的不同定义，但对定义本身缺乏深究，没有道德做哲学上寻根究底的传统。道德的本质是什么，世界秩序的本质又是什么，一直以来就是非常艰深的问题。</p>
<p>个人认为（应该不是我脑补过度）《三体》以文革为背景开始整个叙事，所要突出的正是文革时期那种满含猜疑的紧张气氛，以及当时道德秩序的混乱：仅需一场政治运动，便足以煽动无数人将数千年文明所谓道德人性推入深渊。文革中的一大主题就是如何生存下去，而且这仅仅是人类自身内部。将这些脆弱的存在推广到整个宇宙中的不同文明之间，并加以放大，黑暗森林并非不可想象。丧失理性会颠覆道德与人性，完全的理性同样也会。大刘展现了这样一种可能的残酷，道德什么的太靠不住，靠的住的是严格游戏规则，执剑者逻辑明白规则，程心（个人认为圣母程心就是道德与人性的代言人）不明白或者说不愿明白。失去人性失去很多，失去兽性，失去一切，大刘采用了不同的方式强调了这一点<a href="/刘慈欣在新书《刘慈欣谈科幻》中透漏，他是一个科学主义者和技术崇拜者。其所架构的世界很多时候钢铁般坚硬和冷酷，缺少人性的关怀。个人认为这是一种缺点，但也是一种优点。">^2</a>。</p>
<p>《行尸走肉》将故事放在地球范围内，明显更为详细的对不同类型的人群进行了各式各样的考察。按剧情的发展来看，人类与行尸之间的冲突虽然一直是重要背景，但这一背景逐渐被弱化，人类与人类的冲突则逐渐被突出出来。数万年前人类逐渐开始产生社会形态，并利用语言，技术等进行自我规训，最终基本完成自我驯化，形成了一个压抑自己的意义世界<a href="/此处参考吴国盛《技术哲学讲演录》，文中对技术哲学做了讲演式的概括介绍，人类的自我规训是其中一个重要内容。">^3</a>，个人认为这可以称作是道德和世界秩序的技术成因。但这种秩序是人类的特定阶段以及相应的特定的环境结合产生的，而末世结束了旧时秩序，同时结束的还有相应的社会和自然条件。在新的环境下，已经高度进化了的现代人，又该如何生存，能否重建一种不同的世界秩序，道德的标准又会发生什么变化？瑞克一行人在经历了众多情况之后，逐渐摆脱了原世界秩序的影响，在以警察为首的这一行人身上，还能看到生存之外的东西以及他们心理的摇摆不定，但是生存竞争已经在他们小组的意识中渗透的越来越深了，不知道采取何种策略才能更好的生存下去，但肯定不同于三体中的黑暗森林。</p>
<h1 id="4-_u8FBE_u5C14_u6587_u601D_u60F3_u4E0E_u793E_u4F1A_u5B66"><a href="#4-_u8FBE_u5C14_u6587_u601D_u60F3_u4E0E_u793E_u4F1A_u5B66" class="headerlink" title="4.达尔文思想与社会学"></a>4.达尔文思想与社会学</h1><p>达尔文的生存竞争思想在社会学中是很有地位的，并且以此发展出一种社会达尔文主义，而且达尔文思想在社会学中的应用会产生出一些逻辑清晰的，特别诱人的类似于科学中的那种分析方式（像《三体》这样就属一种）。但是达尔文自身过于强调了生存竞争的作用，忽视了生存竞争之外的现象，在社会中应用时也难以处理复杂的社会现象。另外，达尔文思想只是“演化”，而不是“进化”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看大刘的《三体》，已经是几年前的事情了。除了宏观的叙事和一些经典场景，已忘的七七八八。刚开始看《行尸走肉》时，还以为是个单纯的丧尸剧，但随着剧情的不断深入，就发现它描述了更多的东西。在某些重要的方面，两者有些相像。不过是一个把达尔文主义推广到整个宇宙，建立了较为极端的达尔文]]>
    </summary>
    
      <category term="三体" scheme="http://starding.github.io/tags/%E4%B8%89%E4%BD%93/"/>
    
      <category term="社会达尔文主义" scheme="http://starding.github.io/tags/%E7%A4%BE%E4%BC%9A%E8%BE%BE%E5%B0%94%E6%96%87%E4%B8%BB%E4%B9%89/"/>
    
      <category term="行尸走肉" scheme="http://starding.github.io/tags/%E8%A1%8C%E5%B0%B8%E8%B5%B0%E8%82%89/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[科学史上的东方与西方]]></title>
    <link href="http://starding.github.io/2016/01/07/science-in-east-and-west/"/>
    <id>http://starding.github.io/2016/01/07/science-in-east-and-west/</id>
    <published>2016-01-07T07:48:31.000Z</published>
    <updated>2016-01-07T07:52:54.000Z</updated>
    <content type="html"><![CDATA[<p>此文是我在知乎的<a href="http://www.zhihu.com/question/21867922/answer/35898434" target="_blank" rel="external">第一个科学史答案</a></p>
<h1 id="u4E00_uFF1A_u79D1_u5B66_u53F2_u4E0A_u7684_u300E_u79D1_u5B66_u300F"><a href="#u4E00_uFF1A_u79D1_u5B66_u53F2_u4E0A_u7684_u300E_u79D1_u5B66_u300F" class="headerlink" title="一：科学史上的『科学』"></a>一：科学史上的『科学』</h1><p>科学史中所研究的科学范围，是超出我们日常生活中所提到的科学的，在科学史研究中，研究的是更广义意义上的科学，一般包括以下几种：</p>
<ol>
<li>古希腊的理性科学</li>
<li>近代科学革命产生的数理-实验科学</li>
<li>更为广泛意义上的博物学</li>
<li>更广泛的包括技术系统的科学</li>
</ol>
<p>题主所说的“西方科学史”的主线是：<br>古希腊——罗马——中世纪——文艺复兴——科学革命——现在。</p>
<p>以下叙述中的“科学”也是广义化的，但西方科学发展中的主线与支线，大家一看便知，一个非常重要的线索就是文明的类型与科学的类型这对关系。</p>
<h1 id="u4E8C_3A_u79D1_u5B66_u53F2_u4E0A_u7684_u4E1C_u65B9_u4E0E_u897F_u65B9"><a href="#u4E8C_3A_u79D1_u5B66_u53F2_u4E0A_u7684_u4E1C_u65B9_u4E0E_u897F_u65B9" class="headerlink" title="二:科学史上的东方与西方"></a>二:科学史上的东方与西方</h1><p>追溯到科学发展的源头去看，科学史上有两种比较典型的科学类型：东方的「实用型科学」与古希腊的「理性型科学」，而承载这两种科学类型的文明类型，也有两种类型：水利型文明和非水利型文明。</p>
<h2 id="u6C34_u5229_u578B_u6587_u660E_u4E0E_u5B9E_u7528_u578B_u79D1_u5B66_3A"><a href="#u6C34_u5229_u578B_u6587_u660E_u4E0E_u5B9E_u7528_u578B_u79D1_u5B66_3A" class="headerlink" title="水利型文明与实用型科学:"></a>水利型文明与实用型科学:</h2><p>代表是四大古文明，即两河流域的美索不达米亚文明，尼罗河流域的埃及文明，印度河恒河流域的印度文明，以及长江，黄河流域的中国文明。这几个文明都是近水而生，人们聚集在发达的水系旁边进行农业生产，当农业与人口都开始繁荣后，多余粮食的分配，水资源的分配，水利工程的建造和维护，排水，泄洪等都需要有组织的协作，而用水过程中出现的争执也需要权威来调节，这就应运而生了比较核心的管理组织，也就是集权政治的原型。在这种文明环境中，国家的正常运行，人民的生活是管理阶层首先要考虑的事，相应的，被管理阶层所把持的科学也偏向于实用，多集中于水利（农业灌溉必不可少），天文（农业生产，平时生活，预测王朝命运等都需要天文），医学。</p>
<h2 id="u975E_u6C34_u5229_u6587_u660E_u4E0E_u5E0C_u814A_u7406_u6027_u79D1_u5B66_uFF1A"><a href="#u975E_u6C34_u5229_u6587_u660E_u4E0E_u5E0C_u814A_u7406_u6027_u79D1_u5B66_uFF1A" class="headerlink" title="非水利文明与希腊理性科学："></a>非水利文明与希腊理性科学：</h2><p>希腊在地理位置上处于地中海沿岸，境内多山，没有大河，也没有大面积富饶的冲积平原，农业灌溉更加依靠雨水而不是与江河有关的水利，希腊人民靠本土条件难以为继，逐渐发展出了比较好的航海和商业。同时，希腊距离美索不达米亚和埃及这些文明不近也不远，便于交流而且不会被完全同化。另一方面，山脉把希腊的政治文明分割成多个小邦国，各个邦国之间形成合作竞争的关系。在此环境下，希腊人发展出了民主城邦制和奴隶制度，保证了闲暇阶层的出现，自由民主的环境也使得政治辩论成为常态，这都培养了希腊人的理性精神。希腊的闲暇阶层不同于东方的管理者，需要极力去维护一个集权大国的正常运行，而是更加注重于对政治合法性等这些内容进行思考。这些条件使得希腊成为科学史上的一朵奇葩，希腊人善于辩论，对事物有着一种寻根究底的热情，超越世俗的学术精神，比如希腊的天文学不同于东方的实用性天文学，它是一种数理行星天文学，是为了解释自然，而不是为了农业，占星等实用目的。用自然自身解释自然，不再求助于神等外物，从泰勒斯的“水是万物之源”，到柏拉图的“理念论”，再到亚里士多德的综合自然哲学，清晰的体现出理性科学出现的过程，这也是现代科学最古老的源头。</p>
<h1 id="u4E09_uFF1A_u4E24_u79CD_u79D1_u5B66_u7C7B_u578B_u7684_u53D1_u5C55"><a href="#u4E09_uFF1A_u4E24_u79CD_u79D1_u5B66_u7C7B_u578B_u7684_u53D1_u5C55" class="headerlink" title="三：两种科学类型的发展"></a>三：两种科学类型的发展</h1><h2 id="u5E0C_u814A_u7406_u6027_u79D1_u5B66_u7684_u7EE7_u627F_u53CA_u53D1_u5C55_uFF1A"><a href="#u5E0C_u814A_u7406_u6027_u79D1_u5B66_u7684_u7EE7_u627F_u53CA_u53D1_u5C55_uFF1A" class="headerlink" title="希腊理性科学的继承及发展："></a>希腊理性科学的继承及发展：</h2><p>希腊发展出了非功利的，比较系统的，有内在发展逻辑的理性科学传统，比如托勒密的《天文学大成》，欧几里得的《几何原本》，更为重要的是柏拉图和亚里士多德开创的理性的范式：柏拉图的理念论和亚氏自然哲学，他们虽然不同，但都是有内在逻辑的理性系统。希腊-罗马文明灭亡之后，这种理性融入到了基督教的教义之中，形成了前期的教父哲学和后期的经院哲学。希腊的文化同时被移植到伊斯兰世界中去，十字军东征之后，便开始在欧洲复兴，经历了航海时代，宗教改革，文艺复兴之后，希腊的这种理性科学的主线便在哥白尼身上连接了起来。紧接着就是近代的科学革命了。要注意的是，这个时候是十六十七世纪，资本主义对科学的发展有作用，但是还远没有到工业革命时的那么大的影响，在这中间主要的动力作用还理性科学内在的发展逻辑，宗教精神在其中也有不小的推动作用（宗教在近代科学产生过程中的作用，也是非常重要的，但讨论又需要大量篇幅了，答主题目中所说的“宗教的严格拘束”不太公平）。</p>
<h2 id="u4E1C_u65B9_u6C34_u5229_u6587_u660E_u5B9E_u7528_u578B_u79D1_u5B66_u7684_u53D1_u5C55_uFF1A"><a href="#u4E1C_u65B9_u6C34_u5229_u6587_u660E_u5B9E_u7528_u578B_u79D1_u5B66_u7684_u53D1_u5C55_uFF1A" class="headerlink" title="东方水利文明实用型科学的发展："></a>东方水利文明实用型科学的发展：</h2><p>实用型科学并没有它内在的发展逻辑，它的发展是根据外部环境的需要，一旦外部环境没有了需求时，它也就失去了发展的动力。这在中国历史上表现的非常明显，中国是非常典型的水利文明，集权的政治，官方掌控的科学都是其特点，这种由外部需求推动的科学与外部需要结合的非常紧密，长期来看就表现出科学技术发展的离散性，形不成系统。而且中国这种高度集权的国家，一旦形成了相应的治国文化后，这种文化对超越而无用的学术具有很强的限制作用（宗教还是文化，这是个问题）。中国在两千年的历史中，科学技术（取技术系统与博物学）其实一直都是非常强的，到了明代，达到了最高点。到了这个时候，外部的需求基本被满足，除非产生社会结构的变革（像资本主义与城市那样），或者是科学本身产生像希腊理性科学那样的结构，科学技术的发展就很难前进了。但是二者都是困难的，前者是封建势力不断扼杀资本主义的萌芽，后者是中国的政治文化已经固定，形成很强的束缚了。这个时候，也刚好是西方开始抓住希腊理性之线开始复兴的时候，从此中国在技术上也开始落后了。</p>
<h1 id="u56DB_uFF1A_u603B_u7ED3"><a href="#u56DB_uFF1A_u603B_u7ED3" class="headerlink" title="四：总结"></a>四：总结</h1><p>总之，以一种辉格史的角度来看的话，宏观上西方科学发展的逻辑还是比较清晰的，主线的就是希腊这根理性之线，旁支就是伊斯兰地区在中世纪时期对希腊学术的移植以及再移植，然而伊斯兰世界始终也是典型的东方文明，即使移植了希腊学术，对近代科学产生有着极其重要的影响，但最终也没能成功成为近代科学的策源地。</p>
<p>亚里士多德认为自由的学术有三个条件：</p>
<ol>
<li>闲暇的阶层</li>
<li>批判传统</li>
<li>对世界的惊异</li>
</ol>
<p>结合科学史可以看到，无论是古希腊，还是近代欧洲，都比较符合这些条件，而集权的国家则难以满足。注意这里没有强调“民主”，只是强调学术发展应有一个相对自由的环境，集权国家在脱去蒙昧之后，也是能创造出相似的条件的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>此文是我在知乎的<a href="http://www.zhihu.com/question/21867922/answer/35898434" target="_blank" rel="external">第一个科学史答案</a></p>
<h1 id="u4E00_uF]]>
    </summary>
    
      <category term="科学史" scheme="http://starding.github.io/tags/%E7%A7%91%E5%AD%A6%E5%8F%B2/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django中使用原生sql]]></title>
    <link href="http://starding.github.io/2016/01/07/raw-sql-in-django/"/>
    <id>http://starding.github.io/2016/01/07/raw-sql-in-django/</id>
    <published>2016-01-07T07:29:46.000Z</published>
    <updated>2016-01-08T11:33:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，django的orm只是sql的一个子集。也就是说很多使用sql能实现的功能，django orm是无法完成的，更不用说sql甚至是图灵完备的了。比如，直到1.8中，django才逐渐实现了case，when，if这些控制流。而这些内容在一些特殊类型的表操作中非常常见，比如说报表管理。</p>
<p>好在django提供了使用原生sql的接口，这样就能通过原生sql来实现一些复杂的功能。</p>
<h2 id="sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50"><a href="#sql_u63A7_u5236_u6D41_u4E4BCASE_WHEN_u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="sql控制流之CASE WHEN一个例子"></a>sql控制流之CASE WHEN一个例子</h2><p>现有一张档案信息表archives：</p>
<p><img src="http://7xpxcb.com1.z0.glb.clouddn.com/starding48482-ddc55e26121f44aa.png" alt="mysql-demo"></p>
<p>字段说明：</p>
<ul>
<li>number 档案号</li>
<li>type 档案类型</li>
<li>status 档案状态</li>
<li>company 公司</li>
<li>branch_company 分公司</li>
</ul>
<p><strong>需求是计算出表中同一type，同一分公司下的档案总数，和status=01的档案数，以及它占档案总数的比值。</strong></p>
<p>当然，使用编程语言也可以实现这个功能，但是会比较复杂。这个时候可以使用case when语句来精确控制表中同一字段下，不同内容的选择。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> </span><br><span class="line">      <span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>) status_01,</span><br><span class="line">      <span class="keyword">COUNT</span>(*) total,</span><br><span class="line">      <span class="keyword">CONCAT</span>(<span class="keyword">FORMAT</span>(<span class="keyword">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">status</span>=<span class="string">'01'</span> <span class="keyword">THEN</span> <span class="keyword">status</span> <span class="keyword">END</span>)/</span><br><span class="line">      <span class="keyword">COUNT</span>(*)*<span class="number">100</span>, <span class="number">2</span>), <span class="string">'%'</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      archives</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      <span class="keyword">status</span>, subbranch_company</span></span><br></pre></td></tr></table></figure>
<p>这样就可以解决上面提出的问题，因为这个表是临时杜撰的，结果这里就不贴了。</p>
<h2 id="u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2"><a href="#u5728_u4E0A_u8FF0_u57FA_u7840_u4E0A_u5B9E_u73B0_u94FE_u5F0F_u67E5_u8BE2" class="headerlink" title="在上述基础上实现链式查询"></a>在上述基础上实现链式查询</h2><p>在django的orm中，一个非常好用的功能就是使用链式查询，你可以不断连接filter等方法来过滤出想要的内容。</p>
<p>这在一些特定的场景中特别有用。比如在上面的表中，我有时候想要某个分公司或中支公司下的数据，有时候又想要单一类型下的数据。如果针对每一种条件组合分别写相应地sql查询的话，会非常复杂，而且有时候组合会特别多。而链式查询比较完美的解决了这个问题。<br>而为了让原生sql也能有个简单的链式查询，我们需要不断连接where中的条件子句。为此可以写一个简单的类来实现它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenQuerySQL</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, table)</span>:</span></span><br><span class="line">        self.table = table</span><br><span class="line">        self.group_by_fields = <span class="string">" "</span></span><br><span class="line">        self.where_conditions = <span class="string">" 1=1 "</span></span><br><span class="line">        self.fields = <span class="string">" "</span></span><br><span class="line">        self.order_by_fields = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">where</span><span class="params">(self, where_condition)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> where_condition:</span><br><span class="line">            self.where_conditions += <span class="string">" and "</span> + where_condition</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_field</span><span class="params">(self, fields)</span>:</span></span><br><span class="line">        self.fields += <span class="string">" "</span> + fields</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_by</span><span class="params">(self, group_by_field)</span>:</span></span><br><span class="line">        self.group_by_fields = group_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order_by</span><span class="params">(self, order_by_field)</span>:</span></span><br><span class="line">        self.order_by_fields = order_by_field</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sql</span><span class="params">(self)</span>:</span></span><br><span class="line">       SQL = <span class="string">'SELECT '</span> + self.fields + <span class="string">' FROM '</span> + self.table + <span class="string">' WHERE '</span> + self.where_conditions + <span class="string">' GROUP BY '</span> + self.group_by_fields + <span class="string">' ORDER BY '</span> + self.order_by_fields +  <span class="string">";"</span></span><br><span class="line">       <span class="keyword">return</span> SQL</span><br></pre></td></tr></table></figure>
<p>这个类可以简单的模拟链式查询的功能，可以这样使用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archive_statistics = GenQuerySQL(SOME_TABLE)</span><br><span class="line">raw_sql = archive_statistics.add_field(fields).where(where_condition).group_by(group_by_fields).order_by(order_by_fields).sql()</span><br></pre></td></tr></table></figure>
<p>其中.where可以多次连接。当然也可以使用另一种方式：先把where语句根据条件构造完毕，最终再拼接成sql语句。其思想是一样的：先过滤条件，最终再查询数据库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="orm_u5E76_u975E_u4E07_u80FD"><a href="#orm_u5E76_u975E_u4E07_u80FD" class="headerlink" title="orm并非万能"></a>orm并非万能</h2><p>从功能集上讲，dja]]>
    </summary>
    
      <category term="django" scheme="http://starding.github.io/tags/django/"/>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 部署gitlab]]></title>
    <link href="http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/"/>
    <id>http://starding.github.io/2016/01/07/deploy-gitlab-by-docker/</id>
    <published>2016-01-07T07:27:22.000Z</published>
    <updated>2016-01-07T07:28:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="headerlink" title="拉取镜像及启动容器"></a>拉取镜像及启动容器</h1><p>参考：<a href="http://doc.gitlab.com/omnibus/docker/" target="_blank" rel="external">gitlab documentation</a></p>
<h2 id="u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A"><a href="#u9996_u5148_u4F7F_u7528dao_u52A0_u901F_u5668_u62C9_u53D6daocker_u955C_u50CF_uFF1A" class="headerlink" title="首先使用dao加速器拉取daocker镜像："></a>首先使用dao加速器拉取daocker镜像：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<h1 id="u521B_u5EFAvolumes"><a href="#u521B_u5EFAvolumes" class="headerlink" title="创建volumes"></a>创建volumes</h1><p>简单来说volumes，就是可以映射到容器中去的容器外部存储空间。你可以将一些比价通用的配置文件，数据，或者是代码等都使用volumes的形式存储在容器所在的宿主机器上。这样不仅可以永久保留数据，保证数据的安全性。同时还可以方便的修改volumes中的内容，然后重新映射到容器中，这对于需要经常动态修改文件的容器非常有用。<br>在本次部署gitlab的时候，创建三个volumes，分别是/mnt/volumes/gitlab下的 config，logs，data目录。<br>启动一个gitlab容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \&#10;    --hostname git.xiaohuruwei.com \&#10;    --publish 8443:443 --publish 8080:80 --publish 2222:22 \&#10;    --name gitlab \&#10;    --restart always \&#10;    --volume /mnt/volumes/gitlab/config:/etc/gitlab \&#10;    --volume /mnt/volumes/gitlab/logs:/var/log/gitlab \&#10;    --volume /mnt/volumes/gitlab/data:/var/opt/gitlab \&#10;    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<p>命令参数解释：</p>
<p>–hostname<br>指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定git.xiaohuruwei.com</p>
<p>–publish<br>端口映射，冒号前面是宿主机端口，后面是容器expose出的端口</p>
<p>–volume<br>volume 映射，冒号前面是宿主机的一个文件路径，后面是容器中的文件路径</p>
<h1 id="u914D_u7F6Enginx_uFF0C_u652F_u6301https"><a href="#u914D_u7F6Enginx_uFF0C_u652F_u6301https" class="headerlink" title="配置nginx，支持https"></a>配置nginx，支持https</h1><p>参考：<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https" target="_blank" rel="external">gitlab set nginx</a><br>nginx 配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">rewrite</span><span class="regexp"> ^</span> <span class="url">https://git.xiaohuruwei.com</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="https_proxy"><a href="#https_proxy" class="headerlink" title="https proxy"></a>https proxy</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="title">server_name</span>  git.xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/https-gitlab.xiaohuruwei.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="comment"># ssl 证书配置，这里使用的是自己生成的证书，在访问时会提示证书问题，选择相信即可。</span></span><br><span class="line">    <span class="comment"># 如果想要公认的证书，需要在网络上的一些授权中心生成</span></span><br><span class="line">    <span class="title">ssl</span> <span class="built_in">on</span>;</span><br><span class="line">    <span class="title">ssl_certificate</span> /etc/nginx/ssl/getbase.crt;</span><br><span class="line">    <span class="title">ssl_certificate_key</span> /etc/nginx/ssl/getbase_nopass.key;</span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">https://localhost:8443</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u5F00_u653Egitlab_u7684https_u652F_u6301"><a href="#u5F00_u653Egitlab_u7684https_u652F_u6301" class="headerlink" title="开放gitlab的https支持"></a>开放gitlab的https支持</h1><p>仅仅由nginx反向代理https是不行的，因为还需要打开gitlab的https支持。</p>
<ul>
<li>修改配置文件，在/mnt/volumes/gitlab/config/ 目录下的gitlab.rb中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># note the &#39;https&#39; below&#10;external_url &#34;https://gitlab.example.com&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新建ssl目录，同时在该目录下添加ssl证书文件，命名要与上述域名中保持一致</p>
<p>git.xiaohuruwei.com.crt<br>git.xiaohuruwei.com.key</p>
</li>
<li><p>重新启动容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="u8BBF_u95EEgitlab_u6D4B_u8BD5"><a href="#u8BBF_u95EEgitlab_u6D4B_u8BD5" class="headerlink" title="访问gitlab测试"></a>访问gitlab测试</h1><ul>
<li>打开web界面，默认登录名为root，密码为5iveL!fe（已经改为厘米脚印的默认密码），新建一个project仓库:test</li>
<li><p>因为ssl证书是自己生成的，并不具有全网通用性，因此只能先选择相信证书。在本地设置环境变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GIT_SSL_NO_VERIFY=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后克隆仓库： git clone <a href="https://git.xiaohuruwei.com/root/test.git" target="_blank" rel="external">https://git.xiaohuruwei.com/root/test.git</a></p>
</li>
</ul>
<h1 id="u5F00_u542F_u90AE_u4EF6_u670D_u52A1"><a href="#u5F00_u542F_u90AE_u4EF6_u670D_u52A1" class="headerlink" title="开启邮件服务"></a>开启邮件服务</h1><p>默认的邮件服务不太好使，所以这里配置自己的邮件服务。参考官方<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md#examples" target="_blank" rel="external">gitlab stmp文档</a>。</p>
<p>使用163邮箱, 按照官方文档配置后，会发现发送邮件没有起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;smtp_enable&#39;] = true&#10;gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.163.com&#34;&#10;gitlab_rails[&#39;smtp_port&#39;] = 25&#10;gitlab_rails[&#39;smtp_user_name&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;gitlab_rails[&#39;smtp_password&#39;] = &#34;xxxx&#34;&#10;gitlab_rails[&#39;smtp_domain&#39;] = &#34;163.com&#34;&#10;gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;&#10;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true&#10;gitlab_rails[&#39;smtp_tls&#39;] = false&#10;gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;none&#39;</span><br></pre></td></tr></table></figure></p>
<p>查看log时，由于log比较杂乱，没有发现问题，后来在ruby社区发现有人解决过同样的问题：<br><a href="https://ruby-china.org/topics/20450" target="_blank" rel="external">GitLab 配置通过 smtp.163.com 发送邮件</a><br>以及网易的官方解释：<br><a href="http://www.mail163.cn/fault/analysis/1109.html" target="_blank" rel="external">网易服务器smtp机器要求身份验证帐号和发信帐号必须一致，如果用户在发送邮件时，身份验证帐号和发件人帐号是不同的，因此拒绝发送。</a><br>所以又添加了两行配置后测试可以正常使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;xiaohuruwei@163.com&#34;&#10;user[&#39;git_user_email&#39;] = &#34;xiaohuruwei@163.com&#34;</span><br></pre></td></tr></table></figure></p>
<h1 id="ssh_u65B9_u5F0F_u8BBF_u95EE"><a href="#ssh_u65B9_u5F0F_u8BBF_u95EE" class="headerlink" title="ssh方式访问"></a>ssh方式访问</h1><p>因为是使用docker部署的，通过ssh方式(比如git clone <a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>)访问会有两层认证:</p>
<ul>
<li>一层是freelancer服务器的认证</li>
<li>另一层是gitlab的认证。</li>
</ul>
<p>后者需要使用ssh-key<br>前者可能需要ssh本身的反向代理(现在使用的nginx不支持除http，https以外的反向代理)，</p>
<p>现在发现使用端口转发的形式比较困难，但是可以改变默认的gitlab的ssh端口为非标准端口：<br>直接修改gitlab配置文件中的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_shell_ssh_port = 2222</span><br></pre></td></tr></table></figure></p>
<p> 然后重新启动docker容器，就可以在web界面中看到相应的ssh地址发生了改变:<br>ssh://<a href="mailto:git@git.xiaohuruwei.com" target="_blank" rel="external">git@git.xiaohuruwei.com</a>:2222/root/test.git  然后就直接可以继续使用git clone来继续操作了</p>
<h1 id="u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A"><a href="#u5173_u4E8Essl_u8BC1_u4E66_u53C2_u8003_uFF1A" class="headerlink" title="关于ssl证书参考："></a>关于ssl证书参考：</h1><p><a href="http://www.guokr.com/post/116169/" target="_blank" rel="external">https那些事，ssl证书</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668"><a href="#u62C9_u53D6_u955C_u50CF_u53CA_u542F_u52A8_u5BB9_u5668" class="heade]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用daocloud持续集成应用]]></title>
    <link href="http://starding.github.io/2016/01/07/daocloud-deploy/"/>
    <id>http://starding.github.io/2016/01/07/daocloud-deploy/</id>
    <published>2016-01-07T07:24:25.000Z</published>
    <updated>2016-01-15T07:30:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762_u7684_u8BDD"><a href="#u5199_u5728_u524D_u9762_u7684_u8BDD" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>来自维基百科的：<a href="https://zh.wikipedia.org/wiki/货物崇拜编程" target="_blank" rel="external">货殖崇拜编程</a></p>
<p>为因GFW屏蔽访问不了维基百科的同学准备的：</p>
<blockquote>
<p>货物崇拜编程（Cargo Cult Programming）是一种计算机程序设计中的反模式，其特征为不明就里地、仪式性地使用代码或程序架构。货物崇拜编程通常是程序员既没理解他要解决的bug、也没理解表面上的解决方案的典型表现。</p>
<p>这个名词有时也指不熟练的或没经验的程序员从某处拷贝代码到另一处，却不太清楚其代码是如何工作的，或者不清楚在新的地方是否需要这段代码。也可以指不正确或过份的应用设计模式、代码风格或编程方法，却对其原理不明就里。</p>
<p>货物崇拜编程来源于“货物崇拜”这个词。其衍生词还有“货物崇拜软件工程”。</p>
</blockquote>
<p>在阅读任何教程类的文章时，都不要有编程上的货殖崇拜，有些内容是需要你根据自己的实际情况修改一些内容的,需要你理解它，如果不理解某些内容，就需要先熟悉一下相关的知识。</p>
<h1 id="daocloud_u4ECB_u7ECD"><a href="#daocloud_u4ECB_u7ECD" class="headerlink" title="daocloud介绍"></a>daocloud介绍</h1><p>  <a href="https://daocloud.io" target="_blank" rel="external">daocloud</a>提供基于docker进行持续集成的服务，使用它可以很方便的完成项目的自动化构建以及持续发布等功能。</p>
<p>当然，如果要使用daocloud持续化集成应用，首先你需要注册一个daocloud账号。如果你效力于某个公司的话，还要通知该公司把你的账号拉到公司用户组里，这样才能使用该公司的资源。</p>
<h1 id="u6301_u7EED_u96C6_u6210_u7B80_u5355_u7684html5_u5E94_u7528"><a href="#u6301_u7EED_u96C6_u6210_u7B80_u5355_u7684html5_u5E94_u7528" class="headerlink" title="持续集成简单的html5应用"></a>持续集成简单的html5应用</h1><h2 id="u672C_u5C0F_u8282_u4F7F_u7528_u573A_u666F"><a href="#u672C_u5C0F_u8282_u4F7F_u7528_u573A_u666F" class="headerlink" title="本小节使用场景"></a>本小节使用场景</h2><ul>
<li>拥有自己的主机</li>
<li>将主机添加到了daocloud上</li>
<li>只使用daocloud的自动构建和部署功能</li>
<li>镜像也要部署到自己的主机上。</li>
</ul>
<h2 id="u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D"><a href="#u4EC0_u4E48_u662F_u300C_u7B80_u5355_u7684html5_u5E94_u7528_u300D" class="headerlink" title="什么是「简单的html5应用」"></a>什么是「简单的html5应用」</h2><p>只有前端页面，并且使用nginx提供服务。</p>
<h2 id="u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848"><a href="#u90E8_u7F72_u5927_u81F4_u89E3_u51B3_u65B9_u6848" class="headerlink" title="部署大致解决方案"></a>部署大致解决方案</h2><p>本文假设一个使用场景：拥有自己的主机，并且绑定到了daocloud上，然后想通过daocloud进行持续化地部署到自己的主机上。如果想要部署一个纯前端项目，需要把nginx集成进去，然后使用nginx来提供服务。</p>
<h2 id="u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907"><a href="#u6784_u5EFA_u5E94_u7528_u524D_u7684_u51C6_u5907" class="headerlink" title="构建应用前的准备"></a>构建应用前的准备</h2><h3 id="u5E94_u7528_u76EE_u5F55_u7ED3_u6784"><a href="#u5E94_u7528_u76EE_u5F55_u7ED3_u6784" class="headerlink" title="应用目录结构"></a>应用目录结构</h3><p>因为daocloud是基于daocker的，在使用daocloud之前，我们需要按照docker的规范，把自己的项目改成支持打包成镜像的应用，对于html5项目来说，就是添加Dockerfile文件和配置好所需要的nginx配置文件。比如我有一个应用叫jinli，其目录结构为(你的目录结构和这个可能也不一样)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinli/  # &#39033;&#30446;&#26681;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; jinli/  # &#20855;&#20307;&#30340;&#24212;&#29992;&#30446;&#24405;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; images/ # &#22270;&#29255;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.html  # &#40664;&#35748;&#30340;&#26816;&#32034;html&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; scripts/  #  js&#25991;&#20214;&#22841;&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; styles/    # &#23384;&#25918;css&#30340;&#25991;&#20214;&#22841;&#10;&#9500;&#9472;&#9472; Dockerfile   # Dockerfile&#10;&#9500;&#9472;&#9472; jinli.conf   # &#26412;&#24212;&#29992;&#30340;nginx&#37197;&#32622;&#25991;&#20214;&#10;&#9492;&#9472;&#9472; log/  # log&#25991;&#20214;</span><br></pre></td></tr></table></figure>
<p>在这个目录结构中，和docker镜像构建是就是Dockerfile这个文件，jinli.conf是个将要一起打包放入docker镜像中的文件，其他的都是应用本身的文件。</p>
<h3 id="u521B_u5EFADockerfile_u6587_u4EF6"><a href="#u521B_u5EFADockerfile_u6587_u4EF6" class="headerlink" title="创建Dockerfile文件"></a>创建Dockerfile文件</h3><p><strong>Dockerfile</strong>，就是一个daocker的规则文件，就像make的Makefile一样。Dockerfile描述了将自己的应用构建成docker镜像的过程。<br>在本例中，Dockerfile的内容如下：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择nginx服务</span></span><br><span class="line"><span class="built_in">FROM</span> nginx:<span class="number">1.9</span>.<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy代码</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">. /src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 添加nginx配置文件</span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">jinli.conf /etc/nginx/conf.d/</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 去掉默认的nginx配置文件</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">rm /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile解释：</p>
<ul>
<li>首先，想象将要构建的docker镜像包含一个linux操作系统。</li>
<li><code>FROM nginx:1.9.5</code> 的意思就是，将1.9.5版本的nginx服务集成到自己的镜像中（其实操作系统就是在这一步引入的，nginx本身也是一个镜像，它是建立在一个linux操作系统之上的，拉取nginx的时候，会连把nginx连带其附着的linx系统整个一起拉下来）。</li>
<li><code>COPY . /src</code> 的意思是将当前目录下的代码复制到镜像中（的操作系统中）的 /src目录下</li>
<li><code>COPY jinli.conf /etc/nginx/conf.d/</code> 的意思是，将当前目录下写好的nginx配置文件，复制到镜像（的操作系统）中的相应目录下。</li>
<li>删掉原来默认的nginx配置（因为默认配置文件会占用掉localhost，不知道有没有更好的解决办法）</li>
</ul>
<h3 id="u914D_u7F6E_u5728docker_u4E2D_u4F7F_u7528_u7684nginx_u914D_u7F6E_u6587_u4EF6_u3002"><a href="#u914D_u7F6E_u5728docker_u4E2D_u4F7F_u7528_u7684nginx_u914D_u7F6E_u6587_u4EF6_u3002" class="headerlink" title="配置在docker中使用的nginx配置文件。"></a>配置在docker中使用的nginx配置文件。</h3><p>本示例中，nginx配置文件命名为jinli.conf。把它打包到镜像中，来给html5应用提供服务，这与平时直接在服务器上部署没有什么很大的差别，需要注意的就是：</p>
<ul>
<li>server_name 为 localhost，因为这个server_name是在docker容器内部使用的。</li>
<li>location 中的root文件夹是docker容器中的地址，不是宿主机的地址</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> localhost;</span><br><span class="line">    <span class="title">access_log</span> /src/log/jinli.access.log;</span><br><span class="line">    <span class="title">error_log</span> /src/log/jinli.<span class="built_in">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里你还可以选择根据需要配一些gzip等选项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">    <span class="title">root</span> /src/jinli/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将应用提交到github上，比如具体为：xiaohuruwei/jinli.git</p>
<p>以上已经包含全部必须的材料了，下面进入daocloud环节。</p>
<h2 id="u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03"><a href="#u4F7F_u7528daocloud_u8FDB_u884C_u6301_u7EED_u6784_u5EFA_u955C_u50CF_u4EE5_u53CA_u53D1_u5E03" class="headerlink" title="使用daocloud进行持续构建镜像以及发布"></a>使用daocloud进行持续构建镜像以及发布</h2><p>因为前面的步骤已经构建好了一个支持docker的代码版本，而且不需要外联像mysql这样的外部服务，因此可以直接将其当做一个单应用的镜像来构建。</p>
<p>在这方面，daocloud已经有了完善的<a href="http://docs.daocloud.io/" target="_blank" rel="external">文档</a>，可以直接参考其中的创建新项目章节，以及持续集成章节。</p>
<ul>
<li>第四节<a href="http://docs.daocloud.io/ci-on-daocloud" target="_blank" rel="external">创建新项目</a>，根据具体情况选择要绑定需要的git源</li>
<li>第五节<a href="http://docs.daocloud.io/ci-image-build" target="_blank" rel="external">持续集成和镜像构建</a>,在简单的html部署中，不需要了解daocloud.yml的写法</li>
<li>第九节中的<a href="http://docs.daocloud.io/app-deploy-mgmt/deploy-to-cluster" target="_blank" rel="external">向自由主机集群上发布应用</a></li>
</ul>
<p>在上面的过程中，核心部分如下：</p>
<ul>
<li>绑定git源</li>
<li>选择要部署的git仓库，并构建成镜像</li>
<li>部署到<strong>自有主机</strong>上</li>
<li>将后续自动持续部署的设置打开<ul>
<li>在「代码构建」具体项目的「设置」中，将持续集成打开，设置好镜像和持续集成的触发规则，比如：在向docker-support分支提交代码时，就触发自动持续集成。</li>
<li>在「应用列表」中的「发布」设置中，将自动发布打开。</li>
</ul>
</li>
</ul>
<h2 id="u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C"><a href="#u53D1_u5E03_u5B8C_u6210_u4E4B_u540E_u9700_u8981_u505A_u7684_u5DE5_u4F5C" class="headerlink" title="发布完成之后需要做的工作"></a>发布完成之后需要做的工作</h2><p>发布完成之后，可以在daocloud上看到所创建的容器的具体信息。包括映射到宿主机上的端口号等等，点击端口号后可以看到该应用的访问地址，打开可以测试是否部署成功了</p>
<p>为方便后面的叙述，这里假设映射出的端口号为8888。因为是发布到自己的主机上，所以还需要自己配置域名以及nginx反向代理来对外提供访问服务。假设有一个域名已经绑定在了自己的主机上，这里假设为xiaohuruwei.com.</p>
<p>登陆自己的主机，并配置nginx文件，如果是使用apt-get一类的包管理工具安装的，那么应该是在/etc/nginx/conf.d/目录下添加 jinli.conf:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/jinli.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/jinli.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以根据需要设置其他配置项</span></span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title">proxy_pass</span> <span class="url">http://127.0.0.1:8888</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问xiaohuruwei.com就可以看到内容了</p>
<p>另外，需要在使用daocloud的时候，将自动构建和持续发布都打开，这样下次使用时，只需要往github推代码时，触发了你设定的更新规则，就会持续构建镜像并发布了。</p>
<hr>
<h1 id="u6301_u7EED_u96C6_u6210_u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528"><a href="#u6301_u7EED_u96C6_u6210_u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528" class="headerlink" title="持续集成依赖外部服务的应用"></a>持续集成依赖外部服务的应用</h1><p>以django应用为例</p>
<h2 id="u672C_u6587_u9002_u7528_u7684_u573A_u666F"><a href="#u672C_u6587_u9002_u7528_u7684_u573A_u666F" class="headerlink" title="本文适用的场景"></a>本文适用的场景</h2><ul>
<li>拥有自己的主机</li>
<li>将主机添加到了daocloud上</li>
<li>只使用daocloud的自动构建和部署功能</li>
<li><strong>所依赖的外部服务已经（以daocke容器）存在于自己的主机上</strong>，镜像也要部署在自己的主机上。在部署的同时连接主机上已经存在的外部服务（如mysql，redis等）。</li>
</ul>
<h2 id="u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528"><a href="#u4F9D_u8D56_u5916_u90E8_u670D_u52A1_u7684_u5E94_u7528" class="headerlink" title="依赖外部服务的应用"></a>依赖外部服务的应用</h2><p>在docker领域中，如果一个docker镜像自身需要其他镜像来提供服务，就说这个镜像是带外部服务的。</p>
<p>以一个简单的django应用为例，如果这个django应用自身无法完成任务，而需要mysql或者其他数据库作为数据的持久化服务，那么这个django应用就是依赖外部服务的。</p>
<h2 id="u6784_u5EFA_u524D_u7684_u51C6_u5907"><a href="#u6784_u5EFA_u524D_u7684_u51C6_u5907" class="headerlink" title="构建前的准备"></a>构建前的准备</h2><p>准备同html5接近，因为需要连接外部服务，而且因为uwsig服务默认不支持静态文件的处理，所以多了一些对原代码的改造。</p>
<h3 id="u9879_u76EE_u7ED3_u6784"><a href="#u9879_u76EE_u7ED3_u6784" class="headerlink" title="项目结构"></a>项目结构</h3><p>首先是django应用的目录，比如有一个应用叫taikang，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taikang&#9;# &#39033;&#30446;&#26681;&#30446;&#24405;&#9;&#10;&#9500;&#9472;&#9472; Dockerfile&#9;# Dockerfile&#25991;&#20214;&#10;&#9500;&#9472;&#9472; logs&#9;&#10;&#9500;&#9472;&#9472; manage.py&#10;&#9500;&#9472;&#9472; Makefile&#9;# makefile&#25991;&#20214;&#10;&#9500;&#9472;&#9472; requirements.txt&#9;# &#24212;&#29992;&#20381;&#36182;&#30340;python&#24211;&#10;&#9500;&#9472;&#9472; templates&#10;&#9492;&#9472;&#9472; taikang&#9;&#9;# &#24212;&#29992;&#30446;&#24405;&#10;&#9;&#9500;&#9472;&#9472; __init__.py&#10;&#9;&#9500;&#9472;&#9472; models.py&#10;&#9;&#9500;&#9472;&#9472; settings.py   # django&#30340;&#37197;&#32622;&#25991;&#20214;&#10;&#9;&#9500;&#9472;&#9472; urls.py&#10;&#9;&#9500;&#9472;&#9472; views.py&#10;&#9;&#9492;&#9472;&#9472; wsgi.py</span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile_u6587_u4EF6_u7F16_u5199"><a href="#Dockerfile_u6587_u4EF6_u7F16_u5199" class="headerlink" title="Dockerfile文件编写"></a>Dockerfile文件编写</h3><p>Dockerfile文件的含义和html5部署中是完全相同的，这里为：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用python2.7.10版本作为基础服务</span></span><br><span class="line"><span class="built_in">from</span> python:<span class="number">2.7</span>.<span class="number">10</span></span><br><span class="line"></span><br><span class="line">将当前项目中的内容全<span class="built_ins">copy</span>到镜像中的 /src 目录下</span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">. /src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 安装django应用依赖的库，这里设置为豆瓣的pypi源</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash"><span class="built_in">cd</span> /src; pip install -r  requirements.txt -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 镜像暴露出8000端口</span></span><br><span class="line"><span class="built_in">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录为代码所在目录</span></span><br><span class="line"><span class="built_in">WORKDIR</span>  <span class="bash">/src</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># 设置应用启动命令</span></span><br><span class="line"><span class="built_in">CMD</span> <span class="bash">[<span class="string">"make"</span>, <span class="string">"start-uwsgi"</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Makefile_u6587_u4EF6_u7F16_u5199"><a href="#Makefile_u6587_u4EF6_u7F16_u5199" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h3><p>可以注意到，上述最后的启动命令中使用了make命令，这也是前面目录结构中Makefile文件的作用所在。有关makefile的知识，这里不再详述.<br>总之可以让你更方便的管理应用，这里直接贴出makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uwsig启动的host和端口 </span></span><br><span class="line"><span class="constant">host</span>:=0.0.0.0</span><br><span class="line"><span class="constant">port</span>:=8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug的时候直接使用django自带的服务启动</span></span><br><span class="line"><span class="title">debug:</span></span><br><span class="line">    ./manage.py runserver $(host):$(port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动uwsgi服务</span></span><br><span class="line">start-uwsgi:</span><br><span class="line">    uwsgi --socket $(host):$(port) \</span><br><span class="line">        --chdir $(shell pwd) \</span><br><span class="line">        --wsgi-file taikang/wsgi.py \</span><br><span class="line">        --master \</span><br><span class="line">        --process 4 \</span><br><span class="line">        --pidfile $(shell pwd)/uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止uwsgi服务</span></span><br><span class="line">stop-uwsgi:</span><br><span class="line">    uwsgi --stop uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载uwsgi服务</span></span><br><span class="line">reload-uwsgi:</span><br><span class="line">    uwsgi --reload uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集静态文件</span></span><br><span class="line"><span class="title">collectstatic:</span></span><br><span class="line">    ./manage.py collectstatic --noinput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="phony"><span class="keyword">.PHONY</span>: debug \</span></span><br><span class="line">    collectstatic \</span><br><span class="line">    reload-uwsgi \</span><br><span class="line">    start-uwsgi \</span><br><span class="line">    stop-uwsgi</span><br></pre></td></tr></table></figure>
<h3 id="u9759_u6001_u6587_u4EF6_u652F_u6301"><a href="#u9759_u6001_u6587_u4EF6_u652F_u6301" class="headerlink" title="静态文件支持"></a>静态文件支持</h3><p>在uwsgi提供服务时，静态文件需要单独进行处理，目前推荐使用django的<a href="https://github.com/evansd/whitenoise" target="_blank" rel="external">whitenoise库</a> 。可以方便的提供静态文件服务，仅仅需要几行配置。</p>
<h3 id="u901A_u8FC7_u73AF_u5883_u53D8_u91CF_u6765_u8FDE_u63A5_u670D_u52A1"><a href="#u901A_u8FC7_u73AF_u5883_u53D8_u91CF_u6765_u8FDE_u63A5_u670D_u52A1" class="headerlink" title="通过环境变量来连接服务"></a>通过环境变量来连接服务</h3><p>在使用docker部署项目，当需要连接外部的服务时，一般通过link + 环境变量的参数进行。而为了支持环境变量的形式，我们的django应用也要做一些相应的改变。具体就是修改settings.py中的配置。</p>
<p>修改settings.py文件，以mysql为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原来的mysql配置文件</span></span><br><span class="line"><span class="comment">#DATABASES = &#123;</span></span><br><span class="line"><span class="comment">#    'default': &#123;</span></span><br><span class="line"><span class="comment">#        'ENGINE': 'django.db.backends.mysql',</span></span><br><span class="line"><span class="comment">#        'NAME': 'starding_taikang',</span></span><br><span class="line"><span class="comment">#        'USER': 'root',</span></span><br><span class="line"><span class="comment">#        'PASSWORD': 'your_password_here',</span></span><br><span class="line"><span class="comment">#        'HOST': 'localhost',</span></span><br><span class="line"><span class="comment">#        'PORT': '3306'</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过获取环境变量的形式来获取服务</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 导入os库</span></span><br><span class="line">mysql_name = os.environ.get(<span class="string">'MYSQL_INSTANCE_NAME'</span>) <span class="keyword">or</span> <span class="string">"taikang"</span>  <span class="comment"># 获取数据库名称</span></span><br><span class="line">mysql_user = os.environ.get(<span class="string">'MYSQL_USERNAME'</span>) <span class="keyword">or</span> <span class="string">"root"</span>  <span class="comment"># 获取mysql用户名</span></span><br><span class="line">mysql_password = os.environ.get(<span class="string">'MYSQL_PASSWORD'</span>) <span class="keyword">or</span> <span class="string">"your_password"</span>  <span class="comment"># 获取密码</span></span><br><span class="line">mysql_host = os.environ.get(<span class="string">'MYSQL_ADDR'</span>) <span class="keyword">or</span> <span class="string">"127.0.0.1"</span>  <span class="comment"># 获取服务地址</span></span><br><span class="line">mysql_port = <span class="string">"3306"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用上面的变量代替字符串</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">'default'</span>: &#123;</span><br><span class="line">       <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">       <span class="string">'NAME'</span>: mysql_name,</span><br><span class="line">       <span class="string">'USER'</span>: mysql_user,</span><br><span class="line">       <span class="string">'PASSWORD'</span>: mysql_password,</span><br><span class="line">       <span class="string">'HOST'</span>: mysql_host,</span><br><span class="line">       <span class="string">'PORT'</span>: mysql_port</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528daocloud_u90E8_u7F72_u6784_u5EFA_u597D_u7684taikang_u9879_u76EE"><a href="#u4F7F_u7528daocloud_u90E8_u7F72_u6784_u5EFA_u597D_u7684taikang_u9879_u76EE" class="headerlink" title="使用daocloud部署构建好的taikang项目"></a>使用daocloud部署构建好的taikang项目</h2><p>步骤基本同html5部署，假设你完成镜像构建之后，产生的镜像地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daocloud.io/xiaohuruwei/taking:latest</span><br></pre></td></tr></table></figure>
<p>下一步在使用镜像部署的时候，需要连接外部服务，具体是手动编辑yaml文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">takang_test:&#10;  image: daocloud.io/xiaohuruwei/taking:latest&#10;  restart: always&#10;  external_links:&#10;  - mysql1:mysql&#9;  # &#21069;&#38754;&#30340;mysql1&#26159;&#20320;&#20027;&#26426;&#19978;&#24050;&#32463;&#23384;&#22312;&#30340;mysql&#30340;&#23481;&#22120;&#23454;&#20363;&#65292;&#20882;&#21495;&#21518;&#38754;&#26159;&#21035;&#21517;&#10;  ports:&#10;  - &#39;8000&#39;&#10;  environment:    # &#29615;&#22659;&#21464;&#37327;    &#10;  - MYSQL_ADDR=mysql</span><br></pre></td></tr></table></figure>
<p>但是我发现这种方法似乎有一些bug，如果上面的方法不成功，那么你就先直接部署，部署成功之后，再去修改yaml文件成为上面描述的样子。在修改yaml文件的时候，daocloud会提示重新部署，选择确定即可。</p>
<p>至此，django项目也部署完成了。然后同html5项目部署一样，把各种自动构建，自动发布的功能打开就行了。</p>
<p><strong>注意：</strong> 由于django项目是使用uwsgi部署的，直接访问daocloud给出的地址是错误的，这个时候必须配置nginx反向代理。</p>
<p>附上uwsgi部署的django nginx代理配置文件：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="title">server_name</span> xiaohuruwei.com;</span><br><span class="line">    <span class="title">access_log</span> /var/log/nginx/taikang.access.log;</span><br><span class="line">    <span class="title">error_log</span> /var/log/nginx/taikang.<span class="built_in">error</span>.log;</span><br><span class="line">    <span class="title">client_max_body_size</span> <span class="number">200m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title">gzip</span> <span class="built_in">on</span>;</span><br><span class="line">    <span class="title">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="title">gzip_buffers</span> <span class="number">16</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="title">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="title">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">    <span class="title">gzip_types</span> text/plain application/x-javascript text/javascript text/css application/xml;</span><br><span class="line">    <span class="title">gzip_vary</span> <span class="built_in">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="title">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title">include</span> uwsgi_params;</span><br><span class="line">        <span class="title">uwsgi_pass</span> <span class="number">127.0.0.1:32801</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762_u7684_u8BDD"><a href="#u5199_u5728_u524D_u9762_u7684_u8BDD" class="headerlink" title="写在前面的话"></a>写在前面的话</h1]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker——从隐喻说起]]></title>
    <link href="http://starding.github.io/2016/01/07/docker-a-metaphor/"/>
    <id>http://starding.github.io/2016/01/07/docker-a-metaphor/</id>
    <published>2016-01-07T05:44:42.000Z</published>
    <updated>2016-01-07T07:00:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</p>
<blockquote>
<p>Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.</p>
<p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。</p>
</blockquote>
<p>通过定义，可以模糊的知道docker是可以实现自动化部署之类功能的工具，但是并不能清楚的理解它到底牛逼在什么地方，又好在哪里。为了理解这一点，需要额外的工作要做，一种情况是你可以在长期使用docker的过程中，主键体会到docker的优势。但是对于一个从未接触过docker，甚至对部署都不是很了解的信任，应该怎么快速理解这一点呢？一个比较好的办法，就是借助于隐喻。</p>
<h2 id="u91CD_u8981_u7684_u9690_u55BB"><a href="#u91CD_u8981_u7684_u9690_u55BB" class="headerlink" title="重要的隐喻"></a>重要的隐喻</h2><p>在《代码大全》中，作者在欢迎章节之后，就开始介绍软件开发中的隐喻，并且强调了隐喻的重要性：</p>
<blockquote>
<p>计算机科学领域中有着搜友学科中最为丰富多彩的语言。你走进一间安全严密，温度精确控制在20℃的房间，并在里面发现了病毒（virus），特洛伊木马（Trojan horse），蠕虫（worm），臭虫（bug），逻辑炸弹（bomb），崩溃（crash），论坛口水战（flame），双绞线转换头（twisted sex changer），还有致命错误（fatal error）……在其他领域中，你能遇到这些吗？</p>
<p>这些形象的隐喻描述了软件领域总各种特定的现象和事物，像这样生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻，我们能更深刻的理解软件开发的过程。</p>
</blockquote>
<p>同样，要快速理解docker，抓出核心思想，隐喻是非常重要的</p>
<h3 id="u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002"><a href="#u5B57_u9762_u610F_u601D_uFF1Adocker_u2014_u2014_u7801_u5934_u5DE5_u4EBA_u3002" class="headerlink" title="字面意思：docker——码头工人。"></a>字面意思：docker——码头工人。</h3><p>docker的名称本身就带有隐喻的性质：在海洋物流中，一个非常重要的发明就是集装箱。</p>
<p>集装箱重要在哪里？为了理解这件事情，可以先考察一下集装箱出现之前的物流情况：货物生产出来之后，装箱，然后一箱一箱的搬到卡车上，然后再一箱一箱卸下来，送上火车，运送到码头附近的火车站，再一箱一箱卸下来，装上卡车，拉到货轮上，一箱一箱的装上去….</p>
<p>可以发现，大量的时间，人力 ，物力全部浪费在了中间的装卸上，在物流里面，货物真正在路上的时间是一定的，在交通技术得到改善之前，也很难去缩短。于是货物的装卸这部分时间，就成了物流中的瓶颈，而这个局面在集装箱出现之后，得到了很大的改善。</p>
<p>集装箱重要在它提供了一种通用的封装货物的标准规格（说白了指的就是它的尺寸，外形是符合一定标准的），这样就产生了一个优点，在物流运输中，只需要在运输前一次封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上，卸船之后直接再放上火车，卡车，运送到目的地。而且，集装箱本身的标准，使得它非常容易机械化操作，这样就节省了大量的人力物力。</p>
<h3 id="docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB"><a href="#docker_uFF08_u7801_u5934_u5DE5_u4EBA_uFF09_u6B63_u662F_u501F_u7528_u4E86_u96C6_u88C5_u7BB1_u7684_u9690_u55BB" class="headerlink" title="docker（码头工人）正是借用了集装箱的隐喻"></a>docker（码头工人）正是借用了集装箱的隐喻</h3><p>docker就像往集装箱里装货物的码头工人那样，它把应用打包成具有某种标准规格的集装箱，用计算机领域的语言来说，这种按照一定规格封装的集装箱叫「镜像」。其实就是将你原来的代码添加点内容，格式啥的，整出来的一个静态的应用。而且就像光盘镜像只能由特定的解析光盘镜像格式的软件来解析一样，这个镜像也只能由docker来解析。</p>
<p>集装箱减少了货物的运输工作量，那docker镜像又有什么相似的优势呢？首先可以看看docker出现之前的应用部署是啥样的。</p>
<h4 id="u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A"><a href="#u5728docker_u51FA_u73B0_u4E4B_u524D_uFF0C_u6BD4_u5982_u8BF4_u6211_u8981_u90E8_u7F72_u4E00_u4E2Adjango_u5E94_u7528_uFF0C_u8981_u505A_u54EA_u4E9B_u4E8B_u60C5_3A" class="headerlink" title="在docker出现之前，比如说我要部署一个django应用，要做哪些事情:"></a>在docker出现之前，比如说我要部署一个django应用，要做哪些事情:</h4><ul>
<li><p>首先我得有个python环境，比如我用的是python3，而你机器上是python2，那ok，先装个python3吧，一看装起来还挺麻烦，要先装各种依赖，还要解决一些可能的冲突，没办法硬着头皮上吧。</p>
</li>
<li><p>装完python之后，因为有pip这些神奇的工具，很快就装完django，需要的python库了。咦，发现还要装mysql，还用了redis。没办法，继续上吧，下载，安装，配置。费了九牛二虎之力终于搞完了。一天就这么过去了。</p>
</li>
<li><p>啥？你告诉我原来的服务器不用了，要换一台服务器？我靠，那重新来一遍吧，有了昨天的经验，只用了大半天就搞定了。</p>
</li>
<li><p>啥？你说咱们的应用做的太好，要进行推广，需要指导它们部署？我选择狗带，删代码走人。</p>
</li>
</ul>
<p>上面的描述可能有些夸张，但也绝不是罕有发生。在docker出现之前，这些正是运维人员很多时候都在做的事情，在不断的重复工作上，浪费了巨大的人力物力。</p>
<h4 id="docker_u51FA_u73B0_u4E4B_u540E"><a href="#docker_u51FA_u73B0_u4E4B_u540E" class="headerlink" title="docker出现之后"></a>docker出现之后</h4><p>docker正是在部署过程中，将上面那些重复的部分，封装在Docker镜像里，由docker自动化完成。只需要在第一次部署时，构建完毕一个可用的docker镜像。然后在以后使用的过程中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。</p>
<p>所需要的仅仅是安装了docker的服务器，一个Dockerfile文件，以及比较流畅的网络而已。</p>
<p>需要python3环境？直接 from python:3.x 搞定。</p>
<p>需要迁移服务器？ 直接把应用连带Dockerfile，volumes数据拷贝到新服务器上，几条命令又搞定</p>
<p>需要作为服务给别人使用？Dockerfile即是最清晰的部署文档，维护一个官方镜像即可。</p>
<p>到这个地方，你可能已经发现了，docker镜像成为了一种像集装箱那样的标准货件，谁想用我的服务，直接拉取镜像就完事了。容器跑起来之后，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p>
<h3 id="u4E00_u4E2A_u8BEF_u89E3"><a href="#u4E00_u4E2A_u8BEF_u89E3" class="headerlink" title="一个误解"></a>一个误解</h3><p>有人可能会问，我只有一台服务器，也不太可能会迁移。我的python服务，mysql服务，只需要部署一次，就可以在以后重复使用了。那这样docker对于我来说还有优势吗？毕竟docker也是有学习成本的。</p>
<p>如果你真的确信你的应用都是一次性的，而且只提供给自己使用，那么docker在这种场景下的优势不是特别明显：即便是docker，最初的构建也是需要有人做的，也是有工作量的。这和你一次性部署的工作量差不多。但是即便如此也是又有点的，它提供了一个干净，隔离的环境。</p>
<p>另外，很多人说docker改变了运维世界，这句话是从群体角度来说的，像mysql，python这样的使用群体众多的应用，以及会经常迁移，变动，重新部署的应用，docker化之后，整个群体所节省的时间，是非常巨大的。说是改变了运维的面貌毫不夸张。</p>
<p>但是对于纯粹的单次部署，具体到每一个人上面，其效率并非有质的提升，因为即使是集装箱，要往里面装东西，也是有不可避免的工作量的。而你第一次构建自己的镜像时，就像往集装箱里装东西是类似的，需要和直接在机器上部署差不多的工作量。这个时候，docker的效率提升是很小的。</p>
<p>但是，你真的确信，你所做的工作只是一次性的吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>首先来看维基百科的定义：</]]>
    </summary>
    
      <category term="docker" scheme="http://starding.github.io/tags/docker/"/>
    
      <category term="docker" scheme="http://starding.github.io/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中的闭包和装饰器]]></title>
    <link href="http://starding.github.io/2016/01/06/closure-decorator-in-python/"/>
    <id>http://starding.github.io/2016/01/06/closure-decorator-in-python/</id>
    <published>2016-01-06T13:51:03.000Z</published>
    <updated>2016-01-06T15:58:47.000Z</updated>
    <content type="html"><![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A"><a href="#u9996_u5148_u770B_u7EF4_u57FA_u767E_u79D1_u4E2D_u7684_u5B9A_u4E49_uFF1A" class="headerlink" title="首先看维基百科中的定义："></a>首先看维基百科中的定义：</h3><blockquote>
<p>In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure—unlike a plain function—allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope</p>
</blockquote>
<h3 id="u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A"><a href="#u7136_u540E_u8003_u5BDF_u5B9A_u4E49_uFF1A" class="headerlink" title="然后考察定义："></a>然后考察定义：</h3><p>上面这段话中有几个关键点：</p>
<ul>
<li>闭包是一项技术（technique）</li>
<li>一个闭包是一个函数和它所在的环境构成的记录</li>
<li>闭包，也就是上面说的记录，创建时，形成了函数中用到的自由变量（在封闭的词法作用域中定义，但在函数本地使用的变量）与其值的绑定关系。</li>
<li>闭包不同于普通的函数，它允许函数使用已经捕获（绑定）的变量，即使变量的定义在其作用域之外。</li>
</ul>
<p>直接考察定义，再加上对「闭包」一词的直觉，只能产生一种模糊的概念：这货大致是一个封闭的结构，它包括一个函数以及在函数外定义的变量。但是更深入的理解就还得看实际中的代码了。</p>
<p>一个python闭包的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建闭包的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at=<span class="number">0</span>)</span>:</span></span><br><span class="line">	count = [start_at]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">()</span>:</span></span><br><span class="line">		count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> incr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将闭包赋值给另一个变量</span></span><br><span class="line">counter1 = counter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次赋值给一个变量</span></span><br><span class="line">counter2 = counter(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，counter是一个创建闭包的函数，然后下面两句分别赋值给了两个不同的变量。这实际上产生了两个闭包函数，counter1和counter2，他们都包括一个函数本身，以及在函数外关联的一个作用域。</p>
<p>上面的两个闭包非常像实例化的两个对象，它们附加的那个函数之外的作用域互相独立。彼此之间互不影响。</p>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D"><a href="#u9996_u5148_u89E3_u91CA_u5B57_u9762_u610F_u601D" class="headerlink" title="首先解释字面意思"></a>首先解释字面意思</h3><p>装饰器这个名词，字面意思就是「装饰其他特定东西用的工具」。这个词里暗含着一层意思，就是被装饰的东西才是核心，而装饰用的工具，只不过是起到点缀作用，增加点额外的东西罢了。</p>
<p>以一个隐喻来做比：在圣诞节的时候，我们会拿一些小挂件去装饰圣诞树，那么这个时候的小挂件就是一个一个的小装饰器，被装饰的核心是圣诞树。这也暗含着，核心是圣诞树，这些小挂件只不过是给圣诞树增加一些其他有趣的特性罢了。</p>
<p>回到python中也是类似的，在python中，并不是像存在函数，字典，列表这些python元素一样，真的有一种对象类型叫装饰器。而是说，python中可以构造这样一种可调用对象（一般是函数或类来构造），它可以用于装饰别的对象，我们就把具有这样装饰功能的对象叫做装饰器。其实质不过是起到装饰作用的一些可调用对象。</p>
<p>那么这样就有两个问题：</p>
<ul>
<li>装饰什么呢？</li>
<li>又是如何实现装饰功能的呢？</li>
</ul>
<p>还是通过代码来看，一个python装饰器的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 做一些我们想要做的功能</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># 最后打印一下</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'in foo()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="string">'''</span><br><span class="line">	Decorator that reports the execution time.</span><br><span class="line">   '''</span></span><br><span class="line"><span class="decorator">   @wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		start  = time.clock()</span><br><span class="line">		result = func(*args, **kwargs)</span><br><span class="line">		end = time.clock()</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'used: &#123;0&#125;'</span>.format(end-start)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>首先要明白我们的程序主体是什么，我们想要用foo函数来完成一些特定的功能，最终再打印一下，所以我们的主体函数是foo。</p>
<p>同时，我们还想知道完成这件事所用的时间，那这正好可以通过装饰器来完成。于是我们构造了一个函数timeit作为装饰器，来装饰foo函数。</p>
<p>需要再次强调的一点是，装饰器timeit是用来装饰foo函数的，它只是给foo函数增加可以输出执行时间的特性，并不改变foo函数原来想要完成的功能。对foo函数原来所要做的事情，没有任何影响。</p>
<p>不过如果你留心一下，就会发现上面这个装饰器的实现中，用到了闭包这一技术（只是不那么明显，因为并没有带上一个额外的作用域，加上一个也是没问题的）。更准确的说，闭包和装饰器都是基于python中的可调用对象可以传递这一事实。</p>
<h3 id="u88C5_u9970_u5668_u6A21_u5F0F"><a href="#u88C5_u9970_u5668_u6A21_u5F0F" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>那么装饰器是怎么来的呢？其实这一概念来源于设计模式中的装饰器模式：在不改变核心调用对象的情况下，给它添加一些有趣的也可能很有用的特性。这正是“装饰”的意义所在。</p>
<p>这不仅既不用改动原来的核心对象，又达到了我们想要的目的，实在是高明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一版创建于：2016-01-06</p>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><h3 id="u9996_u5148_u770B_u7EF]]>
    </summary>
    
      <category term="python" scheme="http://starding.github.io/tags/python/"/>
    
      <category term="python" scheme="http://starding.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[缘起]]></title>
    <link href="http://starding.github.io/2016/01/05/hello-world/"/>
    <id>http://starding.github.io/2016/01/05/hello-world/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-01-10T06:50:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86" class="headerlink" title="仔细一想，我写博客也有一段时间了"></a>仔细一想，我写博客也有一段时间了</h3><p>回想这些年，我从大一的时候，就开始试着写博客了。当时涉及的技术比较少，大部分文章都是一些随笔，其内容也多是对一些社会事件的思考。</p>
<p>刚开始还不知道有独立博客这个概念，而且文章也都是发在qq空间的，原因是因为qq空间是我当时所知道的唯一能在网络上发表并保存日志的地方，也就将其档博客使用了。同时qq空间也有一些优点，因为它是基于qq这个社交平台的，自己所写的文章，总是可以被好友以及其他人看到，也会不时的得到一些反馈，这也是我当时的写作动力之一。</p>
<p>但是后来随着写的东西越来越偏向自己的专业，而且以前那些处处透露着中二思想的随笔类文章也很少写了，qq空间的优点越来越不明显。而且因为其巨差的写作体验（不流畅，仅支持富文本），写点简单的纯文字文章还行，元素稍微多点的文章就不行了。</p>
<h3 id="u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2"><a href="#u6211_u66FE_u5728_u5F88_u591A_u5730_u65B9_u5199_u8FC7_u535A_u5BA2" class="headerlink" title="我曾在很多地方写过博客"></a>我曾在很多地方写过博客</h3><p>于是我转向寻找其他可以写博客的地方。豆瓣，网易等等，但是都觉得不是写作体验太差，就是<br>广告太多，严重影响心情，而且这个时候我正好了解了独立博客这样东西。于是开始申请域名，购买服务器，建立自己的wordpress，寻找比较好的模板，一番折腾之后，终于搭起了自己的独立博客。</p>
<p>然而拥有了一年多独立博客之后，发现在写作本身上面甚至没有花在维护博客上面的时间长，各种费心巴力的问题不断，最终累觉不爱。</p>
<p>这个时候我意识到，写作才是本来的目的，也不想再费力气维护一个独立的博客。于是就开始了第二次寻找合适写作平台之旅。试了试网易的lofter等一波平台，发现只有简书还算差强人意，但是简书的可定制性又不太好。</p>
<p>这个时候我也突然发现，自己已经用过太多的平台，所写的内容也零零散散，非常不利于自己的积累和知识梳理。于是决定再寻找。</p>
<p>最终找到了github孪生兄弟：gitpages。</p>
<h3 id="u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86"><a href="#u6700_u7EC8_u8FD8_u662F_u805A_u5408_u5728_u4E00_u8D77_u4E86" class="headerlink" title="最终还是聚合在一起了"></a>最终还是聚合在一起了</h3><p>github本身就是程序员最常去的地方，gitpages评价又高，仅用了半天就搭起了一个半独立博客，一看效果，这正是我想要的。</p>
<p>于是开始了聚合之路…</p>
<p>后来无意中看到网上有人总结的<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">「写博客的三个阶段」</a>，表示深有同感，摘抄如下:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4ED4_u7EC6_u4E00_u60F3_uFF0C_u6211_u5199_u535A_u5BA2_u4E5F_u6709_u4E00_u6BB5_u65F6_u95F4_u4E86"><a href="#u4ED4_u7EC6_u4E00_u60F3_u]]>
    </summary>
    
      <category term="随笔" scheme="http://starding.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://starding.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
